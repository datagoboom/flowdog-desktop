===========================================
<App.jsx>
===========================================
import { ThemeProvider } from './contexts/ThemeContext';
import { DiagramProvider } from './contexts/DiagramContext';
import { LoggerProvider } from './contexts/LoggerContext';
import { ApiProvider } from './contexts/ApiContext';
import { Titlebar } from './components/Titlebar';
import Routes from './Routes';

function App() {
  return (
    <ThemeProvider>
      <ApiProvider>
        <LoggerProvider>
          <DiagramProvider>
            <Titlebar />
            <Routes />
          </DiagramProvider>
        </LoggerProvider>
      </ApiProvider>
    </ThemeProvider>
  );
}

export default App;

===========================================
<Routes.jsx>
===========================================
import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import Layout from './components/layout/Layout';
import Dashboard from './pages/Dashboard';
import Flows from './pages/Flows';
import Settings from './pages/Settings';
import NotFound from './pages/NotFound';

const router = createBrowserRouter([
  {
    path: '/',
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Dashboard />,
      },
      {
        path: 'flows',
        element: <Flows />,
      },
      {
        path: 'settings',
        element: <Settings />,
      },
      {
        path: '*',
        element: <NotFound />,
      },
    ],
  },
]);

const Routes = () => {
  return <RouterProvider router={router} />;
};

export default Routes; 
===========================================
<actions/formatAction.js>
===========================================
import Handlebars from 'handlebars';

export const executeFormatAction = async (config, inputData) => {
  const { template } = config;

  if (!template || !inputData) {
    return {
      success: false,
      error: { message: 'Template or input data is missing' }
    };
  }

  try {
    // Compile the template
    const compiledTemplate = Handlebars.compile(template);
    
    // Execute the template with the input data
    const result = compiledTemplate(inputData);
    
    // Try to parse the result as JSON if it looks like JSON
    let parsedResult = result;
    try {
      if (result.trim().startsWith('{') || result.trim().startsWith('[')) {
        parsedResult = JSON.parse(result);
      }
    } catch (e) {
      console.log('Result is not valid JSON, returning as string');
    }
    
    return {
      success: true,
      data: parsedResult
    };
  } catch (error) {
    return {
      success: false,
      error: { message: error.message }
    };
  }
};

export const validateFormatConfig = (config) => {
  const errors = [];

  if (!config.template) {
    errors.push('Template is required');
  }

  try {
    if (config.template) {
      Handlebars.compile(config.template);
    }
  } catch (error) {
    errors.push(`Invalid template: ${error.message}`);
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}; 
===========================================
<actions/httpAction.js>
===========================================
import axios from 'axios';
import Handlebars from 'handlebars';

/**
 * Templates a string using Handlebars
 * @param {string} template - The template string
 * @param {object} data - The data to use for templating
 * @returns {string} The templated string
 */
const templateString = (template, data) => {
  if (!template || !data) return template;

  console.log('Templating string:', template, data);
  try {
    const compiled = Handlebars.compile(template);
    return compiled(data);
  } catch (error) {
    console.error('Template error:', error);
    return template;
  }
};

/**
 * Templates an object's values using Handlebars
 * @param {Array} items - Array of key-value objects
 * @param {object} data - The data to use for templating
 * @returns {Array} Array with templated values
 */
const templateItems = (items = [], data) => {
  return items.map(item => ({
    ...item,
    key: templateString(item.key, data),
    value: templateString(item.value, data)
  }));
};

/**
 * Builds the final URL with query parameters
 * @param {string} baseUrl - The base URL
 * @param {Array} params - Array of parameter objects
 * @returns {string} The complete URL with query parameters
 */
const buildUrl = (baseUrl, params = []) => {
  if (!params.length) return baseUrl;
  
  const queryString = params
    .filter(param => param.key && param.value) // Only include params with both key and value
    .map(param => `${encodeURIComponent(param.key)}=${encodeURIComponent(param.value)}`)
    .join('&');
    
  return queryString ? `${baseUrl}${baseUrl.includes('?') ? '&' : '?'}${queryString}` : baseUrl;
};

/**
 * Parse body string into JSON if needed
 * @param {string|object} body - The request body
 * @returns {object} Parsed body
 */
const parseBody = (body) => {
  if (!body) return null;
  if (typeof body === 'object') return body;
  
  try {
    // Remove any extra whitespace and newlines
    const cleanBody = body.trim();
    return JSON.parse(cleanBody);
  } catch (error) {
    console.error('Failed to parse body:', error);
    return body; // Return original if parsing fails
  }
};

/**
 * Executes an HTTP request
 * @param {Object} config - The request configuration
 * @param {string} config.url - The URL to send the request to
 * @param {string} config.method - The HTTP method to use
 * @param {Array} config.headers - Array of header objects
 * @param {Array} config.params - Array of parameter objects
 * @param {string} config.body - The request body (for POST/PUT/PATCH)
 * @returns {Promise} The response data
 */
export const executeHttpAction = async (config, inputData = null) => {
  const { url, method, headers = [], params = [], body } = config;

  try {
    // Template the URL
    const templatedUrl = templateString(url, inputData);
    if (!templatedUrl) {
      throw new Error('URL is required');
    }

    // Create URL object and template query parameters
    const urlObj = new URL(templatedUrl);
    const templatedParams = templateItems(params, inputData);
    templatedParams.forEach(p => {
      if (p.key && p.value) {
        urlObj.searchParams.append(p.key, p.value);
      }
    });

    // Template headers
    const headerObj = {};
    const templatedHeaders = templateItems(headers, inputData);
    templatedHeaders.forEach(h => {
      if (h.key && h.value) {
        headerObj[h.key] = h.value;
      }
    });

    // Prepare request options
    const requestOptions = {
      method,
      headers: headerObj
    };

    // Handle body based on content type
    if (['POST', 'PUT', 'PATCH'].includes(method)) {
      if (body?.file) {
        // Handle file upload
        const formData = new FormData();
        formData.append('file', body.file, body.filename);
        requestOptions.body = formData;
        // Let the browser set the correct Content-Type for FormData
        delete requestOptions.headers['Content-Type'];
      } else if (body) {
        // Handle JSON/text body
        try {
          const templatedBody = templateString(body, inputData);
          requestOptions.body = JSON.stringify(JSON.parse(templatedBody));
          requestOptions.headers['Content-Type'] = 'application/json';
        } catch (error) {
          // If JSON parsing fails, send as plain text
          requestOptions.body = templateString(body, inputData);
          requestOptions.headers['Content-Type'] = 'text/plain';
        }
      } else if (inputData) {
        // Use inputData as body if no body specified
        requestOptions.body = JSON.stringify(inputData);
        requestOptions.headers['Content-Type'] = 'application/json';
      }
    }

    console.log('Making templated request:', {
      url: urlObj.toString(),
      method,
      headers: requestOptions.headers,
      body: requestOptions.body
    });

    const response = await fetch(urlObj.toString(), requestOptions);
    
    // Handle different response types
    let responseData;
    const contentType = response.headers.get('content-type');
    if (contentType?.includes('application/json')) {
      responseData = await response.json();
    } else {
      responseData = await response.text();
    }

    return {
      success: response.ok,
      response: {
        status: response.status,
        headers: Object.fromEntries(response.headers.entries()),
        data: responseData
      },
      error: response.ok ? null : { 
        message: typeof responseData === 'object' ? responseData.message : 'Request failed' 
      }
    };
  } catch (error) {
    console.error('HTTP request failed:', error);
    return {
      success: false,
      response: null,
      error: { message: error.message }
    };
  }
};

/**
 * Validates HTTP request configuration
 * @param {Object} config - The request configuration
 * @returns {Object} Validation result
 */
export const validateHttpConfig = (config) => {
  const errors = [];

  if (!config.url) {
    errors.push('URL is required');
  } else {
    try {
      new URL(config.url);
    } catch (e) {
      errors.push('Invalid URL format');
    }
  }

  if (!config.method) {
    errors.push('Method is required');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}; 
===========================================
<actions/index.js>
===========================================
import { executeHttpAction, validateHttpConfig } from './httpAction';
import { executeFormatAction, validateFormatConfig } from './formatAction';
import { executeParserAction, validateParserConfig } from './parserAction';

export * from './httpAction';
export * from './formatAction';
export * from './parserAction';
// We'll add more exports here as we create other actions 

// This will be used by the executor
export const nodeExecutors = {
  http: executeHttpAction,
  format: executeFormatAction,
  parser: executeParserAction,
  // ... other executors
};

export const nodeValidators = {
  http: validateHttpConfig,
  format: validateFormatConfig,
  parser: validateParserConfig,
  // ... other validators
}; 
===========================================
<actions/parserAction.js>
===========================================
import get from 'lodash/get';

const parseJQPath = (path) => {
  // Remove leading dot if present
  path = path.startsWith('.') ? path.slice(1) : path;
  
  // Handle array operations
  path = path.replace(/\[\](?=\.|$)/g, '[*]');
  
  return path;
};

const evaluateJQExpression = (data, query) => {
  try {
    if (!query) return data;
    
    const path = parseJQPath(query);
    
    // Handle array wildcards
    if (path.includes('[*]')) {
      const basePath = path.split('[*]')[0];
      const remainingPath = path.split('[*]').slice(1).join('');
      const array = get(data, basePath);
      
      if (Array.isArray(array)) {
        if (!remainingPath) return array;
        return array.map(item => get({ item }, `item${remainingPath}`));
      }
    }
    
    return get(data, path);
  } catch (error) {
    throw new Error(`Invalid query: ${error.message}`);
  }
};

export const executeParserAction = async (config, inputData) => {
  const { mode, query, inputExpression } = config;

  try {
    // Get the input data using the expression
    const targetData = inputExpression ? get(inputData, inputExpression) : inputData;
    
    if (targetData === undefined) {
      throw new Error(`Input data not found at path: ${inputExpression}`);
    }

    switch (mode) {
      case 'json':
        const result = evaluateJQExpression(targetData, query);
        return {
          success: true,
          data: result,
          error: null
        };

      case 'xml':
      case 'text':
        return {
          success: false,
          data: null,
          error: 'Parser mode not yet implemented'
        };

      default:
        return {
          success: false,
          data: null,
          error: 'Invalid parser mode'
        };
    }
  } catch (error) {
    return {
      success: false,
      data: null,
      error: error.message
    };
  }
};

export const validateParserConfig = (config) => {
  const errors = [];

  if (!config.mode) {
    errors.push('Parser mode is required');
  }

  if (!config.inputExpression) {
    errors.push('Input expression is required');
  }

  if (config.mode === 'json' && !config.query) {
    errors.push('JSON query is required');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}; 
===========================================
<components/Titlebar.jsx>
===========================================
import { Minus, Square, X } from 'lucide-react'
import logoSm from '../assets/logo_sm.png'

export function Titlebar() {
  const handleMinimize = () => {
    window.electron.ipcRenderer.send('minimize-window')
  }

  const handleMaximize = () => {
    window.electron.ipcRenderer.send('maximize-window')
  }

  const handleClose = () => {
    window.electron.ipcRenderer.send('close-window')
  }

  return (
    <div className="titlebar">
      <div className="titlebar-left">
        <img src={logoSm} alt="FlowDog Logo" className="titlebar-logo" />
        <span className="titlebar-text">FLOWDOG</span>
      </div>
      <div className="window-controls">
        <button onClick={handleMinimize} className="window-control-btn">
          <Minus size={16} />
        </button>
        <button onClick={handleMaximize} className="window-control-btn">
          <Square size={16} />
        </button>
        <button onClick={handleClose} className="window-control-btn">
          <X size={16} />
        </button>
      </div>
    </div>
  )
} 
===========================================
<components/Versions.jsx>
===========================================
import { useState } from 'react'

function Versions() {
  const [versions] = useState(window.electron.process.versions)

  return (
    <ul className="versions">
      <li className="electron-version">Electron v{versions.electron}</li>
      <li className="chrome-version">Chromium v{versions.chrome}</li>
      <li className="node-version">Node v{versions.node}</li>
    </ul>
  )
}

export default Versions

===========================================
<components/common/Box.jsx>
===========================================
import {useEffect} from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { cn } from '../../utils'

const BLUR_LEVELS = {
  0: 'backdrop-blur-none',
  1: 'backdrop-blur-sm', // 4px
  2: 'backdrop-blur-md', // 8px
  3: 'backdrop-blur-lg', // 12px
  4: 'backdrop-blur-xl', // 16px
  5: 'backdrop-blur-2xl', // 24px
  6: 'backdrop-blur-3xl', // 48px
};

const OPACITY_LEVELS = {
  0: 'bg-opacity-0',
  1: 'bg-opacity-5',
  2: 'bg-opacity-10',
  3: 'bg-opacity-20',
  4: 'bg-opacity-30',
  5: 'bg-opacity-40',
  6: 'bg-opacity-50',
  7: 'bg-opacity-60',
  8: 'bg-opacity-70',
  9: 'bg-opacity-80',
  10: 'bg-opacity-90',
};

const Box = ({
  children,
  className = '',
  blur = 5,
  opacity = 10,
  selected = false, 
  border = true,
  borderOpacity = 2,
  shadow = true,
  rounded = 'lg',
  padding = 4,
  as: Component = 'div',
  ...props
}) => {
  const { isDark } = useTheme();

  const baseClasses = cn(
    "transition-all duration-200 overflow-hidden border-2",
    BLUR_LEVELS[blur],
    OPACITY_LEVELS[opacity],
    
    // Border styles
    border && cn(
      "border",
      "border-slate-400",
      OPACITY_LEVELS[borderOpacity]
    ),
    
    // Shadow styles
    shadow && "shadow-md",
    shadow && (isDark ? "shadow-slate-900" : "shadow-slate-300"),
    
    // Padding
    padding && `p-${padding}`,
    
    // Background colors - increased contrast for light mode
    isDark ? "bg-slate-800" : "bg-slate-100",
    
    // Selection styles
    selected && "ring-1",
    selected && (isDark ? "ring-semantic-yellow" : "ring-slate-500")
  );
    
  return (
    <Component
      className={cn(baseClasses, className)}
      {...props}
    >
      {children}
    </Component>
  );
};

Box.propTypes = {
  children: PropTypes.node,
  className: PropTypes.string,
  blur: PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6]),
  opacity: PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
  border: PropTypes.bool,
  borderOpacity: PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
  shadow: PropTypes.bool,
  rounded: PropTypes.oneOf(['none', 'sm', 'md', 'lg', 'xl', '2xl', '3xl', 'full']),
  padding: PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 8, 10, 12, 16]),
  as: PropTypes.elementType,
};

export default Box; 
===========================================
<components/common/Button.jsx>
===========================================
import { forwardRef } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';

const Button = forwardRef(({
  children,
  variant = 'filled',
  color = 'blue',
  size = 'md',
  fullWidth = false,
  disabled = false,
  loading = false,
  circular = false,
  startIcon,
  endIcon,
  className = '',
  ...props
}, ref) => {
  const { isDark } = useTheme();

  const variants = {
    filled: `
      ${isDark ? 'bg-opacity-90' : 'bg-opacity-100'}
      hover:bg-opacity-80
      active:bg-opacity-70
      text-white
      shadow-sm
      hover:shadow-md
    `,
    light: `
      bg-opacity-10
      hover:bg-opacity-20
      active:bg-opacity-30
    `,
    outlined: `
      border-2
      bg-transparent
      hover:bg-opacity-10
      active:bg-opacity-20
    `,
    glass: `
      backdrop-blur-md
      ${isDark ? 'bg-dark-background/30' : 'bg-light-background/30'}
      hover:bg-opacity-40
      active:bg-opacity-50
      border
      border-opacity-20
    `,
    text: `
    ${color !== 'white' ? `text-semantic-${color}` : 'text-white'}
      bg-transparent
      hover:bg-opacity-10
      active:bg-opacity-20
    `,
  };

  const sizes = circular ? {
    xs: 'w-6 h-6 p-0',
    sm: 'w-8 h-8 p-0',
    md: 'w-10 h-10 p-0',
    lg: 'w-12 h-12 p-0',
    xl: 'w-14 h-14 p-0',
  } : {
    xs: 'px-2.5 py-1.5 text-xs',
    sm: 'px-3 py-2 text-sm',
    md: 'px-4 py-2 text-base',
    lg: 'px-5 py-2.5 text-lg',
    xl: 'px-6 py-3 text-xl',
  };

  const baseClasses = `
    inline-flex
    items-center
    justify-center
    gap-2
    font-medium
    transition-all
    duration-200
    ${circular ? 'rounded-full aspect-square p-0' : 'rounded-lg'}
    ${fullWidth ? 'w-full' : ''}
    ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
    ${loading ? 'cursor-wait' : ''}
    ${sizes[size]}
  `;

  const colorClasses = variant !== undefined ? `
    ${variant === 'filled' ? `bg-${color}-500` : ''}
    ${variant === 'outlined' ? `border-${color}-500 text-${color}-500` : ''}
    ${variant === 'light' ? `bg-${color}-500 text-${color}-500` : ''}
    ${variant === 'text' ? `text-${color}${color == 'white' ? '' : '-500'}` : ''}
  ` : '';

  const LoadingSpinner = () => (
    <svg
      className="animate-spin h-5 w-5"
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      />
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      />
    </svg>
  );

  return (
    <button
      ref={ref}
      disabled={disabled || loading}
      className={`
        ${baseClasses}
        ${variants[variant]}
        ${colorClasses}
        ${className}
      `.trim()}
      {...props}
    >
      {loading && <LoadingSpinner />}
      {!loading && startIcon && (
        <span className="inline-flex shrink-0">{startIcon}</span>
      )}
      {(!circular || !startIcon) && children}
      {!loading && endIcon && (
        <span className="inline-flex shrink-0">{endIcon}</span>
      )}
    </button>
  );
});

Button.displayName = 'Button';

Button.propTypes = {
  children: PropTypes.node.isRequired,
  variant: PropTypes.oneOf(['filled', 'light', 'outlined', 'glass', 'text']),
  color: PropTypes.oneOf(['blue', 'green', 'red', 'purple', 'orange']),
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  fullWidth: PropTypes.bool,
  disabled: PropTypes.bool,
  loading: PropTypes.bool,
  circular: PropTypes.bool,
  startIcon: PropTypes.node,
  endIcon: PropTypes.node,
  className: PropTypes.string,
};

export default Button; 
===========================================
<components/common/ButtonGroup.jsx>
===========================================
import PropTypes from 'prop-types';
import { Children, cloneElement } from 'react';

const ButtonGroup = ({
  children,
  variant,
  color,
  size,
  vertical = false,
  fullWidth = false,
  className = '',
  ...props
}) => {
  const childrenArray = Children.toArray(children);

  const groupClasses = `
    inline-flex
    ${vertical ? 'flex-col' : 'flex-row'}
    ${fullWidth ? 'w-full' : ''}
  `;

  const getChildClasses = (index) => {
    if (vertical) {
      if (index === 0) return 'rounded-t-lg rounded-b-none';
      if (index === childrenArray.length - 1) return 'rounded-b-lg rounded-t-none';
      return 'rounded-none';
    }
    
    if (index === 0) return 'rounded-r-none';
    if (index === childrenArray.length - 1) return 'rounded-l-none';
    return 'rounded-none';
  };

  return (
    <div
      className={`
        ${groupClasses}
        ${className}
      `.trim()}
      {...props}
    >
      {Children.map(children, (child, index) => {
        if (!child) return null;

        return cloneElement(child, {
          variant: variant || child.props.variant,
          color: color || child.props.color,
          size: size || child.props.size,
          className: `
            ${child.props.className || ''}
            ${getChildClasses(index)}
            ${vertical ? '' : index !== 0 ? '-ml-px' : ''}
          `.trim(),
        });
      })}
    </div>
  );
};

ButtonGroup.propTypes = {
  children: PropTypes.node.isRequired,
  variant: PropTypes.oneOf(['filled', 'light', 'outlined', 'glass', 'text']),
  color: PropTypes.oneOf(['blue', 'green', 'red', 'purple', 'orange']),
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  vertical: PropTypes.bool,
  fullWidth: PropTypes.bool,
  className: PropTypes.string,
};

export default ButtonGroup; 
===========================================
<components/common/Card.jsx>
===========================================
import PropTypes from 'prop-types';
import Box from './Box';
import Stack from './Stack';
import { H4, Body1 } from './Typography';
import Divider from './Divider';
import Image from './Image';
import { cn } from '../../utils';
import { useTheme } from '../../contexts/ThemeContext';
const Card = ({
  variant = 'default',
  children,
  className = '',
  hover = true,
  blur = 2,
  opacity = 6,
  ...props
}) => {
  const { isDark } = useTheme();

  return (
    <Box
      className={`
        ${variant === 'node' ? 'p-[4px]' : ''}
        ${variant === 'node' && isDark ? 'bg-slate-800' : 'bg-slate-300'}
        ${className}
      `.trim()}
      blur={blur}
      opacity={opacity}
      {...props}
    >
      {variant === 'default' && children}
      {variant === 'node' && (
        <div className={cn(
          "border border-dashed",
          isDark ? "border-white/20" : "border-slate-400",
          isDark ? "bg-slate-700/20" : "bg-white",
          "rounded-md",
          "w-full h-full flex items-center justify-center",
          "p-0.5"
        )}
        >
          {children}
        </div>
      )}
    </Box>
  );
};

const CardHeader = ({
  title,
  subtitle,
  image,
  action,
  className = '',
  ...props
}) => {
  return (
    <div className={`space-y-4 ${className}`.trim()} {...props}>
      {image && (
        <div className="-mx-4 -mt-4 mb-4">
          <Image
            {...image}
            className="w-full"
            rounded="t-lg"
          />
        </div>
      )}
      <div className="flex justify-between items-start gap-4">
        <Stack spacing={1}>
          {title && (typeof title === 'string' ? <H4>{title}</H4> : title)}
          {subtitle && (typeof subtitle === 'string' ? <Body1>{subtitle}</Body1> : subtitle)}
        </Stack>
        {action && (
          <div className="flex-shrink-0">
            {action}
          </div>
        )}
      </div>
    </div>
  );
};

const CardContent = ({
  children,
  className = '',
  ...props
}) => {
  return (
    <div className={`py-2 ${className}`.trim()} {...props}>
      {children}
    </div>
  );
};

const CardFooter = ({
  children,
  className = '',
  divider = true,
  ...props
}) => {
  return (
    <>
      {divider && <Divider spacing={2} />}
      <div 
        className={`
          flex
          items-center
          justify-between
          gap-4
          pt-2
          ${className}
        `.trim()}
        {...props}
      >
        {children}
      </div>
    </>
  );
};

// PropTypes
Card.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  hover: PropTypes.bool,
  blur: PropTypes.number,
  opacity: PropTypes.number,
};

CardHeader.propTypes = {
  title: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  subtitle: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  image: PropTypes.shape(Image.propTypes),
  action: PropTypes.node,
  className: PropTypes.string,
};

CardContent.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
};

CardFooter.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  divider: PropTypes.bool,
};

// Compound components
Card.Header = CardHeader;
Card.Content = CardContent;
Card.Footer = CardFooter;

export default Card; 
===========================================
<components/common/Checkbox.jsx>
===========================================
import { forwardRef } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { Body2 } from './Typography';

const Checkbox = forwardRef(({
  label,
  error,
  helper,
  disabled = false,
  className = '',
  containerClassName = '',
  size = 'md',
  indeterminate = false,
  ...props
}, ref) => {
  const { isDark } = useTheme();

  const sizes = {
    sm: 'w-4 h-4',
    md: 'w-5 h-5',
    lg: 'w-6 h-6'
  };

  const labelSizes = {
    sm: 'text-sm',
    md: 'text-base',
    lg: 'text-lg'
  };

  return (
    <div className={`${containerClassName}`.trim()}>
      <label className={`
        inline-flex
        items-center
        ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
      `.trim()}>
        <div className="relative">
          <input
            type="checkbox"
            ref={(elem) => {
              if (elem) {
                elem.indeterminate = indeterminate;
              }
              if (typeof ref === 'function') {
                ref(elem);
              } else if (ref) {
                ref.current = elem;
              }
            }}
            disabled={disabled}
            className={`
              appearance-none
              rounded
              border-2
              ${isDark ? 'border-dark-comment' : 'border-light-comment'}
              ${isDark ? 'bg-dark-background' : 'bg-light-background'}
              checked:border-blue-500
              checked:bg-blue-500
              disabled:opacity-50
              disabled:cursor-not-allowed
              transition-all
              duration-200
              ${sizes[size]}
              ${className}
            `.trim()}
            {...props}
          />
          <div className={`
            absolute
            inset-0
            pointer-events-none
            flex
            items-center
            justify-center
            transition-opacity
            ${props.checked || indeterminate ? 'opacity-100' : 'opacity-0'}
          `}>
            {indeterminate ? (
              <div className={`
                bg-white
                ${size === 'sm' ? 'w-2 h-0.5' : size === 'md' ? 'w-2.5 h-0.5' : 'w-3 h-0.5'}
              `} />
            ) : (
              <svg
                className="stroke-white fill-none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                strokeWidth="3"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M5 13l4 4L19 7"
                />
              </svg>
            )}
          </div>
        </div>
        
        {label && (
          <span className={`
            ml-2
            ${labelSizes[size]}
            ${isDark ? 'text-dark-foreground' : 'text-light-foreground'}
          `.trim()}>
            {label}
          </span>
        )}
      </label>

      {(error || helper) && (
        <Body2
          className={`
            mt-1
            ${error ? 'text-red-500' : isDark ? 'text-dark-comment' : 'text-light-comment'}
          `.trim()}
        >
          {error || helper}
        </Body2>
      )}
    </div>
  );
});

Checkbox.displayName = 'Checkbox';

Checkbox.propTypes = {
  label: PropTypes.string,
  error: PropTypes.string,
  helper: PropTypes.string,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  containerClassName: PropTypes.string,
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  indeterminate: PropTypes.bool,
  checked: PropTypes.bool,
};

export default Checkbox; 
===========================================
<components/common/CodeEditor.jsx>
===========================================
import { useRef, useEffect, useState } from 'react';
import hljs from 'highlight.js';
import { useDiagram } from '../../contexts/DiagramContext';
import { useTheme } from '../../contexts/ThemeContext';

export default function CodeEditor({ value = '', node, language, updateField }) {
  const overlayRef = useRef(null);
  const editorRef = useRef(null);
  const { isDark } = useTheme();
  const { updateNodeData } = useDiagram();
  const [rows, setRows] = useState(1);
  const [localValue, setLocalValue] = useState(value);
  const [highlightedCode, setHighlightedCode] = useState('');

  useEffect(() => {
    // Dynamic import of the CSS based on theme
    if (isDark) {
      import('../../../../../node_modules/highlight.js/styles/github.css');
    } else {
      import('../../../../../node_modules/highlight.js/styles/stackoverflow-dark.css');
    }
  }, [isDark]);
  
  // Update local value when prop value changes
  useEffect(() => {
    setLocalValue(value);
  }, [value]);

  // Update highlighted code when value changes
  useEffect(() => {
    if (language && localValue) {
      const highlighted = hljs.highlight(localValue, { language }).value;
      setHighlightedCode(highlighted);
    }
  }, [localValue, language]);

  const handleChange = (newValue) => {
    setLocalValue(newValue);
    
    if (node && updateField) {
      // Update just the specific field instead of the entire data object
      updateNodeData(node.id, updateField, newValue);

      console.log('Updated node field:', {
        field: updateField,
        value: newValue
      });
      
      const lines = newValue.split('\n').length;
      setRows(Math.max(lines, 1));
    }
  };

  const formatJSON = (value) => {
    try {
      return JSON.stringify(JSON.parse(value), null, 2);
    } catch (e) {
      return value;
    }
  };

  // Sync scroll between editor and highlight overlay
  useEffect(() => {
    const syncScroll = (e) => {
      if (overlayRef.current) {
        overlayRef.current.scrollTop = e.target.scrollTop;
      }
    };

    const editor = editorRef.current;
    editor?.addEventListener('scroll', syncScroll);
    return () => editor?.removeEventListener('scroll', syncScroll);
  }, []);

  return (
    <div className={`relative rounded border ${isDark ? 'border-slate-600 bg-slate-800' : 'border-slate-300 bg-slate-50'}`}>
      {language && (
        <div 
          ref={overlayRef}
          className="absolute inset-0 overflow-auto pointer-events-none h-full"
          style={{ 
            padding: '0.75rem'
          }}
        >
          <pre>
            <code 
              dangerouslySetInnerHTML={{ __html: highlightedCode || ' ' }}
              style={{ 
                fontFamily: 'monospace',
                fontSize: '14px',
                lineHeight: 1.5
              }}
            />
          </pre>
        </div>
      )}
      <textarea
        ref={editorRef}
        value={localValue}
        onChange={(e) => handleChange(e.target.value)}
        spellCheck="false"
        className={`
          relative block w-full h-full resize-none 
          bg-transparent p-3 font-mono text-transparent 
          outline-none border-none
          ${isDark ? 'caret-slate-300' : 'caret-slate-700'}
        `}
        style={{ 
          minHeight: `${rows * 1.5}rem`,
          lineHeight: 1.5,
          fontSize: '14px'
        }}
        rows={rows}
        onBlur={language === 'json' ? () => handleChange(formatJSON(localValue)) : null}
      />
    </div>
  );
}
===========================================
<components/common/Container.jsx>
===========================================
import PropTypes from 'prop-types';

const Container = ({ 
  children, 
  maxWidth = 'max-w-7xl', // default to Tailwind's max-w-7xl (1280px)
  padding = 'px-4 sm:px-6 lg:px-8', // responsive padding
  className = '',
  fluid = false, // if true, container will be full width
}) => {
  return (
    <div
      className={`
        mx-auto
        w-full
        ${fluid ? 'max-w-none' : maxWidth}
        ${padding}
        ${className}
      `.trim()}
    >
      {children}
    </div>
  );
};

Container.propTypes = {
  children: PropTypes.node.isRequired,
  maxWidth: PropTypes.string,
  padding: PropTypes.string,
  className: PropTypes.string,
  fluid: PropTypes.bool,
};

export default Container; 
===========================================
<components/common/Divider.jsx>
===========================================
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';

const Divider = ({
  orientation = 'horizontal',
  thickness = 1,
  opacity = 2,
  spacing = 4,
  className = '',
  text,
  ...props
}) => {
  const { isDark } = useTheme();

  const OPACITY_LEVELS = {
    1: 'opacity-5',
    2: 'opacity-10',
    3: 'opacity-20',
    4: 'opacity-30',
    5: 'opacity-40',
  };

  const baseClasses = `
    ${isDark ? 'bg-dark-foreground' : 'bg-light-foreground'}
    ${OPACITY_LEVELS[opacity]}
    transition-all
    duration-200
  `;

  if (orientation === 'vertical') {
    return (
      <div
        className={`
          inline-block
          h-full
          px-${spacing}
          ${className}
        `.trim()}
        {...props}
      >
        <div
          className={`
            ${baseClasses}
            w-${thickness}
            h-full
          `.trim()}
        />
      </div>
    );
  }

  if (text) {
    return (
      <div
        className={`
          flex
          items-center
          gap-4
          py-${spacing}
          ${className}
        `.trim()}
        {...props}
      >
        <div className={`${baseClasses} h-${thickness} flex-grow`} />
        <span className={`
          text-sm
          whitespace-nowrap
          ${isDark ? 'text-dark-comment' : 'text-light-comment'}
        `}>
          {text}
        </span>
        <div className={`${baseClasses} h-${thickness} flex-grow`} />
      </div>
    );
  }

  return (
    <div
      className={`
        py-${spacing}
        ${className}
      `.trim()}
      {...props}
    >
      <div
        className={`
          ${baseClasses}
          h-${thickness}
          w-full
        `.trim()}
      />
    </div>
  );
};

Divider.propTypes = {
  orientation: PropTypes.oneOf(['horizontal', 'vertical']),
  thickness: PropTypes.oneOf([1, 2, 3, 4]),
  opacity: PropTypes.oneOf([1, 2, 3, 4, 5]),
  spacing: PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 8, 10]),
  className: PropTypes.string,
  text: PropTypes.string,
};

export default Divider; 
===========================================
<components/common/FileUpload.jsx>
===========================================
import { memo, useCallback, useRef, useState } from 'react';
import { Upload, X } from 'lucide-react';
import { cn } from '../../utils';
import Button from './Button';

const FileUpload = memo(({
  value,
  onChange,
  onClear,
  accept,
  maxSize,
  className,
  disabled,
  ...props
}) => {
  const inputRef = useRef(null);
  const [fileName, setFileName] = useState(null);

  const handleFileChange = useCallback((e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    // Check file size if maxSize is provided (in bytes)
    if (maxSize && file.size > maxSize) {
      console.error(`File size exceeds ${maxSize / 1024 / 1024}MB limit`);
      return;
    }

    setFileName(file.name);
    onChange?.(file);
    // Reset input value to allow selecting the same file again
    e.target.value = '';
  }, [onChange, maxSize]);

  const handleClear = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    onClear?.();
    if (inputRef.current) {
      inputRef.current.value = '';
      setFileName(null);
    }
  }, [onClear]);

  const handleClick = useCallback((e) => {
    if (inputRef.current && !disabled) {
      inputRef.current.click();
    }
  }, [disabled]);

  const formatFileSize = (bytes) => {
    if (!bytes || isNaN(bytes)) return '0 KB';
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
  };

  return (
    <div className={cn("space-y-2", className)} {...props}>
      <div
        onClick={handleClick}
        className={cn(
          "flex items-center justify-center gap-2 px-4 py-2 rounded-md",
          "bg-slate-100 dark:bg-slate-800",
          "border border-slate-200 dark:border-slate-700",
          "cursor-pointer",
          disabled && "opacity-50 cursor-not-allowed"
        )}
      >
        <input
          ref={inputRef}
          type="file"
          className="hidden"
          onChange={handleFileChange}
          accept={accept}
          disabled={disabled}
        />
        <div className="flex items-center justify-center gap-2 flex-1">
          <Upload className="w-4 h-4 shrink-0" />
          <span className="truncate">
            {fileName || 'Choose File'}
          </span>
        </div>
        {value && (
          <button
            type="button"
            onClick={handleClear}
            disabled={disabled}
            className={cn(
              "p-1 hover:bg-slate-200 dark:hover:bg-slate-700 rounded",
              "transition-colors duration-200"
            )}
          >
            <X className="w-4 h-4" />
          </button>
        )}
      </div>
      {value?.size && (
        <div className="text-xs text-slate-500 px-2 text-center">
          Size: {formatFileSize(value.size)}
          {value.type && ` • Type: ${value.type}`}
        </div>
      )}
    </div>
  );
});

FileUpload.displayName = 'FileUpload';

export default FileUpload;
===========================================
<components/common/Form.jsx>
===========================================
import { createContext, useContext, useCallback } from 'react';
import PropTypes from 'prop-types';

const FormContext = createContext({});

export const useForm = () => useContext(FormContext);

const Form = ({
  children,
  onSubmit,
  onChange,
  initialValues = {},
  validate,
  className = '',
  ...props
}) => {
  const handleSubmit = useCallback(async (event) => {
    event.preventDefault();
    
    const formData = new FormData(event.target);
    const values = Object.fromEntries(formData.entries());

    // Handle array values (multiple select, checkboxes, etc.)
    for (const [key, value] of formData.entries()) {
      if (key.endsWith('[]')) {
        const arrayKey = key.slice(0, -2);
        if (!values[arrayKey]) {
          values[arrayKey] = formData.getAll(key);
        }
        delete values[key];
      }
    }

    // Custom validation
    if (validate) {
      try {
        const errors = await validate(values);
        if (errors && Object.keys(errors).length > 0) {
          // You can implement your own error handling here
          console.error('Validation errors:', errors);
          return;
        }
      } catch (error) {
        console.error('Validation failed:', error);
        return;
      }
    }

    onSubmit?.(values, event);
  }, [onSubmit, validate]);

  const handleChange = useCallback((event) => {
    const formData = new FormData(event.target.form);
    const values = Object.fromEntries(formData.entries());
    onChange?.(values, event);
  }, [onChange]);

  return (
    <FormContext.Provider value={{ initialValues }}>
      <form
        onSubmit={handleSubmit}
        onChange={handleChange}
        className={`space-y-4 ${className}`.trim()}
        {...props}
      >
        {children}
      </form>
    </FormContext.Provider>
  );
};

Form.propTypes = {
  children: PropTypes.node.isRequired,
  onSubmit: PropTypes.func,
  onChange: PropTypes.func,
  initialValues: PropTypes.object,
  validate: PropTypes.func,
  className: PropTypes.string,
};

export default Form;
===========================================
<components/common/FormGroup.jsx>
===========================================
import { createContext, useContext, useCallback } from 'react';
import PropTypes from 'prop-types';

const FormContext = createContext({});

export const useForm = () => useContext(FormContext);

const Form = ({
  children,
  onSubmit,
  onChange,
  initialValues = {},
  validate,
  className = '',
  ...props
}) => {
  const handleSubmit = useCallback(async (event) => {
    event.preventDefault();
    
    const formData = new FormData(event.target);
    const values = Object.fromEntries(formData.entries());

    // Handle array values (multiple select, checkboxes, etc.)
    for (const [key, value] of formData.entries()) {
      if (key.endsWith('[]')) {
        const arrayKey = key.slice(0, -2);
        if (!values[arrayKey]) {
          values[arrayKey] = formData.getAll(key);
        }
        delete values[key];
      }
    }

    // Custom validation
    if (validate) {
      try {
        const errors = await validate(values);
        if (errors && Object.keys(errors).length > 0) {
          // You can implement your own error handling here
          console.error('Validation errors:', errors);
          return;
        }
      } catch (error) {
        console.error('Validation failed:', error);
        return;
      }
    }

    onSubmit?.(values, event);
  }, [onSubmit, validate]);

  const handleChange = useCallback((event) => {
    const formData = new FormData(event.target.form);
    const values = Object.fromEntries(formData.entries());
    onChange?.(values, event);
  }, [onChange]);

  return (
    <FormContext.Provider value={{ initialValues }}>
      <form
        onSubmit={handleSubmit}
        onChange={handleChange}
        className={`space-y-4 ${className}`.trim()}
        {...props}
      >
        {children}
      </form>
    </FormContext.Provider>
  );
};

Form.propTypes = {
  children: PropTypes.node.isRequired,
  onSubmit: PropTypes.func,
  onChange: PropTypes.func,
  initialValues: PropTypes.object,
  validate: PropTypes.func,
  className: PropTypes.string,
};

export default Form;
===========================================
<components/common/Grid.jsx>
===========================================
import PropTypes from 'prop-types';

const GRID_SPACING = {
  0: 'gap-0',
  1: 'gap-1',
  2: 'gap-2',
  3: 'gap-3',
  4: 'gap-4',
  5: 'gap-5',
  6: 'gap-6',
  8: 'gap-8',
  10: 'gap-10',
};

const GRID_COLS = {
  1: 'grid-cols-1',
  2: 'grid-cols-2',
  3: 'grid-cols-3',
  4: 'grid-cols-4',
  5: 'grid-cols-5',
  6: 'grid-cols-6',
  7: 'grid-cols-7',
  8: 'grid-cols-8',
  9: 'grid-cols-9',
  10: 'grid-cols-10',
  11: 'grid-cols-11',
  12: 'grid-cols-12',
};

const GRID_SPANS = {
  1: 'col-span-1',
  2: 'col-span-2',
  3: 'col-span-3',
  4: 'col-span-4',
  5: 'col-span-5',
  6: 'col-span-6',
  7: 'col-span-7',
  8: 'col-span-8',
  9: 'col-span-9',
  10: 'col-span-10',
  11: 'col-span-11',
  12: 'col-span-12',
  full: 'col-span-full',
};

const BREAKPOINTS = ['sm', 'md', 'lg', 'xl', '2xl'];

export const Grid = ({ 
  children, 
  container = false,
  spacing = 4,
  cols = 12,
  className = '',
  ...props 
}) => {
  if (!container) {
    return <div className={className} {...props}>{children}</div>;
  }

  return (
    <div 
      className={`
        grid
        ${GRID_SPACING[spacing]}
        ${GRID_COLS[cols]}
        ${className}
      `.trim()}
      {...props}
    >
      {children}
    </div>
  );
};

export const GridItem = ({ 
  children, 
  span = 12,
  sm,
  md,
  lg,
  xl,
  xxl,
  className = '',
  ...props 
}) => {
  const responsiveClasses = [
    GRID_SPANS[span],
    sm && `sm:${GRID_SPANS[sm]}`,
    md && `md:${GRID_SPANS[md]}`,
    lg && `lg:${GRID_SPANS[lg]}`,
    xl && `xl:${GRID_SPANS[xl]}`,
    xxl && `2xl:${GRID_SPANS[xxl]}`,
  ].filter(Boolean).join(' ');

  return (
    <div 
      className={`
        ${responsiveClasses}
        ${className}
      `.trim()}
      {...props}
    >
      {children}
    </div>
  );
};

Grid.propTypes = {
  children: PropTypes.node.isRequired,
  container: PropTypes.bool,
  spacing: PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 8, 10]),
  cols: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
  className: PropTypes.string,
};

GridItem.propTypes = {
  children: PropTypes.node.isRequired,
  span: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'full']),
  sm: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'full']),
  md: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'full']),
  lg: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'full']),
  xl: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'full']),
  xxl: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 'full']),
  className: PropTypes.string,
}; 
===========================================
<components/common/IconButton.jsx>
===========================================
import { forwardRef } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';

const IconButton = forwardRef(({
  icon,
  variant = 'filled',
  color = 'blue',
  size = 'md',
  disabled = false,
  loading = false,
  className = '',
  ...props
}, ref) => {
  const { isDark } = useTheme();

  const variants = {
    filled: `
      ${isDark ? 'bg-opacity-90' : 'bg-opacity-100'}
      hover:bg-opacity-80
      active:bg-opacity-70
      text-white
      shadow-sm
      hover:shadow-md
    `,
    light: `
      bg-opacity-10
      hover:bg-opacity-20
      active:bg-opacity-30
    `,
    outlined: `
      border-2
      bg-transparent
      hover:bg-opacity-10
      active:bg-opacity-20
    `,
    glass: `
      backdrop-blur-md
      ${isDark ? 'bg-dark-background/30' : 'bg-light-background/30'}
      hover:bg-opacity-40
      active:bg-opacity-50
      border
      border-opacity-20
    `,
    text: `
      bg-transparent
      hover:bg-opacity-10
      active:bg-opacity-20
    `,
  };

  const colors = {
    blue: {
      base: 'blue-500',
      hover: 'blue-600',
      active: 'blue-700',
    },
    green: {
      base: 'green-500',
      hover: 'green-600',
      active: 'green-700',
    },
    red: {
      base: 'red-500',
      hover: 'red-600',
      active: 'red-700',
    },
    purple: {
      base: 'purple-500',
      hover: 'purple-600',
      active: 'purple-700',
    },
    orange: {
      base: 'orange-500',
      hover: 'orange-600',
      active: 'orange-700',
    },
  };

  const sizes = {
    xs: 'p-1 w-7 h-7',
    sm: 'p-1.5 w-8 h-8',
    md: 'p-2 w-10 h-10',
    lg: 'p-2.5 w-12 h-12',
    xl: 'p-3 w-14 h-14',
  };

  const iconSizes = {
    xs: 'w-4 h-4',
    sm: 'w-5 h-5',
    md: 'w-6 h-6',
    lg: 'w-7 h-7',
    xl: 'w-8 h-8',
  };

  const baseClasses = `
    inline-flex
    items-center
    justify-center
    rounded-full
    transition-all
    duration-200
    ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
    ${loading ? 'cursor-wait' : ''}
    ${sizes[size]}
  `;

  const colorClasses = variant !== 'glass' ? `
    ${variant === 'filled' ? `bg-${colors[color].base}` : ''}
    ${variant === 'outlined' ? `border-${colors[color].base} text-${colors[color].base}` : ''}
    ${variant === 'light' ? `bg-${colors[color].base} text-${colors[color].base}` : ''}
    ${variant === 'text' ? `text-${colors[color].base}` : ''}
  ` : '';

  const LoadingSpinner = () => (
    <svg
      className={`animate-spin ${iconSizes[size]}`}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      />
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      />
    </svg>
  );

  return (
    <button
      ref={ref}
      disabled={disabled || loading}
      className={`
        ${baseClasses}
        ${variants[variant]}
        ${colorClasses}
        ${className}
      `.trim()}
      {...props}
    >
      {loading ? (
        <LoadingSpinner />
      ) : (
        <span className={iconSizes[size]}>{icon}</span>
      )}
    </button>
  );
});

IconButton.displayName = 'IconButton';

IconButton.propTypes = {
  icon: PropTypes.node.isRequired,
  variant: PropTypes.oneOf(['filled', 'light', 'outlined', 'glass', 'text']),
  color: PropTypes.oneOf(['blue', 'green', 'red', 'purple', 'orange']),
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  disabled: PropTypes.bool,
  loading: PropTypes.bool,
  className: PropTypes.string,
};

export default IconButton; 
===========================================
<components/common/Image.jsx>
===========================================
import { useState } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';

const Image = ({
  src,
  alt,
  fallback = '📷',
  className = '',
  rounded = 'none',
  aspectRatio = 'auto',
  objectFit = 'cover',
  blur = true,
  ...props
}) => {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  const { isDark } = useTheme();

  const handleLoad = () => setIsLoading(false);
  const handleError = () => {
    setIsLoading(false);
    setHasError(true);
  };

  const baseClasses = `
    transition-all
    duration-300
    ${rounded ? `rounded-${rounded}` : ''}
    ${isLoading ? 'opacity-50 animate-pulse' : 'opacity-100'}
    ${blur ? 'hover:blur-sm' : ''}
  `;

  const containerClasses = `
    relative
    ${aspectRatio !== 'auto' ? `aspect-${aspectRatio}` : ''}
    ${className}
  `;

  if (hasError) {
    return (
      <div 
        className={`
          ${containerClasses}
          flex
          items-center
          justify-center
          bg-opacity-50
          ${isDark ? 'bg-dark-background' : 'bg-light-background'}
          ${baseClasses}
        `.trim()}
      >
        <span className="text-4xl">{fallback}</span>
      </div>
    );
  }

  return (
    <div className={containerClasses}>
      <img
        src={src}
        alt={alt}
        onLoad={handleLoad}
        onError={handleError}
        className={`
          ${baseClasses}
          w-full
          h-full
          object-${objectFit}
        `.trim()}
        {...props}
      />
    </div>
  );
};

Image.propTypes = {
  src: PropTypes.string.isRequired,
  alt: PropTypes.string.isRequired,
  fallback: PropTypes.string,
  className: PropTypes.string,
  rounded: PropTypes.oneOf(['none', 'sm', 'md', 'lg', 'xl', '2xl', '3xl', 'full']),
  aspectRatio: PropTypes.oneOf(['auto', 'square', 'video', '4/3', '16/9']),
  objectFit: PropTypes.oneOf(['contain', 'cover', 'fill', 'none', 'scale-down']),
  blur: PropTypes.bool,
};

export default Image; 
===========================================
<components/common/Input.jsx>
===========================================
import { forwardRef, useState, useRef, useEffect } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import Box from './Box';
import { Body2 } from './Typography';
import { cn } from '../../utils';
import { Search, X } from 'lucide-react';

const Input = forwardRef(({
  label,
  error,
  helper,
  startAdornment,
  endAdornment,
  fullWidth = false,
  disabled = false,
  className = '',
  containerClassName = '',
  size = 'md',
  variant = 'outlined',
  suggestions = [],
  onSuggestionSelect,
  showSuggestions = false,
  startIcon: StartIcon,
  endIcon: EndIcon,
  onClear,
  ...props
}, ref) => {
  const { isDark } = useTheme();
  const [isFocused, setIsFocused] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const inputRef = useRef(null);
  const dropdownRef = useRef(null);

  // Handle clicks outside of input and dropdown
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        (!inputRef.current || !inputRef.current.contains(event.target)) &&
        (!dropdownRef.current || !dropdownRef.current.contains(event.target))
      ) {
        setIsFocused(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Reset selected index when suggestions change
  useEffect(() => {
    setSelectedIndex(-1);
  }, [suggestions]);

  // Keyboard navigation
  const handleKeyDown = (e) => {
    if (!showSuggestions || !suggestions.length) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev < suggestions.length - 1 ? prev + 1 : prev
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => prev > 0 ? prev - 1 : -1);
        break;
      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0) {
          onSuggestionSelect?.(suggestions[selectedIndex]);
          setIsFocused(false);
        }
        break;
      case 'Escape':
        setIsFocused(false);
        break;
    }
  };

  const sizes = {
    sm: 'h-8 text-sm px-2',
    md: 'h-10 text-base px-3',
    lg: 'h-12 text-lg px-4'
  };

  const variants = {
    minimal: `
      border-0
      ${isDark ? 'bg-slate-700/30' : 'bg-slate-200/30'}
      focus:border-blue-500
    `,
    outlined: `
      border-2
      ${isDark ? 'border-dark-comment' : 'border-light-comment'}
      focus:border-blue-500
    `,
    filled: `
      ${isDark ? 'bg-slate-700' : 'bg-slate-200'}
      border-transparent
      focus:border-blue-500
    `,
    glass: `
      ${isDark ? 'bg-slate-700/30' : 'bg-slate-200/30'}
      border
      ${isDark ? 'border-slate-700' : 'border-slate-200'}
      focus:border-blue-500
    `
  };

  const baseStyles = cn(
    "relative transition-colors duration-200",
    "bg-white dark:bg-slate-800",
    "border rounded-md",
    "focus:outline-none focus:ring-2",
    {
      'w-full': fullWidth,
      'border-slate-300 dark:border-slate-600': !error,
      'border-semantic-red': error,
      'focus:border-blue-500 focus:ring-blue-500/20': !error,
      'focus:border-semantic-red focus:ring-semantic-red/20': error,
      'px-3 py-2 text-sm': size === 'md',
      'px-2 py-1 text-xs': size === 'sm',
      'px-4 py-3 text-base': size === 'lg',
      'bg-slate-100 dark:bg-slate-700': variant === 'filled',
      'bg-transparent': variant === 'ghost',
    }
  );

  return (
    <div className={cn("relative", fullWidth && "w-full", containerClassName)}>
      {label && (
        <label className={cn(
          "block mb-1.5 text-sm font-medium",
          isDark ? 'text-dark-foreground' : 'text-light-foreground',
          disabled && 'opacity-50'
        )}>
          {label}
        </label>
      )}

      <div className="relative">
        <div className="relative flex items-center">
          {StartIcon && (
            <StartIcon className="absolute left-3 text-slate-400" size={16} />
          )}
          <input
            ref={inputRef}
            disabled={disabled}
            className={cn(
              baseStyles,
              StartIcon && "pl-9",
              EndIcon && "pr-9",
              className
            )}
            onFocus={() => setIsFocused(true)}
            onKeyDown={handleKeyDown}
            {...props}
          />
          {EndIcon && (
            <div className="absolute right-3">
              {onClear ? (
                <button
                  type="button"
                  onClick={onClear}
                  className="p-1 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-full"
                >
                  <X size={14} className="text-slate-400" />
                </button>
              ) : (
                <EndIcon className="text-slate-400" size={16} />
              )}
            </div>
          )}
        </div>

        {/* Suggestions Dropdown */}
        {showSuggestions && isFocused && suggestions.length > 0 && (
          <div
            ref={dropdownRef}
            className={cn(
              "absolute z-50 w-full mt-1",
              "bg-white dark:bg-slate-800",
              "border border-slate-200 dark:border-slate-700",
              "max-h-[300px] overflow-auto"
            )}
          >
            {suggestions.map((suggestion, index) => (
              <div
                key={index}
                className={cn(
                  "px-3 py-2 text-sm cursor-pointer",
                  "hover:bg-slate-100 dark:hover:bg-slate-700",
                  selectedIndex === index && "bg-slate-100 dark:bg-slate-700",
                  "transition-colors duration-150"
                )}
                onClick={() => {
                  onSuggestionSelect?.(suggestion);
                  setIsFocused(false);
                }}
              >
                {suggestion}
              </div>
            ))}
          </div>
        )}
      </div>

      {(error || helper) && (
        <Body2 className={cn(
          "mt-1",
          error ? 'text-red-500' : isDark ? 'text-dark-comment' : 'text-light-comment'
        )}>
          {error || helper}
        </Body2>
      )}
    </div>
  );
});

Input.displayName = 'Input';

Input.propTypes = {
  label: PropTypes.string,
  error: PropTypes.string,
  helper: PropTypes.string,
  startAdornment: PropTypes.node,
  endAdornment: PropTypes.node,
  fullWidth: PropTypes.bool,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  containerClassName: PropTypes.string,
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  variant: PropTypes.oneOf(['outlined', 'filled', 'glass']),
  suggestions: PropTypes.array,
  onSuggestionSelect: PropTypes.func,
  showSuggestions: PropTypes.bool,
  startIcon: PropTypes.node,
  endIcon: PropTypes.node,
  onClear: PropTypes.func,
};

export default Input; 
===========================================
<components/common/Label.jsx>
===========================================
import { memo } from 'react';
import { cn } from '../../utils';
import PropTypes from 'prop-types';

const Label = memo(({ 
  children, 
  color = 'slate', // default color
  className,
  ...props 
}) => {
  const colorClasses = {
    slate: 'bg-slate-100 text-slate-700 dark:bg-slate-800 dark:text-slate-300',
    red: 'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400',
    green: 'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400',
    blue: 'bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400',
    yellow: 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400',
    purple: 'bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-400',
    cyan: 'bg-cyan-100 text-cyan-700 dark:bg-cyan-900/30 dark:text-cyan-400',
  };

  return (
    <span
      className={cn(
        'inline-flex items-center px-2 py-1',
        'rounded text-xs font-medium',
        colorClasses[color],
        className
      )}
      {...props}
    >
      {children}
    </span>
  );
});

Label.displayName = 'Label';

Label.propTypes = {
  children: PropTypes.node.isRequired,
  color: PropTypes.oneOf(['slate', 'red', 'green', 'blue', 'yellow', 'purple', 'cyan']),
  className: PropTypes.string
};

export default Label; 
===========================================
<components/common/Navbar.jsx>
===========================================
import { useState } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import Box from './Box';
import IconButton from './IconButton';
import { H4 } from './Typography';

const Navbar = ({
  brand,
  logo,
  children,
  actions,
  sticky = true,
  blur = 2,
  opacity = 8,
  className = '',
  height = 64,
  mobileBreakpoint = 'md',
  ...props
}) => {
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const { isDark } = useTheme();

  const toggleMobileMenu = () => {
    setIsMobileMenuOpen(!isMobileMenuOpen);
  };

  return (
    <Box
      as="nav"
      className={`
        ${sticky ? 'sticky top-0 z-50' : ''}
        ${className}
      `.trim()}
      blur={blur}
      opacity={opacity}
      {...props}
    >
      <div
        className="px-4 mx-auto"
        style={{ height }}
      >
        <div className="flex items-center justify-between h-full">
          {/* Brand/Logo Section */}
          <div className="flex items-center gap-3">
            {logo && (
              <div className="flex-shrink-0">
                {logo}
              </div>
            )}
            {brand && (
              <H4 className="font-semibold whitespace-nowrap">
                {brand}
              </H4>
            )}
          </div>

          {/* Desktop Navigation */}
          <div className={`
            hidden
            ${mobileBreakpoint}:flex
            items-center
            gap-1
          `}>
            {children}
          </div>

          {/* Actions Section */}
          <div className={`
            hidden
            ${mobileBreakpoint}:flex
            items-center
            gap-2
          `}>
            {actions}
          </div>

          {/* Mobile Menu Button */}
          <div className={`${mobileBreakpoint}:hidden`}>
            <IconButton
              icon={
                <svg
                  className="w-6 h-6"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  {isMobileMenuOpen ? (
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M6 18L18 6M6 6l12 12"
                    />
                  ) : (
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M4 6h16M4 12h16M4 18h16"
                    />
                  )}
                </svg>
              }
              variant="text"
              onClick={toggleMobileMenu}
            />
          </div>
        </div>

        {/* Mobile Menu */}
        <div className={`
          ${mobileBreakpoint}:hidden
          ${isMobileMenuOpen ? 'block' : 'hidden'}
          py-2
          space-y-1
        `}>
          {children}
          <div className="pt-2 mt-2 border-t border-light-comment/20 dark:border-dark-comment/20">
            {actions}
          </div>
        </div>
      </div>
    </Box>
  );
};

Navbar.propTypes = {
  brand: PropTypes.node,
  logo: PropTypes.node,
  children: PropTypes.node,
  actions: PropTypes.node,
  sticky: PropTypes.bool,
  blur: PropTypes.number,
  opacity: PropTypes.number,
  className: PropTypes.string,
  height: PropTypes.number,
  mobileBreakpoint: PropTypes.oneOf(['sm', 'md', 'lg', 'xl', '2xl']),
};

export default Navbar; 
===========================================
<components/common/NavbarItem.jsx>
===========================================
import { forwardRef } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';

const NavbarItem = forwardRef(({
  children,
  icon,
  active = false,
  disabled = false,
  className = '',
  mobileFullWidth = true,
  onClick,
  ...props
}, ref) => {
  const { isDark } = useTheme();

  const handleClick = (event) => {
    if (!disabled && onClick) {
      onClick(event);
    }
  };

  return (
    <div
      ref={ref}
      className={`
        relative
        group
        px-3
        py-2
        rounded-lg
        transition-all
        duration-200
        ${active ? (
          isDark ? 'bg-dark-background/50' : 'bg-light-background/50'
        ) : (
          'hover:bg-dark-background/30 dark:hover:bg-light-background/10'
        )}
        ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
        ${mobileFullWidth ? 'w-full md:w-auto' : ''}
        ${className}
      `.trim()}
      onClick={handleClick}
      {...props}
    >
      <div className="flex items-center gap-2">
        {icon && (
          <span className={`
            flex-shrink-0
            ${active ? 'text-blue-500' : ''}
          `}>
            {icon}
          </span>
        )}
        <span className={`
          whitespace-nowrap
          font-medium
          ${active ? 'text-blue-500' : ''}
        `}>
          {children}
        </span>
      </div>
    </div>
  );
});

NavbarItem.displayName = 'NavbarItem';

NavbarItem.propTypes = {
  children: PropTypes.node.isRequired,
  icon: PropTypes.node,
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  mobileFullWidth: PropTypes.bool,
  onClick: PropTypes.func,
};

export default NavbarItem; 
===========================================
<components/common/ProgressBar.jsx>
===========================================
import { memo } from 'react';

const ProgressBar = memo(({ progress, color = 'blue', className = '' }) => {
  // Ensure progress is between 0 and 100
  const percentage = Math.min(Math.max(progress, 0), 100);

  return (
    <div 
      className={`
        absolute 
        bottom-0 
        left-0 
        w-full 
        h-2 
        overflow-hidden
        rounded-b
        ${className}
      `}
    >
      <div
        className={`
          h-full 
          transition-all 
          duration-300 
          ease-in-out
          bg-semantic-${color}/50
        `}
        style={{
          width: `${percentage}%`,
          backgroundImage: `linear-gradient(90deg, var(--color-${color}, currentColor) 0%, var(--color-${color}, currentColor) 100%)`,
          opacity: 0.5
        }}
      />
    </div>
  );
});

ProgressBar.displayName = 'ProgressBar';

export default ProgressBar; 
===========================================
<components/common/Radio.jsx>
===========================================
import { forwardRef } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { Body2 } from './Typography';

const Radio = forwardRef(({
  label,
  error,
  helper,
  disabled = false,
  className = '',
  containerClassName = '',
  size = 'md',
  ...props
}, ref) => {
  const { isDark } = useTheme();

  const sizes = {
    sm: 'w-4 h-4',
    md: 'w-5 h-5',
    lg: 'w-6 h-6'
  };

  const dotSizes = {
    sm: 'w-2 h-2',
    md: 'w-2.5 h-2.5',
    lg: 'w-3 h-3'
  };

  const labelSizes = {
    sm: 'text-sm',
    md: 'text-base',
    lg: 'text-lg'
  };

  return (
    <div className={`${containerClassName}`.trim()}>
      <label className={`
        inline-flex
        items-center
        ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
      `.trim()}>
        <div className="relative">
          <input
            type="radio"
            ref={ref}
            disabled={disabled}
            className={`
              appearance-none
              rounded-full
              border-2
              ${isDark ? 'border-dark-comment' : 'border-light-comment'}
              ${isDark ? 'bg-dark-background' : 'bg-light-background'}
              checked:border-blue-500
              disabled:opacity-50
              disabled:cursor-not-allowed
              transition-all
              duration-200
              ${sizes[size]}
              ${className}
            `.trim()}
            {...props}
          />
          <div className={`
            absolute
            inset-0
            pointer-events-none
            flex
            items-center
            justify-center
            transition-opacity
            ${props.checked ? 'opacity-100' : 'opacity-0'}
          `}>
            <div className={`
              rounded-full
              bg-blue-500
              ${dotSizes[size]}
            `} />
          </div>
        </div>
        
        {label && (
          <span className={`
            ml-2
            ${labelSizes[size]}
            ${isDark ? 'text-dark-foreground' : 'text-light-foreground'}
          `.trim()}>
            {label}
          </span>
        )}
      </label>

      {(error || helper) && (
        <Body2
          className={`
            mt-1
            ${error ? 'text-red-500' : isDark ? 'text-dark-comment' : 'text-light-comment'}
          `.trim()}
        >
          {error || helper}
        </Body2>
      )}
    </div>
  );
});

Radio.displayName = 'Radio';

Radio.propTypes = {
  label: PropTypes.string,
  error: PropTypes.string,
  helper: PropTypes.string,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  containerClassName: PropTypes.string,
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  checked: PropTypes.bool,
};

export default Radio; 
===========================================
<components/common/Ripple.jsx>
===========================================
import { useState, useLayoutEffect } from 'react';

const Ripple = ({ duration = 500, color = "rgba(255, 255, 255, 0.3)" }) => {
  const [ripples, setRipples] = useState([]);

  useLayoutEffect(() => {
    const timeouts = [];

    ripples.forEach((ripple) => {
      const timeout = setTimeout(() => {
        setRipples((prevRipples) =>
          prevRipples.filter((prevRipple) => prevRipple.id !== ripple.id)
        );
      }, duration);

      timeouts.push(timeout);
    });

    return () => {
      timeouts.forEach((timeout) => clearTimeout(timeout));
    };
  }, [ripples, duration]);

  const addRipple = (event) => {
    const rect = event.currentTarget.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const size = Math.max(rect.width, rect.height);

    setRipples((prevRipples) => [
      ...prevRipples,
      {
        id: Date.now(),
        x,
        y,
        size,
      },
    ]);
  };

  return {
    ripples: ripples.map((ripple) => (
      <span
        key={ripple.id}
        style={{
          position: "absolute",
          left: ripple.x - ripple.size / 2,
          top: ripple.y - ripple.size / 2,
          width: ripple.size,
          height: ripple.size,
          borderRadius: "50%",
          backgroundColor: color,
          opacity: "0",
          transform: "scale(0)",
          animation: `ripple ${duration}ms linear`,
        }}
      />
    )),
    addRipple,
  };
};

export default Ripple; 
===========================================
<components/common/RowCard.jsx>
===========================================
import PropTypes from 'prop-types';
import Box from './Box';
import { Body1, Body2 } from './Typography';
import Image from './Image';

const RowCard = ({
  children,
  className = '',
  hover = true,
  blur = 2,
  opacity = 6,
  compact = false,
  ...props
}) => {
  return (
    <Box
      className={`
        flex
        items-center
        gap-4
        ${compact ? 'p-2' : 'p-4'}
        ${hover ? 'hover:scale-101 hover:shadow-lg' : ''}
        transition-all
        duration-200
        ${className}
      `.trim()}
      blur={blur}
      opacity={opacity}
      {...props}
    >
      {children}
    </Box>
  );
};

const RowCardMedia = ({
  src,
  alt,
  size = 'md',
  className = '',
  ...props
}) => {
  const sizeClasses = {
    sm: 'w-8 h-8',
    md: 'w-12 h-12',
    lg: 'w-16 h-16',
    xl: 'w-24 h-24',
  };

  return (
    <div className={`flex-shrink-0 ${sizeClasses[size]} ${className}`.trim()}>
      <Image
        src={src}
        alt={alt}
        rounded="lg"
        className="w-full h-full"
        {...props}
      />
    </div>
  );
};

const RowCardContent = ({
  title,
  subtitle,
  className = '',
  children,
  ...props
}) => {
  return (
    <div 
      className={`
        flex-grow
        min-w-0
        ${className}
      `.trim()}
      {...props}
    >
      {title && (
        <div className="truncate">
          {typeof title === 'string' ? (
            <Body1 className="font-semibold">{title}</Body1>
          ) : title}
        </div>
      )}
      {subtitle && (
        <div className="truncate">
          {typeof subtitle === 'string' ? (
            <Body2 className="text-light-comment dark:text-dark-comment">{subtitle}</Body2>
          ) : subtitle}
        </div>
      )}
      {children}
    </div>
  );
};

const RowCardAction = ({
  children,
  className = '',
  ...props
}) => {
  return (
    <div 
      className={`
        flex-shrink-0
        flex
        items-center
        gap-2
        ${className}
      `.trim()}
      {...props}
    >
      {children}
    </div>
  );
};

// PropTypes
RowCard.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  hover: PropTypes.bool,
  blur: PropTypes.number,
  opacity: PropTypes.number,
  compact: PropTypes.bool,
};

RowCardMedia.propTypes = {
  src: PropTypes.string.isRequired,
  alt: PropTypes.string.isRequired,
  size: PropTypes.oneOf(['sm', 'md', 'lg', 'xl']),
  className: PropTypes.string,
};

RowCardContent.propTypes = {
  title: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  subtitle: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  className: PropTypes.string,
  children: PropTypes.node,
};

RowCardAction.propTypes = {
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
};

// Compound components
RowCard.Media = RowCardMedia;
RowCard.Content = RowCardContent;
RowCard.Action = RowCardAction;

export default RowCard; 
===========================================
<components/common/Select.jsx>
===========================================
import { forwardRef, useState, memo } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { Body2 } from './Typography';
import { cn } from '../../utils';

const Select = memo(({
  label,
  error,
  helper,
  options = [],
  fullWidth = false,
  disabled = false,
  className = '',
  containerClassName = '',
  size = 'md',
  variant = 'outlined',
  placeholder = 'Select an option',
  value,
  onChange,
  ...props
}) => {
  const { isDark } = useTheme();
  const [isOpen, setIsOpen] = useState(false);

  const sizes = {
    sm: 'h-8 text-sm px-2',
    md: 'h-10 text-base px-3',
    lg: 'h-12 text-lg px-4'
  };

  const variants = {
    outlined: `
      border-2
      ${isDark ? 'border-dark-comment' : 'border-light-comment'}
      focus:border-blue-500
    `,
    filled: `
      ${isDark ? 'bg-slate-700' : 'bg-slate-200'}
      border-transparent
      focus:border-blue-500
    `,
    glass: `
      backdrop-blur-sm
      ${isDark ? 'bg-dark-background/30' : 'bg-light-background/30'}
      border
      ${isDark ? 'border-dark-comment/30' : 'border-light-comment/30'}
      focus:border-blue-500
    `
  };

  const baseSelectClasses = `
    w-full
    outline-none
    rounded-lg
    transition-all
    duration-200
    disabled:opacity-50
    disabled:cursor-not-allowed
    appearance-none
    bg-no-repeat
    bg-[url('data:image/svg+xml;charset=US-ASCII,<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5L10 12.5L15 7.5" stroke="%236B7280" stroke-width="1.67" stroke-linecap="round" stroke-linejoin="round"/></svg>')]
    bg-[center_right_0.5rem]
    ${isDark ? 'text-dark-foreground' : 'text-light-foreground'}
    ${variants[variant]}
    ${sizes[size]}
    ${error ? 'border-red-500 focus:border-red-500' : ''}
  `;

  const handleChange = (e) => {
    const newValue = e.target.value;
    onChange(newValue);
  };

  return (
    <div className={`
      ${fullWidth ? 'w-full' : 'max-w-sm'}
      ${containerClassName}
    `.trim()}>
      {label && (
        <label className={`
          block
          mb-1.5
          text-sm
          font-medium
          ${isDark ? 'text-dark-foreground' : 'text-light-foreground'}
          ${disabled ? 'opacity-50' : ''}
        `.trim()}>
          {label}
        </label>
      )}
      
      <select
        value={value || ''}
        onChange={handleChange}
        disabled={disabled}
        className={`
          ${baseSelectClasses}
          ${className}
        `.trim()}
        onFocus={() => setIsOpen(true)}
        onBlur={() => setIsOpen(false)}
        {...props}
      >
        {placeholder && <option value="">{placeholder}</option>}
        {options.map((option) => (
          <option 
            key={option.value} 
            value={option.value}
            className={isDark ? "bg-slate-800" : "bg-white"}
          >
            {option.label}
          </option>
        ))}
      </select>

      {(error || helper) && (
        <Body2
          className={`
            mt-1
            ${error ? 'text-red-500' : isDark ? 'text-dark-comment' : 'text-light-comment'}
          `.trim()}
        >
          {error || helper}
        </Body2>
      )}
    </div>
  );
});

Select.displayName = 'Select';

Select.propTypes = {
  label: PropTypes.string,
  error: PropTypes.string,
  helper: PropTypes.string,
  options: PropTypes.arrayOf(PropTypes.shape({
    value: PropTypes.string.isRequired,
    label: PropTypes.string.isRequired,
  })),
  fullWidth: PropTypes.bool,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  containerClassName: PropTypes.string,
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  variant: PropTypes.oneOf(['outlined', 'filled', 'glass']),
  placeholder: PropTypes.string,
  value: PropTypes.string,
  onChange: PropTypes.func,
};

export default Select; 
===========================================
<components/common/Sidebar.jsx>
===========================================
import { createContext, useContext, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import Box from './Box';
import IconButton from './IconButton';
import { useDiagram } from '../../contexts/DiagramContext';
import { ThemeToggle } from './ThemeToggle';
import { LogOut } from 'lucide-react';
import {ChevronLeft, ChevronRight} from 'lucide-react';
import { Sun, Moon } from 'lucide-react';

const Sidebar = ({
  children,
  position = 'left',
  showToggle = true,
  width = {
    expanded: 200,
    collapsed: 72,
  },
  className = '',
  ...props
}) => {
  const { sidebarOpen, setSidebarOpen } = useDiagram();
  const [isOpen, setIsOpen] = useState(sidebarOpen);
  const { isDark, toggleTheme } = useTheme();


  useEffect(() => {
    setSidebarOpen(isOpen);
  }, [isOpen]);

  const toggleSidebar = () => {
    setIsOpen(!isOpen);
  };

  return (
    <Box
      className={`
        flex
        flex-col
        h-[calc(100vh-40px)]
        sticky
        top-0
        left-0
        transition-all
        duration-200
        ease-in-out
        overflow-x-hidden
        overflow-y-auto
        bg-slate-700
        border-0
        ${className}
      `.trim()}
      style={{
        width: isOpen ? width.expanded : width.collapsed,
      }}
      opacity={10}
      blur={2}
      {...props}
    >
      <div className="flex-1 py-2 text-slate-300">
        {children}
      </div>
      <div 
        onClick={toggleSidebar}
        className={`
          absolute
          right-0
          top-1/2
          -translate-y-1/2
          flex
          justify-center
        items-center
        w-[30px]
        h-[60px]
        border-l border-t border-b border-slate-700
        cursor-pointer
        bg-slate-00
        hover:bg-slate-700
        rounded-l-md
      `}>
        {isOpen && <ChevronLeft size={20} color="white" />}
        {!isOpen && <ChevronRight size={20}  color="white" />}
      </div>

      {!isOpen && (
        <div className="flex justify-center items-center p-2 cursor-pointer">
          {isDark ? <Sun size={20} onClick={toggleTheme} color="yellow" /> : <Moon size={20} onClick={toggleTheme} color="white" />}
        </div>
      )}

      {/* Bottom Controls */}
      <div className="p-2 border-t border-slate-700 flex items-center justify-between">
        <IconButton
          icon={<LogOut size={20} />}
          variant="text"
          size="sm"
          className="text-slate-300 hover:bg-slate-800"
          onClick={() => {
            // Add logout logic here
            console.log('Logout clicked');
          }}
        />
        {isOpen && <ThemeToggle />}
      </div>
    </Box>
  );
};

Sidebar.propTypes = {
  children: PropTypes.node.isRequired,
  position: PropTypes.oneOf(['left', 'right']),
  showToggle: PropTypes.bool,
  width: PropTypes.shape({
    expanded: PropTypes.number,
    collapsed: PropTypes.number,
  }),
  className: PropTypes.string,
};

export default Sidebar; 
===========================================
<components/common/SidebarItem.jsx>
===========================================
import { forwardRef } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { useDiagram } from '../../contexts/DiagramContext';
import { Body1 } from './Typography';
import Ripple from './Ripple';
import { cn } from '../../utils';

const SidebarItem = forwardRef(({
  icon,
  text,
  active = false,
  disabled = false,
  showTextWhenCollapsed = false,
  utility = false,
  showToggle = true,
  isOpen: isOpenProp,
  notification = false,
  className = '',
  onClick,
  ...props
}, ref) => {
  const diagramContext = useDiagram();
  const { isDark } = useTheme();
  const { ripples, addRipple } = Ripple({ color: "rgba(255, 255, 255, 0.2)", duration: 1000 });

  // Use prop for utility variant, context for default
  const effectiveIsOpen = utility ? isOpenProp : diagramContext.sidebarOpen;

  const handleClick = (event) => {
    if (!disabled) {
      addRipple(event);
      onClick?.(event);
    }
  };

  return (
    <div
      ref={ref}
      className={cn(
        "relative",
        "group",
        "px-3",
        "py-2",
        "mx-2",
        "rounded-lg",
        "cursor-pointer",
        "transition-all",
        "duration-200",
        "overflow-hidden",
        disabled ? 'opacity-50 cursor-not-allowed' : '',
        className
      )}
      onClick={handleClick}
      {...props}
    >
      <div className={cn(
        "flex",
        "items-center",
        "gap-3",
        effectiveIsOpen ? '' : 'justify-center'
      )}>
        <div className="relative">
          {icon && (
            <span className={cn(
              "flex-shrink-0",
              !effectiveIsOpen ? (active ? 'text-orange-500' : 'text-aqua-800') : (active ? 'text-aqua-500' : 'text-aqua-800')
            )}>
              {icon}
            </span>
          )}
          {notification && (
            <div className={cn(
              "absolute",
              "-top-1",
              "-right-1",
              "w-2.5",
              "h-2.5",
              "rounded-full",
              "bg-red-400",
              "border-2",
              "border-slate-900",
              "animate-pulse"
            )} />
          )}
        </div>
        
        {(effectiveIsOpen || showTextWhenCollapsed) && (
          <Body1
            className={cn(
              "whitespace-nowrap",
              "transition-opacity",
              "duration-200",
              "text-slate-400",
              effectiveIsOpen ? 'opacity-100' : 'opacity-0 group-hover:opacity-100',
              active ? 'text-orange-500 font-medium' : '',
              !effectiveIsOpen && showTextWhenCollapsed ? 'absolute left-full ml-2 px-2 py-1 rounded-md backdrop-blur-md bg-black/50' : ''
            )}
          >
            {text}
          </Body1>
        )}
      </div>
      {effectiveIsOpen && ripples}
    </div>
  );
});

SidebarItem.displayName = 'SidebarItem';

SidebarItem.propTypes = {
  icon: PropTypes.node,
  text: PropTypes.string,
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  showTextWhenCollapsed: PropTypes.bool,
  utility: PropTypes.bool,
  showToggle: PropTypes.bool,
  isOpen: PropTypes.bool,
  notification: PropTypes.bool,
  className: PropTypes.string,
  onClick: PropTypes.func,
};

export default SidebarItem; 
===========================================
<components/common/Slider.jsx>
===========================================
import { forwardRef, useState, useRef, useEffect } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { Body2 } from './Typography';

const Slider = forwardRef(({
  label,
  error,
  helper,
  min = 0,
  max = 100,
  step = 1,
  defaultValue,
  value: controlledValue,
  onChange,
  disabled = false,
  showValue = true,
  className = '',
  containerClassName = '',
  color = 'blue',
  size = 'md',
  marks = false,
  ...props
}, ref) => {
  const { isDark } = useTheme();
  const [localValue, setLocalValue] = useState(defaultValue ?? min);
  const isControlled = controlledValue !== undefined;
  const value = isControlled ? controlledValue : localValue;
  const trackRef = useRef(null);

  const sizes = {
    sm: {
      track: 'h-1',
      thumb: 'w-3 h-3',
      label: 'text-sm'
    },
    md: {
      track: 'h-2',
      thumb: 'w-4 h-4',
      label: 'text-base'
    },
    lg: {
      track: 'h-3',
      thumb: 'w-5 h-5',
      label: 'text-lg'
    }
  };

  const colors = {
    blue: 'bg-blue-500',
    green: 'bg-green-500',
    red: 'bg-red-500',
    purple: 'bg-purple-500',
    orange: 'bg-orange-500',
  };

  const percentage = ((value - min) / (max - min)) * 100;

  const handleChange = (e) => {
    const newValue = Number(e.target.value);
    if (!isControlled) {
      setLocalValue(newValue);
    }
    onChange?.(newValue);
  };

  const renderMarks = () => {
    if (!marks) return null;
    
    const markValues = Array.isArray(marks) 
      ? marks 
      : Array.from({ length: (max - min) / step + 1 }, (_, i) => min + (i * step));

    return (
      <div className="absolute w-full flex justify-between px-1 mt-2">
        {markValues.map((markValue) => (
          <div
            key={markValue}
            className={`
              w-1
              h-1
              rounded-full
              ${isDark ? 'bg-dark-comment' : 'bg-light-comment'}
              ${value >= markValue ? colors[color] : ''}
            `}
          />
        ))}
      </div>
    );
  };

  return (
    <div className={`${containerClassName}`.trim()}>
      <div className="flex items-center justify-between mb-2">
        {label && (
          <label className={`
            ${sizes[size].label}
            font-medium
            ${isDark ? 'text-dark-foreground' : 'text-light-foreground'}
            ${disabled ? 'opacity-50' : ''}
          `.trim()}>
            {label}
          </label>
        )}
        {showValue && (
          <span className={`
            ${sizes[size].label}
            ${isDark ? 'text-dark-comment' : 'text-light-comment'}
          `.trim()}>
            {value}
          </span>
        )}
      </div>

      <div className="relative">
        <div
          ref={trackRef}
          className={`
            absolute
            top-1/2
            -translate-y-1/2
            left-0
            ${sizes[size].track}
            rounded-full
            backdrop-blur-sm
            ${isDark ? 'bg-dark-comment/30' : 'bg-light-comment/30'}
            w-full
          `}
        >
          <div
            className={`
              absolute
              left-0
              top-0
              h-full
              rounded-full
              ${colors[color]}
              transition-all
              duration-100
            `}
            style={{ width: `${percentage}%` }}
          />
        </div>

        <input
          ref={ref}
          type="range"
          min={min}
          max={max}
          step={step}
          value={value}
          onChange={handleChange}
          disabled={disabled}
          className={`
            appearance-none
            bg-transparent
            w-full
            ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
            relative
            ${sizes[size].track}
            [&::-webkit-slider-thumb]:appearance-none
            [&::-webkit-slider-thumb]:${sizes[size].thumb}
            [&::-webkit-slider-thumb]:rounded-full
            [&::-webkit-slider-thumb]:${colors[color]}
            [&::-webkit-slider-thumb]:shadow-lg
            [&::-webkit-slider-thumb]:transition-transform
            [&::-webkit-slider-thumb]:duration-200
            [&::-webkit-slider-thumb]:hover:scale-110
            [&::-moz-range-thumb]:${sizes[size].thumb}
            [&::-moz-range-thumb]:rounded-full
            [&::-moz-range-thumb]:${colors[color]}
            [&::-moz-range-thumb]:border-0
            [&::-moz-range-thumb]:shadow-lg
            [&::-moz-range-thumb]:transition-transform
            [&::-moz-range-thumb]:duration-200
            [&::-moz-range-thumb]:hover:scale-110
            ${className}
          `.trim()}
          {...props}
        />

        {renderMarks()}
      </div>

      {(error || helper) && (
        <Body2
          className={`
            mt-1
            ${error ? 'text-red-500' : isDark ? 'text-dark-comment' : 'text-light-comment'}
          `.trim()}
        >
          {error || helper}
        </Body2>
      )}
    </div>
  );
});

Slider.displayName = 'Slider';

Slider.propTypes = {
  label: PropTypes.string,
  error: PropTypes.string,
  helper: PropTypes.string,
  min: PropTypes.number,
  max: PropTypes.number,
  step: PropTypes.number,
  defaultValue: PropTypes.number,
  value: PropTypes.number,
  onChange: PropTypes.func,
  disabled: PropTypes.bool,
  showValue: PropTypes.bool,
  className: PropTypes.string,
  containerClassName: PropTypes.string,
  color: PropTypes.oneOf(['blue', 'green', 'red', 'purple', 'orange']),
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  marks: PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.arrayOf(PropTypes.number)
  ]),
};

export default Slider; 
===========================================
<components/common/Stack.jsx>
===========================================
import PropTypes from 'prop-types';

const SPACING = {
  0: 'space-y-0',
  1: 'space-y-1',
  2: 'space-y-2',
  3: 'space-y-3',
  4: 'space-y-4',
  5: 'space-y-5',
  6: 'space-y-6',
  8: 'space-y-8',
  10: 'space-y-10',
  12: 'space-y-12',
  16: 'space-y-16',
};

const Stack = ({
  children,
  spacing = 4,
  className = '',
  ...props
}) => {
  return (
    <div
      className={`
        flex
        flex-col
        ${SPACING[spacing]}
        ${className}
      `.trim()}
      {...props}
    >
      {children}
    </div>
  );
};

Stack.propTypes = {
  children: PropTypes.node.isRequired,
  spacing: PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 8, 10, 12, 16]),
  className: PropTypes.string,
};

export default Stack; 
===========================================
<components/common/Switch.jsx>
===========================================
import { forwardRef } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { Body2 } from './Typography';

const Switch = forwardRef(({
  label,
  error,
  helper,
  disabled = false,
  className = '',
  containerClassName = '',
  size = 'md',
  color = 'blue',
  ...props
}, ref) => {
  const { isDark } = useTheme();

  const sizes = {
    sm: {
      switch: 'w-8 h-4',
      thumb: 'w-3 h-3',
      translate: 'translate-x-4',
      label: 'text-sm'
    },
    md: {
      switch: 'w-11 h-6',
      thumb: 'w-5 h-5',
      translate: 'translate-x-5',
      label: 'text-base'
    },
    lg: {
      switch: 'w-14 h-7',
      thumb: 'w-6 h-6',
      translate: 'translate-x-7',
      label: 'text-lg'
    }
  };

  const colors = {
    blue: 'checked:bg-blue-500',
    green: 'checked:bg-green-500',
    red: 'checked:bg-red-500',
    purple: 'checked:bg-purple-500',
    orange: 'checked:bg-orange-500',
  };

  return (
    <div className={`${containerClassName}`.trim()}>
      <label className={`
        inline-flex
        items-center
        ${disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
      `.trim()}>
        <div className="relative">
          <input
            type="checkbox"
            ref={ref}
            disabled={disabled}
            className="sr-only"
            {...props}
          />
          
          <div className={`
            ${sizes[size].switch}
            backdrop-blur-sm
            ${isDark ? 'bg-dark-comment/30' : 'bg-light-comment/30'}
            rounded-full
            ${colors[color]}
            transition-colors
            duration-200
            ${className}
          `.trim()} />
          
          <div className={`
            absolute
            top-0.5
            left-0.5
            ${sizes[size].thumb}
            bg-white
            rounded-full
            shadow-lg
            transition-transform
            duration-200
            ${props.checked ? sizes[size].translate : 'translate-x-0'}
            backdrop-blur-xl
            ${isDark ? 'bg-opacity-90' : 'bg-opacity-100'}
          `} />
        </div>
        
        {label && (
          <span className={`
            ml-3
            ${sizes[size].label}
            ${isDark ? 'text-dark-foreground' : 'text-light-foreground'}
          `.trim()}>
            {label}
          </span>
        )}
      </label>

      {(error || helper) && (
        <Body2
          className={`
            mt-1
            ${error ? 'text-red-500' : isDark ? 'text-dark-comment' : 'text-light-comment'}
          `.trim()}
        >
          {error || helper}
        </Body2>
      )}
    </div>
  );
});

Switch.displayName = 'Switch';

Switch.propTypes = {
  label: PropTypes.string,
  error: PropTypes.string,
  helper: PropTypes.string,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  containerClassName: PropTypes.string,
  size: PropTypes.oneOf(['sm', 'md', 'lg']),
  color: PropTypes.oneOf(['blue', 'green', 'red', 'purple', 'orange']),
  checked: PropTypes.bool,
};

export default Switch; 
===========================================
<components/common/TextArea.jsx>
===========================================
import { forwardRef } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { Body2 } from './Typography';

const TextArea = forwardRef(({
  label,
  error,
  helper,
  fullWidth = false,
  disabled = false,
  className = '',
  containerClassName = '',
  variant = 'outlined',
  rows = 4,
  maxRows = 8,
  minRows = 2,
  autoResize = false,
  ...props
}, ref) => {
  const { isDark } = useTheme();

  const variants = {
    outlined: `
      border-2
      ${isDark ? 'border-slate-700' : 'border-slate-300'}
      focus:border-blue-500
    `,
    filled: `
      ${isDark ? 'bg-slate-800' : 'bg-slate-200'}
      border-transparent
      focus:border-blue-500
    `,
    glass: `
      backdrop-blur-sm
      ${isDark ? 'bg-slate-800' : 'bg-slate-200'}
      border
      ${isDark ? 'border-slate-700' : 'border-slate-300'}
      focus:border-blue-500
    `
  };

  const baseTextAreaClasses = `
    w-full
    outline-none
    rounded-lg
    p-3
    transition-all
    duration-200
    disabled:opacity-50
    disabled:cursor-not-allowed
    resize-${autoResize ? 'y' : 'none'}
    ${isDark ? 'text-slate-300' : 'text-slate-900'}
    ${isDark ? 'placeholder:text-slate-500' : 'placeholder:text-slate-500'}
    ${variants[variant]}
    ${error ? 'border-red-500 focus:border-red-500' : ''}
  `;

  return (
    <div className={`
      ${fullWidth ? 'w-full' : 'max-w-sm'}
      ${containerClassName}
    `.trim()}>
      {label && (
        <label className={`
          block
          mb-1.5
          text-sm
          font-medium
          ${isDark ? 'text-slate-300' : 'text-slate-900'}
          ${disabled ? 'opacity-50' : ''}
        `.trim()}>
          {label}
        </label>
      )}
      
      <textarea
        ref={ref}
        disabled={disabled}
        rows={rows}
        className={`
          ${baseTextAreaClasses}
          ${className}
        `.trim()}
        style={{
          minHeight: minRows ? `${minRows * 1.5}rem` : undefined,
          maxHeight: maxRows ? `${maxRows * 1.5}rem` : undefined,
        }}
        {...props}
      />

      {(error || helper) && (
        <Body2
          className={`
            mt-1
            ${error ? 'text-red-500' : 'text-slate-500'}
          `.trim()}
        >
          {error || helper}
        </Body2>
      )}
    </div>
  );
});

TextArea.displayName = 'TextArea';

TextArea.propTypes = {
  label: PropTypes.string,
  error: PropTypes.string,
  helper: PropTypes.string,
  fullWidth: PropTypes.bool,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  containerClassName: PropTypes.string,
  variant: PropTypes.oneOf(['outlined', 'filled', 'glass']),
  rows: PropTypes.number,
  maxRows: PropTypes.number,
  minRows: PropTypes.number,
  autoResize: PropTypes.bool,
};

export default TextArea; 
===========================================
<components/common/ThemeToggle.jsx>
===========================================
import { useTheme } from '../../contexts/ThemeContext';
import { Sun, Moon } from 'lucide-react';
import { cn } from '../../utils';

export function ThemeToggle({ className }) {
  const { isDark, toggleTheme } = useTheme();

  return (
    <button
      onClick={toggleTheme}
      className={cn(
        "relative h-8 w-16",
        "rounded-full",
        "bg-slate-100/90",
        "p-1",
        "transition-colors duration-200",
        "border border-slate-200/10",
        className
      )}
    >
      {/* Background Icons */}
      <div className="absolute inset-0 flex justify-between items-center px-2">
        <Sun size={14} className={cn(
          "transition-colors duration-200",
          isDark ? "text-slate-900" : "text-amber-300"
        )} />
        <Moon size={14} className={cn(
          "transition-colors duration-200",
          isDark ? "text-slate-100" : "text-slate-900"
        )} />
      </div>

      {/* Sliding Selector */}
      <div
        className={cn(
          "absolute top-1 h-6 w-6",
          "flex items-center justify-center",
          "rounded-full",
          "bg-slate-800",
          "shadow-sm",
          "transition-all duration-200 ease-out",
          isDark ? "translate-x-8" : "translate-x-0"
        )}
      >
        {/* Active Icon */}
        {isDark ? (
          <Moon size={14} className="text-slate-200" />
        ) : (
          <Sun size={14} className="text-amber-300" />
        )}
      </div>
    </button>
  );
} 
===========================================
<components/common/ToggleButton.jsx>
===========================================
import { forwardRef } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { cn } from '../../utils';

const ToggleButton = forwardRef(({
  selected = false,
  disabled = false,
  color = 'blue',
  size = 'md',
  className = '',
  ...props
}, ref) => {
  const { isDark } = useTheme();

  const sizes = {
    xs: 'w-8 h-4',
    sm: 'w-10 h-5',
    md: 'w-12 h-6',
    lg: 'w-14 h-7',
    xl: 'w-16 h-8',
  };

  const thumbSizes = {
    xs: 'w-3 h-3',
    sm: 'w-4 h-4',
    md: 'w-5 h-5',
    lg: 'w-6 h-6',
    xl: 'w-7 h-7',
  };

  const colors = {
    blue: {
      selected: 'bg-blue-500',
      thumb: 'bg-white',
      track: isDark ? 'bg-slate-700' : 'bg-slate-200',
    },
    green: {
      selected: 'bg-green-500',
      thumb: 'bg-white',
      track: isDark ? 'bg-slate-700' : 'bg-slate-200',
    },
    red: {
      selected: 'bg-red-500',
      thumb: 'bg-white',
      track: isDark ? 'bg-slate-700' : 'bg-slate-200',
    },
    purple: {
      selected: 'bg-purple-500',
      thumb: 'bg-white',
      track: isDark ? 'bg-slate-700' : 'bg-slate-200',
    },
    orange: {
      selected: 'bg-orange-500',
      thumb: 'bg-white',
      track: isDark ? 'bg-slate-700' : 'bg-slate-200',
    },
  };

  return (
    <button
      ref={ref}
      type="button"
      role="switch"
      aria-checked={selected}
      disabled={disabled}
      className={cn(
        'relative inline-flex flex-shrink-0 cursor-pointer rounded-full transition-colors duration-200 ease-in-out',
        disabled && 'opacity-50 cursor-not-allowed',
        selected ? colors[color].selected : colors[color].track,
        sizes[size],
        className
      )}
      {...props}
    >
      <span
        className={cn(
          'pointer-events-none inline-block transform rounded-full transition duration-200 ease-in-out',
          colors[color].thumb,
          thumbSizes[size],
          selected ? 'translate-x-full' : 'translate-x-0',
          'shadow-lg',
          'absolute top-[2px] left-[2px]'
        )}
      />
    </button>
  );
});

ToggleButton.displayName = 'ToggleButton';

ToggleButton.propTypes = {
  selected: PropTypes.bool,
  disabled: PropTypes.bool,
  color: PropTypes.oneOf(['blue', 'green', 'red', 'purple', 'orange']),
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  className: PropTypes.string,
};

export default ToggleButton; 
===========================================
<components/common/ToggleButtonGroup.jsx>
===========================================
import { Children, cloneElement } from 'react';
import PropTypes from 'prop-types';

const ToggleButtonGroup = ({
  children,
  value,
  onChange,
  exclusive = false,
  color,
  size,
  vertical = false,
  fullWidth = false,
  className = '',
  ...props
}) => {
  const handleChange = (event, buttonValue) => {
    if (!onChange) return;

    let newValue;
    if (exclusive) {
      newValue = buttonValue === value ? '' : buttonValue;
    } else {
      newValue = Array.isArray(value) ? [...value] : [];
      const index = newValue.indexOf(buttonValue);
      if (index === -1) {
        newValue.push(buttonValue);
      } else {
        newValue.splice(index, 1);
      }
    }

    onChange(event, newValue);
  };

  const childrenArray = Children.toArray(children);

  const isSelected = (buttonValue) => {
    if (exclusive) {
      return buttonValue === value;
    }
    return Array.isArray(value) && value.includes(buttonValue);
  };

  const getChildClasses = (index) => {
    if (vertical) {
      if (index === 0) return 'rounded-t-lg rounded-b-none';
      if (index === childrenArray.length - 1) return 'rounded-b-lg rounded-t-none';
      return 'rounded-none';
    }
    
    if (index === 0) return 'rounded-r-none';
    if (index === childrenArray.length - 1) return 'rounded-l-none';
    return 'rounded-none';
  };

  return (
    <div
      className={`
        inline-flex
        ${vertical ? 'flex-col' : 'flex-row'}
        ${fullWidth ? 'w-full' : ''}
        ${className}
      `.trim()}
      role="group"
      {...props}
    >
      {Children.map(children, (child, index) => {
        if (!child) return null;

        return cloneElement(child, {
          color: color || child.props.color,
          size: size || child.props.size,
          selected: isSelected(child.props.value),
          onChange: (event) => handleChange(event, child.props.value),
          className: `
            ${child.props.className || ''}
            ${getChildClasses(index)}
            ${vertical ? '' : index !== 0 ? '-ml-px' : ''}
          `.trim(),
        });
      })}
    </div>
  );
};

ToggleButtonGroup.propTypes = {
  children: PropTypes.node.isRequired,
  value: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.arrayOf(PropTypes.string),
  ]),
  onChange: PropTypes.func,
  exclusive: PropTypes.bool,
  color: PropTypes.oneOf(['blue', 'green', 'red', 'purple', 'orange']),
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
  vertical: PropTypes.bool,
  fullWidth: PropTypes.bool,
  className: PropTypes.string,
};

export default ToggleButtonGroup; 
===========================================
<components/common/Tooltip.jsx>
===========================================
import { useState, useRef, useEffect } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';

const Tooltip = ({
  children,
  content,
  side = 'top',
  align = 'center',
  delay = 0,
  className = '',
}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const timeoutRef = useRef(null);
  const tooltipRef = useRef(null);
  const { isDark } = useTheme();

  const calculatePosition = (targetRect) => {
    if (!tooltipRef.current) return { x: 0, y: 0 };

    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    let x = 0;
    let y = 0;

    switch (side) {
      case 'top':
        y = targetRect.top - tooltipRect.height - 8;
        break;
      case 'bottom':
        y = targetRect.bottom + 8;
        break;
      case 'left':
        x = targetRect.left - tooltipRect.width - 8;
        break;
      case 'right':
        x = targetRect.right + 8;
        break;
    }

    switch (align) {
      case 'start':
        if (side === 'top' || side === 'bottom') {
          x = targetRect.left;
        } else {
          y = targetRect.top;
        }
        break;
      case 'center':
        if (side === 'top' || side === 'bottom') {
          x = targetRect.left + (targetRect.width - tooltipRect.width) / 2;
        } else {
          y = targetRect.top + (targetRect.height - tooltipRect.height) / 2;
        }
        break;
      case 'end':
        if (side === 'top' || side === 'bottom') {
          x = targetRect.right - tooltipRect.width;
        } else {
          y = targetRect.bottom - tooltipRect.height;
        }
        break;
    }

    // Keep tooltip within viewport
    x = Math.max(8, Math.min(x, window.innerWidth - tooltipRect.width - 8));
    y = Math.max(8, Math.min(y, window.innerHeight - tooltipRect.height - 8));

    return { x, y };
  };

  const handleMouseEnter = (e) => {
    if (delay) {
      timeoutRef.current = setTimeout(() => {
        const rect = e.currentTarget.getBoundingClientRect();
        setPosition(calculatePosition(rect));
        setIsVisible(true);
      }, delay);
    } else {
      const rect = e.currentTarget.getBoundingClientRect();
      setPosition(calculatePosition(rect));
      setIsVisible(true);
    }
  };

  const handleMouseLeave = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    setIsVisible(false);
  };

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return (
    <div
      className="relative inline-block"
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      {children}
      
      {isVisible && (
        <div
          ref={tooltipRef}
          className={`
            fixed
            z-50
            px-2
            py-1
            text-sm
            rounded-md
            shadow-lg
            whitespace-nowrap
            transition-opacity
            duration-200
            ${isDark ? 'bg-dark-paper text-dark-text' : 'bg-light-paper text-light-text'}
            ${className}
          `.trim()}
          style={{
            left: position.x,
            top: position.y,
          }}
        >
          {content}
        </div>
      )}
    </div>
  );
};

Tooltip.propTypes = {
  children: PropTypes.node.isRequired,
  content: PropTypes.node.isRequired,
  side: PropTypes.oneOf(['top', 'right', 'bottom', 'left']),
  align: PropTypes.oneOf(['start', 'center', 'end']),
  delay: PropTypes.number,
  className: PropTypes.string,
};

export default Tooltip; 
===========================================
<components/common/TreeView.jsx>
===========================================
import { useState } from 'react';
import { ChevronRight, ChevronDown } from 'lucide-react';

const TreeView = ({ data, path = '', onSelect }) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const getType = (value) => {
    if (Array.isArray(value)) return 'array';
    if (value === null) return 'null';
    return typeof value;
  };

  const getPreview = (value) => {
    const type = getType(value);
    switch (type) {
      case 'string':
        return `"${value.length > 50 ? value.slice(0, 47) + '...' : value}"`;
      case 'array':
        return `Array(${value.length})`;
      case 'object':
        return value === null ? 'null' : 'Object';
      default:
        return String(value);
    }
  };

  const handleClick = (e) => {
    e.stopPropagation();
    if (typeof data === 'object' && data !== null) {
      setIsExpanded(!isExpanded);
    }
    if (path && onSelect) {
      onSelect(path);
    }
  };

  const renderValue = () => {
    const type = getType(data);

    if (type === 'object' && data !== null) {
      return (
        <>
          <div 
            onClick={handleClick}
            className="flex items-center cursor-pointer hover:bg-slate-100 dark:hover:bg-slate-700 p-1 rounded"
          >
            {isExpanded ? (
              <ChevronDown className="w-4 h-4 mr-1" />
            ) : (
              <ChevronRight className="w-4 h-4 mr-1" />
            )}
            <span className="text-semantic-purple font-medium">
              {path.split('.').pop() || 'root'}
            </span>
            <span className="ml-2 text-slate-500">
              {type === 'array' ? `Array(${Object.keys(data).length})` : `Object`}
            </span>
          </div>
          
          {isExpanded && (
            <div className="ml-4 border-l dark:border-slate-700 pl-2">
              {Object.entries(data).map(([key, value]) => (
                <TreeView
                  key={key}
                  data={value}
                  path={path ? `${path}.${key}` : key}
                  onSelect={onSelect}
                />
              ))}
            </div>
          )}
        </>
      );
    }

    return (
      <div 
        onClick={handleClick}
        className="flex items-center cursor-pointer hover:bg-slate-100 dark:hover:bg-slate-700 p-1 rounded"
      >
        <span className="text-semantic-purple font-medium">
          {path.split('.').pop()}:
        </span>
        <span className="ml-2 text-semantic-green">{getPreview(data)}</span>
      </div>
    );
  };

  return <div className="font-mono text-sm">{renderValue()}</div>;
};

export default TreeView; 
===========================================
<components/common/Typography.jsx>
===========================================
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import { cn } from '../../utils';

const variants = {
  h1: 'text-4xl font-bold',
  h2: 'text-3xl font-bold',
  h3: 'text-2xl font-bold',
  h4: 'text-xl font-semibold',
  h5: 'text-lg font-semibold',
  h6: 'text-base font-semibold',
  body1: 'text-base',
  body2: 'text-sm',
  caption: 'text-xs',
  overline: 'text-xs uppercase tracking-wider',
};

const Text = ({
  variant = 'body1',
  color,
  component,
  children = null,
  className = '',
  ...props
}) => {
  const { isDark } = useTheme();
  const Component = component || defaultElements[variant] || 'span';
  
  return (
    <Component
      className={cn(
        variants[variant],
        !color && (isDark ? 'text-dark-foreground' : 'text-light-foreground'),
        color && `text-semantic-${color}`,
        'transition-colors',
        className
      )}
      {...props}
    >
      {children || ''}
    </Component>
  );
};

// Convenience components
export const H1 = (props) => <Text variant="h1" component="h1" {...props} />;
export const H2 = (props) => <Text variant="h2" component="h2" {...props} />;
export const H3 = (props) => <Text variant="h3" component="h3" {...props} />;
export const H4 = (props) => <Text variant="h4" component="h4" {...props} />;
export const H5 = (props) => <Text variant="h5" component="h5" {...props} />;
export const H6 = (props) => <Text variant="h6" component="h6" {...props} />;
export const Body1 = (props) => <Text variant="body1" component="p" {...props} />;
export const Body2 = (props) => <Text variant="body2" component="p" {...props} />;
export const Caption = (props) => <Text variant="caption" component="span" {...props} />;
export const Overline = (props) => <Text variant="overline" component="span" {...props} />;

const defaultElements = {
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  body1: 'p',
  body2: 'p',
  caption: 'span',
  overline: 'span',
};

Text.propTypes = {
  variant: PropTypes.oneOf([
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'body1', 'body2', 'caption', 'overline'
  ]),
  component: PropTypes.elementType,
  className: PropTypes.string,
};

export default Text; 
===========================================
<components/diagram/ClickableBaseEdge.jsx>
===========================================
import React from "react";

const ClickableBaseEdge = ({
  id,
  path,
  style,
  markerEnd,
  markerStart,
  interactionWidth = 20,
  onClick,
}) => {
  return (
    <>
      <path
        id={id}
        style={style}
        d={path}
        fill="none"
        className="react-flow__edge-path"
        markerEnd={markerEnd}
        markerStart={markerStart}
      />
      {interactionWidth && (
        <path
          d={path}
          fill="none"
          strokeOpacity={0}
          strokeWidth={interactionWidth}
          className="react-flow__edge-interaction"
          onClick={onClick}
        />
      )}
    </>
  );
};

ClickableBaseEdge.displayName = "BaseEdge";

export default ClickableBaseEdge;

===========================================
<components/diagram/ContextMenu.jsx>
===========================================
import { memo, useCallback } from 'react';
import { useTheme } from '../../contexts/ThemeContext';

const ContextMenu = memo(({ x, y, onDelete, onClose, type }) => {
  const { isDark } = useTheme();

  const handleDelete = useCallback(() => {
    onDelete();
    onClose();
  }, [onDelete, onClose]);

  const getDeleteText = () => {
    console.log('Context menu type:', type);  // Debug log
    return type === 'edge' ? 'Delete Connection' : 'Delete Node';
  };

  return (
    <div
      className={`absolute z-50 min-w-[160px] py-1 rounded-lg shadow-lg ${
        isDark ? 'bg-gray-800 border border-gray-700' : 'bg-white border border-gray-200'
      }`}
      style={{
        left: x,
        top: y,
      }}
    >
      <button
        className={`w-full px-4 py-2 text-left text-sm ${
          isDark 
            ? 'text-red-400 hover:bg-gray-700' 
            : 'text-red-600 hover:bg-gray-50'
        }`}
        onClick={handleDelete}
      >
        {getDeleteText()}
      </button>
    </div>
  );
});

ContextMenu.displayName = 'ContextMenu';

export default ContextMenu; 
===========================================
<components/diagram/DiagramEdge.jsx>
===========================================
import { memo } from 'react';
import { getBezierPath, getStraightPath, getSmoothStepPath, getSimpleBezierPath } from 'reactflow';
import PropTypes from 'prop-types';
import { cn } from '../../utils';
import { useTheme } from '../../contexts/ThemeContext';
import { useDiagram } from '../../contexts/DiagramContext';

const DiagramEdge = memo(({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  markerEnd
}) => {
  const { isExecuting, edgeType } = useDiagram();
  const { isDark } = useTheme();

  // Get the path based on the edge type
  const getEdgePath = () => {
    const params = {
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
    };

    switch (edgeType) {
      case 'straight':
        return getStraightPath(params);
      case 'step':
        return getSmoothStepPath({
          ...params,
          borderRadius: 0
        });
      case 'smoothstep':
        return getSmoothStepPath({
          ...params,
          borderRadius: 10
        });
      case 'simplebezier':
        return getSimpleBezierPath(params);
      case 'default':
      default:
        return getBezierPath(params);
    }
  };

  const [edgePath] = getEdgePath();

  return (
    <path
      id={id}
      d={edgePath}
      markerEnd={markerEnd}
      style={{
        ...style,
        strokeWidth: 4,
        strokeDasharray: isExecuting ? '4 8' : '0 0',
        opacity: 0.75,
      }}
      interactionWidth={12}
      reconnectable={true}
      className={cn(
        "react-flow__edge-path",
        isExecuting ? "animate-dash" : "",
        isExecuting ? "stroke-semantic-yellow" : "stroke-cyan-500"
      )}
      fill="none"
    />
  );
});

DiagramEdge.displayName = 'DiagramEdge';

DiagramEdge.propTypes = {
  id: PropTypes.string.isRequired,
  sourceX: PropTypes.number.isRequired,
  sourceY: PropTypes.number.isRequired,
  targetX: PropTypes.number.isRequired,
  targetY: PropTypes.number.isRequired,
  sourcePosition: PropTypes.string.isRequired,
  targetPosition: PropTypes.string.isRequired,
  style: PropTypes.object,
  markerEnd: PropTypes.string,
  interactionWidth: PropTypes.number,
  type: PropTypes.oneOf(['default', 'straight', 'step', 'smoothstep', 'simplebezier'])
};

export default DiagramEdge; 
===========================================
<components/diagram/DiagramPalette.jsx>
===========================================
import { memo, useState, useMemo } from 'react';
import { Controls } from 'reactflow';
import { 
  Play, 
  Loader2,
  ChevronDown,
  ChevronRight,
  ChevronLeft,
  Trash,
} from 'lucide-react';
import { cn } from '../../utils';
import { useDiagram } from '../../contexts/DiagramContext';
import { useTheme } from '../../contexts/ThemeContext';
import Button from '../common/Button';
import Select from '../common/Select';
import Toggle from '../common/ToggleButton';
import Input from '../common/Input';
import { NODE_TYPES, NODE_CATEGORIES } from '../../constants/nodeTypes';

const DiagramPalette = memo(({ items = [] }) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [isOptionsExpanded, setIsOptionsExpanded] = useState(false);
  const [expanded, setExpanded] = useState(true);

  const { 
    nodes,
    isExecuting, 
    startExecution, 
    generateNodeId,
    edgeType,
    setEdgeType,
    background,
    setBackground,
    clearWorkflow,
    autoOpenDrawer,
    setAutoOpenDrawer,
    autoCloseDrawer,
    setAutoCloseDrawer,
    stepDelay,
    setStepDelay,
  } = useDiagram();
  const { isDark } = useTheme();

  const groupedItems = useMemo(() => {
    if (!searchQuery) {
      // Group by category when no search
      return Object.entries(NODE_CATEGORIES).map(([categoryId, category]) => ({
        category: category.label,
        color: category.color,
        items: items.filter(item => {
          const nodeType = NODE_TYPES[item.type];
          return nodeType && nodeType.category === categoryId;
        })
      }));
    }

    // When searching, show flat list of filtered items
    const query = searchQuery.toLowerCase();
    const filteredItems = items.filter(item => 
      item.label.toLowerCase().includes(query) || 
      item.description.toLowerCase().includes(query)
    );
    
    return [{
      category: 'Search Results',
      items: filteredItems
    }];
  }, [items, searchQuery]);

  const handleDragStart = (event, item) => {
    // Generate a unique ID for the new node
    const nodeId = generateNodeId(item.type);
    
    const nodeData = {
      id: nodeId,
      type: item.type,
      data: {
        label: item.label,
        description: item.description,
        color: NODE_TYPES[item.type]?.color,

        ...(item.type === 'http' && {
          method: 'GET',
          url: '',
          headers: [],
          params: []
        }),
        ...(item.type === 'format' && {
          template: ''
        }),
        ...(item.type === 'fileop' && {
          operation: 'read',
          fileName: ''
        }),
        ...(item.type === 'parser' && {
          parser: 'json',
          mode: 'json',
          template: 'data',
        }),
        ...(item.type === 'iterator' && {
          outputList: []
        })
      }
    };

    event.dataTransfer.setData('application/diagram-node', JSON.stringify(nodeData));
    event.dataTransfer.effectAllowed = 'move';
  };

  const handleClearWorkflow = () => {
    if (window.confirm('Are you sure you want to clear the workflow? This cannot be undone.')) {
      clearWorkflow();
    }
  };

  // Check if we have any nodes to execute
  const canExecute = nodes.length > 0;

  return (
    <div className={cn(
      expanded ? "w-[280px]" : "w-[50px]",
      "h-[calc(100vh-40px)]",
      "flex flex-col",
      "bg-[var(--background)]",
      "border border-slate-600",
      "shadow-lg overflow-hidden transition-all duration-300 ease-in-out border-t-0 border-b-0",
      isDark ? "bg-slate-800" : "bg-slate-300"
    )}>
      {/* Execute Button */}
      <div className="h-[50px] p-3 border-b border-[var(--border)] flex items-center bg-aqua-500 dark:bg-slate-800 dark:hover:bg-slate-700">
        <Button
          size="sm"
          variant="text"
          color={isDark ? "aqua" : "white"}
          fullWidth
          startIcon={isExecuting ? <Loader2 className="animate-spin" /> : <Play />}
          onClick={startExecution}
          disabled={!canExecute || isExecuting}
        >
         {expanded ? "Execute" : ""}
        </Button>
      </div>

      {/* Node Types Header */}
      <div className="h-[50px] p-3 border-b border-[var(--border)] flex items-center w-full relative">
        {expanded && <h3 className="font-medium text-organge-500">Node Types</h3>}
        <div 
          className="absolute right-0 top-0 h-full border-l border-slate-800 w-[50px] bg-slate-400 flex items-center justify-center"
          onClick={() => setExpanded(!expanded)}
        >
          <ChevronLeft 
            size={20} 
            className={cn(
              "text-slate-700 transition-all duration-300 ease-in-out",
              !expanded && "rotate-180"
            )}
          />
        </div>
      </div>

      {/* Search Bar */}
      <div className="h-[50px] p-3 border-b flex items-center">
        {expanded && (
          <Input
            placeholder="Search nodes..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            variant="filled"
            fullWidth
          />
        )}
      </div>

      {/* Nodes Section */}
      <div className="flex-1 overflow-y-auto" style={{ height: 'calc(60% - 150px)' }}>
        {expanded && (
          <div className="space-y-4 p-2">
          {groupedItems.map(group => (
            <div key={group.category} className="space-y-2">
              {/* Category Header */}
              <div className={cn(
                "text-xs font-bold dark:font-light font-mono px-2",
                isDark ? `text-semantic-${group.color || 'slate'}` : `text-slate-900`
              )}>
                {group.category}
              </div>

              {/* Category Items */}
              {group.items.length === 0 ? (
                <div className="text-center text-sm text-slate-500 py-2">
                  No nodes available
                </div>
              ) : (
                group.items.map((item) => {
                  const Icon = item.icon;
                  const nodeType = NODE_TYPES[item.type];
                  const color = nodeType?.category ? NODE_CATEGORIES[nodeType.category].color : 'slate';
                  
                  return (
                    <div
                      key={item.type}
                      draggable
                      onDragStart={(e) => handleDragStart(e, item)}
                      className={cn(
                        "flex items-center gap-3 p-3",
                        isDark ? "bg-slate-700" : "bg-slate-100",
                        "border-8 border-double border-slate-300 dark:border-slate-800",
                        "rounded-md cursor-move",
                        "transition-all duration-200 ease-in-out",
                        `hover:scale-102`
                      )}
                    >
                      {Icon && (
                        <div className={cn(
                          "w-8 h-8",
                          "flex items-center justify-center",
                          "rounded",
                          `text-semantic-${color}`
                        )}>
                          <Icon size={20} />
                        </div>
                      )}
                      <div>
                        <div className="font-medium text-sm">{item.label}</div>
                        <div className="text-xs text-[var(--foreground)]/60">
                          {item.description}
                        </div>
                      </div>
                    </div>
                  );
                })
              )}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Options Section */}
      <div className={cn(
        "transition-all duration-300 ease-in-out",
        "border-t border-[var(--border)]"
      )}>
        {expanded && (
        <div 
          className={cn(
            "h-[50px] p-3 flex items-center",
            "justify-between cursor-pointer",
            "hover:bg-slate-700/50",
            "border-b border-[var(--border)]"
          )}
          onClick={() => setIsOptionsExpanded(!isOptionsExpanded)}
        >
          <h3 className="font-medium">Options</h3>
          <ChevronDown
            className={cn(
              "transition-transform duration-300",
              !isOptionsExpanded && "rotate-180"
            )}
            size={20}
          />
        </div>
        )}

        {/* Options Content */}
        <div className={cn(
          "overflow-hidden transition-all duration-300",
          isOptionsExpanded ? "h-[220px]" : "h-0"
        )}>
          <div className="p-3 space-y-4 overflow-y-auto h-full">
            <div>
              <label className="text-sm mb-1 block">Line Style</label>
              <Select
                value={edgeType || 'smoothstep'}
                onChange={(value) => setEdgeType(value)}
                options={[
                  { value: 'default', label: 'Bezier' },
                  { value: 'straight', label: 'Straight' },
                  { value: 'step', label: 'Step' },
                  { value: 'smoothstep', label: 'Smooth Step' },
                  { value: 'simplebezier', label: 'Simple Bezier' },
                ]}
                variant="filled"
                fullWidth
              />
            </div>
            <div>
              <label className="text-sm mb-1 block">Background</label>
              <Select
                value={background}
                onChange={(value) => setBackground(value)}
                options={[
                  { value: 'lines', label: 'Lines' },
                  { value: 'dots', label: 'Dots' },
                  { value: 'none', label: 'None' },
                ]}
                variant="filled"
                fullWidth
              />
            </div>
            <div>
              <label className="text-sm mb-1 block">Step Delay (ms)</label>
              <Input
                type="number"
                min={0}
                max={5000}
                value={stepDelay}
                onChange={(e) => setStepDelay(Math.max(0, parseInt(e.target.value) || 0))}
                variant="filled"
                fullWidth
              />
            </div>
            <div>
              <label className="text-sm mb-1 block">Auto Open Drawer on Node Select</label>
              <Toggle
                selected={autoOpenDrawer}
                onClick={() => setAutoOpenDrawer(!autoOpenDrawer)}
              />
              <label className="text-sm mb-1 block">Auto Close Drawer</label>
              <Toggle
                selected={autoCloseDrawer}
                onClick={() =>  setAutoCloseDrawer(!autoCloseDrawer)}
              />
            </div>
          </div>
        </div>
      </div>

      {/* Controls */}
      <div className="h-[50px] p-3 border-t border-[var(--border)] flex items-center justify-center w-full bg-slate-200 opacity-80">
        {expanded && <div className="flex items-center gap-2 h-[40px] w-full">
          <Controls 
            className="!flex !flex-row !bg-transparent !shadow-none"
          style={{ 
            display: 'flex',
            gap: '8px',
            padding: 0,
            transform: 'none',
            color: 'white'
          }}
          />
        </div>}
      </div>

      {/* Clear Workflow Button */}
      <div className="h-[50px] p-3 border-t border-[var(--border)] flex items-center justify-center bg-red-700 dark:bg-slate-800 dark:hover:bg-slate-700">
        <Button 
          size="sm"
          variant="text"
          color="red"
          onClick={handleClearWorkflow}
          startIcon={<Trash size={20} />}
          fullWidth
        >
          {expanded ? "Clear Workflow" : ""}
        </Button>
      </div>
    </div>
  );
});

DiagramPalette.displayName = 'DiagramPalette';

export default DiagramPalette;
===========================================
<components/diagram/PositionableEdge.jsx>
===========================================
import { memo, useMemo, useCallback, useRef, useState } from 'react';
import {
  EdgeLabelRenderer,
  getBezierPath,
  getSmoothStepPath,
  getStraightPath,
  useReactFlow,
} from 'reactflow';
import PropTypes from 'prop-types';
import { cn } from '../../utils';
import { useTheme } from '../../contexts/ThemeContext';
import { useDiagram } from '../../contexts/DiagramContext';
import ClickableBaseEdge from './ClickableBaseEdge';

const PositionableEdge = memo(({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  markerEnd,
  selected,
  data,
}) => {
  const reactFlowInstance = useReactFlow();
  const { isExecuting, edgeType} = useDiagram();
  const { isDark } = useTheme();
  const positionHandlers = data?.positionHandlers ?? [];
  const dragHandleRef = useRef(null);
  const [isHovered, setIsHovered] = useState(false);
  const params = {
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
  };

  // Memoize path function selection based on edgeType from context
  const pathFunction = useMemo(() => {
    switch (edgeType) {
      case 'straight':
        return getStraightPath;
      case 'smoothstep':
        return getSmoothStepPath;
      case 'step':
        return getSmoothStepPath;
      default:
        return getBezierPath;
    }
  }, [edgeType]);

  // Helper to determine if a segment is more vertical than horizontal
  const isVerticalSegment = useCallback((start, end) => {
    const dx = Math.abs(end.x - start.x);
    const dy = Math.abs(end.y - start.y);
    const THRESHOLD = 10; // Increased from 10 for better detection
    const RATIO_THRESHOLD = 1.2; // More forgiving ratio (was implicitly 2)
  
    // If the segment is very short, we should maintain previous orientation
    // or use the general direction of the full path
    if (dx + dy < THRESHOLD) {
      // Could look at overall source->target orientation
      const globalDx = Math.abs(targetX - sourceX);
      const globalDy = Math.abs(targetY - sourceY);
      return globalDy > globalDx;
    }
  
    // If one dimension is clearly dominant, use that
    if (dy > dx * RATIO_THRESHOLD) return true;  // clearly vertical
    if (dx > dy * RATIO_THRESHOLD) return false; // clearly horizontal
  
    // For segments that are close to 45 degrees:
    // If it's more vertical than the previous segment, keep it vertical
    // If it's the first segment, use the global direction
    const globalDx = Math.abs(targetX - sourceX);
    const globalDy = Math.abs(targetY - sourceY);
    return dy >= dx || globalDy > globalDx;
  }, [sourceX, sourceY, targetX, targetY]);

  // Calculate segment points for orientation detection
  const segmentPoints = useMemo(() => {
    const points = [];
    const allPoints = [
      { x: sourceX, y: sourceY },
      ...positionHandlers,
      { x: targetX, y: targetY }
    ];

    for (let i = 0; i < allPoints.length - 1; i++) {
      points.push({
        start: allPoints[i],
        end: allPoints[i + 1],
        isVertical: isVerticalSegment(allPoints[i], allPoints[i + 1])
      });
    }

    return points;
  }, [sourceX, sourceY, targetX, targetY, positionHandlers, isVerticalSegment]);

  const handleEdgeClick = useCallback((event, segmentIndex) => {
    const position = reactFlowInstance.screenToFlowPosition({
      x: event.clientX,
      y: event.clientY,
    });

    reactFlowInstance.setEdges((edges) => {
      const edgeIndex = edges.findIndex((edge) => edge.id === id);
      if (edgeIndex === -1) return edges;

      const newEdges = [...edges];
      const newHandlers = [...(newEdges[edgeIndex].data?.positionHandlers || [])];
      
      // Get the segment's orientation and points
      const segment = segmentPoints[segmentIndex];
      const isVertical = segment.isVertical;
      const start = segment.start;
      const end = segment.end;

      // Determine flow direction
      const flowingDown = end.y > start.y;
      const flowingRight = end.x > start.x;

      // Set source/target positions based on flow direction
      const sourcePosition = isVertical 
        ? (flowingDown ? 'bottom' : 'top')    // Inverted for vertical
        : (flowingRight ? 'right' : 'left');
      
      const targetPosition = isVertical
        ? (flowingDown ? 'top' : 'bottom')    // Inverted for vertical
        : (flowingRight ? 'left' : 'right');

      // Add the new handler with the appropriate position and orientation
      newHandlers.splice(segmentIndex, 0, {
        x: position.x,
        y: position.y,
        sourcePosition,
        targetPosition
      });

      newEdges[edgeIndex] = {
        ...newEdges[edgeIndex],
        data: {
          ...newEdges[edgeIndex].data,
          positionHandlers: newHandlers
        }
      };

      return newEdges;
    });
  }, [id, reactFlowInstance, segmentPoints]);

  // Memoize edge segments calculation with orientation
  const edgeSegmentsArray = useMemo(() => {
    const segments = [];
    const edgeSegmentsCount = positionHandlers.length + 1;

    for (let i = 0; i < edgeSegmentsCount; i++) {
      let segmentSourceX, segmentSourceY, segmentTargetX, segmentTargetY;
      let segmentSourcePos, segmentTargetPos;

      if (i === 0) {
        segmentSourceX = sourceX;
        segmentSourceY = sourceY;
        segmentSourcePos = sourcePosition;
      } else {
        const handler = positionHandlers[i - 1];
        segmentSourceX = handler.x;
        segmentSourceY = handler.y;
        segmentSourcePos = handler.sourcePosition || 'right';
      }

      if (i === edgeSegmentsCount - 1) {
        segmentTargetX = targetX;
        segmentTargetY = targetY;
        segmentTargetPos = targetPosition;
      } else {
        const handler = positionHandlers[i];
        segmentTargetX = handler.x;
        segmentTargetY = handler.y;
        segmentTargetPos = handler.targetPosition || 'left';
      }

      const [edgePath, labelX, labelY] = pathFunction({
        sourceX: segmentSourceX,
        sourceY: segmentSourceY,
        sourcePosition: segmentSourcePos,
        targetX: segmentTargetX,
        targetY: segmentTargetY,
        targetPosition: segmentTargetPos,
        borderRadius: edgeType === 'step' ? 0 : undefined
      });
      segments.push({ 
        edgePath, 
        labelX, 
        labelY,
        sourcePos: segmentSourcePos,
        targetPos: segmentTargetPos
      });
    }

    return segments;
  }, [sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, positionHandlers, pathFunction, edgeType]);

  const startDragging = useCallback((event, handlerIndex) => {
    const handleDrag = (moveEvent) => {
      const position = reactFlowInstance.screenToFlowPosition({
        x: moveEvent.clientX,
        y: moveEvent.clientY,
      });

      reactFlowInstance.setEdges((edges) => {
        const edgeIndex = edges.findIndex((edge) => edge.id === id);
        if (edgeIndex === -1) return edges;

        const newEdges = [...edges];
        const newHandlers = [...newEdges[edgeIndex].data.positionHandlers];
        newHandlers[handlerIndex] = {
          ...newHandlers[handlerIndex],
          x: position.x,
          y: position.y,
          active: true
        };

        newEdges[edgeIndex] = {
          ...newEdges[edgeIndex],
          data: {
            ...newEdges[edgeIndex].data,
            positionHandlers: newHandlers
          }
        };

        return newEdges;
      });
    };

    const stopDragging = () => {
      window.removeEventListener('mousemove', handleDrag);
      window.removeEventListener('mouseup', stopDragging);
      
      // Reset active state
      reactFlowInstance.setEdges((edges) => {
        const edgeIndex = edges.findIndex((edge) => edge.id === id);
        if (edgeIndex === -1) return edges;

        const newEdges = [...edges];
        const newHandlers = newEdges[edgeIndex].data.positionHandlers.map(
          handler => ({ ...handler, active: false })
        );

        newEdges[edgeIndex] = {
          ...newEdges[edgeIndex],
          data: {
            ...newEdges[edgeIndex].data,
            positionHandlers: newHandlers
          }
        };

        return newEdges;
      });
    };

    window.addEventListener('mousemove', handleDrag);
    window.addEventListener('mouseup', stopDragging);
  }, [id, reactFlowInstance]);

  const handleDelete = useCallback((event, handlerIndex) => {
    event.preventDefault();
    event.stopPropagation();

    reactFlowInstance.setEdges((edges) => {
      const edgeIndex = edges.findIndex((edge) => edge.id === id);
      if (edgeIndex === -1) return edges;

      const newEdges = [...edges];
      const newHandlers = [...newEdges[edgeIndex].data.positionHandlers];
      newHandlers.splice(handlerIndex, 1);

      newEdges[edgeIndex] = {
        ...newEdges[edgeIndex],
        data: {
          ...newEdges[edgeIndex].data,
          positionHandlers: newHandlers
        }
      };

      return newEdges;
    });
  }, [id, reactFlowInstance]);

  const EdgeHandler = memo(({ x, y, handlerIndex, active, isVertical, onDragStart, onDelete }) => (
    <EdgeLabelRenderer>
      <div
        className="nopan nodrag"
        style={{
          position: 'absolute',
          transform: `translate(-50%, -50%) translate(${x}px,${y}px)`,
          pointerEvents: 'all',
        }}
      >
        <div
          className={cn(
            "relative flex items-center justify-center",
            "w-3 h-3 rounded-full bg-slate-200 dark:bg-slate-300",
            "border-2 border-cyan-500 dark:border-cyan-600",
            "shadow-sm cursor-move",
            "transition-colors duration-200",
            active && "scale-110"
          )}
          onMouseDown={onDragStart}
          onContextMenu={onDelete}
        />
      </div>
    </EdgeLabelRenderer>
  ));

  return (
    <>
      {edgeSegmentsArray.map(({ edgePath }, index) => (
        <ClickableBaseEdge
          onClick={(event) => handleEdgeClick(event, index)}
          key={`edge${id}_segment${index}`}
          path={edgePath}
          markerEnd={markerEnd}
          onMouseEnter={() => setIsHovered(true)}
          onMouseLeave={() => setIsHovered(false)}
          style={{
            ...style,
            strokeWidth: 2,
            opacity: 0.75,
            stroke: isExecuting ? 'var(--color-yellow)' : 'var(--color-cyan)',
            ...(isExecuting && {
              strokeDasharray: '4 4',
              animation: 'dash 0.25s linear infinite'
            })
          }}
          className={cn(
            "react-flow__edge-path",
            selected && "!stroke-semantic-yellow"
          )}
        />
      ))}
      
      {(selected || isHovered) && positionHandlers.map((handler, index) => (
        <EdgeHandler
          key={`edge${id}_handler${index}`}
          {...handler}
          handlerIndex={index}
          isVertical={segmentPoints[index]?.isVertical}
          onDragStart={(e) => startDragging(e, index)}
          onDelete={(e) => handleDelete(e, index)}
        />
      ))}
    </>
  );
});

PositionableEdge.displayName = 'PositionableEdge';

PositionableEdge.propTypes = {
  id: PropTypes.string.isRequired,
  sourceX: PropTypes.number.isRequired,
  sourceY: PropTypes.number.isRequired,
  targetX: PropTypes.number.isRequired,
  targetY: PropTypes.number.isRequired,
  sourcePosition: PropTypes.string.isRequired,
  targetPosition: PropTypes.string.isRequired,
  style: PropTypes.object,
  markerEnd: PropTypes.string,
  selected: PropTypes.bool,
  data: PropTypes.shape({
    positionHandlers: PropTypes.arrayOf(PropTypes.shape({
      x: PropTypes.number,
      y: PropTypes.number,
      active: PropTypes.bool,
      sourcePosition: PropTypes.string,
      targetPosition: PropTypes.string
    }))
  })
};

export default PositionableEdge; 
===========================================
<components/diagram/nodes/BaseNode.jsx>
===========================================
import { memo, useState, useEffect } from 'react';
import { Star } from 'lucide-react';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';
import Box from '../../common/Box';
import { Body2 } from '../../common/Typography';
import { useDiagram } from '../../../contexts/DiagramContext';
import Typography from '../../common/Typography';
import * as Icons from 'lucide-react';
import { NODE_TYPES, getNodeColor } from '../../../constants/nodeTypes';
import ProgressBar from '../../common/ProgressBar';

const BaseNode = memo(({ 
  id,
  type,
  isConnectable,
  selected,
  children,
  data = {},
  className,
  ...props 
}) => {
  const { isDark } = useTheme();
  const { executingNodeIds, nodeSequence, lastOutput } = useDiagram();
  const nodeType = NODE_TYPES[type];
  const Icon = nodeType?.icon;

  // Check if we should show progress
  const showProgress = data?.progress?.percentage !== undefined;
  const [localProgress, setLocalProgress] = useState(0);
  const [localSuccess, setLocalSuccess] = useState(false);
  const [color, setColor] = useState('slate');

  const handleFinishProgress = (progress) => {
    setLocalProgress(progress);
    if (progress === 100) {
      setTimeout(() => {
        setLocalProgress(0);
      }, 1000);
    }
  }

  useEffect(() => {
    if (data.progress?.percentage === 100) {
      handleFinishProgress(data.progress.percentage);
    }
  }, [data.progress?.percentage]);

  useEffect(() => {
    if (lastOutput?.[id]?.data?.success) {
      console.log(`${id} success`);
      setLocalSuccess(true);
    }
  }, [lastOutput]);

  useEffect(() => {
    setColor(getNodeColor(type));
  }, [getNodeColor(type)]);

  useEffect(() => {
    console.log(data.testResults);
  }, [data.testResults]);
  
  // variable holding the svg for the vertical lines
  const vertLines = <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 120" className="w-[80px] h-[80px]">
    <defs>
        <clipPath id="viewportClip">
          <rect width="120" height="120" />
        </clipPath>
        <mask id="circleMask">
          <rect width="120" height="120" fill="white"/>
          <circle cx="45" cy="58" r="25" fill="black"/>
        </mask>
      </defs>

      <circle cx="45" cy="58" r="25" style={{stroke: `var(--color-${color}-${isDark ? 400 : 100})`}} fill="none" strokeWidth={2}/>
    

    <g clipPath="url(#viewportClip)" mask="url(#circleMask)">
      <line x1="0" y1="0" x2="0" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 100})`, strokeWidth: 1,}} strokeDasharray="4 4" />
      <line x1="20" y1="0" x2="20" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 100})`, strokeWidth: 1}} strokeDasharray="4 4" />
      <line x1="40" y1="0" x2="40" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 100})`, strokeWidth: 1}} strokeDasharray="4 4" />
      <line x1="60" y1="0" x2="60" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" />
      <line x1="80" y1="0" x2="80" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" />
      <line x1="100" y1="0" x2="100" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" />
      <line x1="120" y1="0" x2="120" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" />
      <line x1="10" y1="0" x2="10" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" strokeDashoffset="4" />
      <line x1="30" y1="0" x2="30" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" strokeDashoffset="4" />
      <line x1="50" y1="0" x2="50" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" strokeDashoffset="4" />
      <line x1="70" y1="0" x2="70" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" strokeDashoffset="4" />
      <line x1="90" y1="0" x2="90" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" strokeDashoffset="4" />
      <line x1="110" y1="0" x2="110" y2="120" style={{stroke: `var(--color-${color}-${isDark ? 400 : 200})`, strokeWidth: 1}} strokeDasharray="4 4" strokeDashoffset="4" />
    </g>
  </svg>

  return (
      <Box
        borderOpacity={10}
        blur={1}
        padding={0}
        selected={selected}
        className={cn(
          "h-[80px]",
          "w-[220px]",
          "flex flex-col justify-between",
          "border-b rounded-3xl",
          "transition-all duration-200",
          isDark && selected && 'shadow-lg shadow-[0px_0px_10px_5px_rgba(246,211,45,0.15)]',
          !isDark && selected && 'shadow-lg shadow-[0px_0px_10px_5px_rgba(100,116,139,0.25)]'
        )}
      >
        {localSuccess && <div className="absolute top-0 right-0 w-2 h-2 bg-green-500 rounded-full"></div>}

        
            
        <div className={cn(
          'h-full flex flex-row justify-center',
          'transition-all duration-200',
          isDark ? 'bg-slate-800' : 'bg-slate-100',
          !selected && 'border-slate-200 dark:border-slate-400',
          isDark && selected && 'border-semantic-yellow',
          !isDark && selected && 'border-slate-500'
        )}>
          
          <div className={cn(
            `w-[80px] h-full overflow-hidden border-r dark:bg-slate-900/80`,
            'transition-all duration-200',
            !selected && 'border-slate-400 dark:border-slate-400',
            selected && `dark:border-semantic-yellow border-slate-500`
          )}
          style={{
            backgroundColor: !isDark ? `var(--color-${color}-400)` : ``,
          }}
          >
            <div className="absolute top-0 left-0 w-[60px] h-[50%] dark:bg-slate-200/10"></div>
            <div className="absolute left-[20px] top-[28px] z-10">
              {Icon && 
                <Icon size={20} 
                  className={cn(
                    `text-white`,
                    selected && 'animate-spin-ease-in-out',
                    data.testResults?.passed === false && 'text-red-500'
                  )} 
                />}
            </div>
            {vertLines}
          </div>
          <div className="w-full h-full flex flex-col justify-center dark:bg-slate-900/50">
            
            <div id="node-text-container" className="flex flex-col justify-center p-2 h-full">
              <Typography variant="caption" color="slate">{id || ''}</Typography>
              <Typography variant="caption" color="yellow">{data?.name?.slice(0, 30) || ''}</Typography> 
              <Typography variant="caption" color="slate">{children}</Typography>
            </div>
            <div className={cn(
              'h-[10px] w-full relative',
              'bg-slate-200 dark:bg-slate-900/50',
            )}>
              {showProgress && (
                  <ProgressBar 
                    progress={data.progress?.percentage == 100 ? localProgress : data.progress?.percentage} 
                    className="w-full rounded-l-none"
                    color={color}
                  />
              )}
            </div>
          </div>

        </div>

        
      </Box>

  );
});

BaseNode.displayName = 'BaseNode';

export default BaseNode; 
===========================================
<components/diagram/nodes/CommandNode.jsx>
===========================================
import { memo } from 'react';
import { Terminal } from 'lucide-react';
import { Handle, Position } from 'reactflow';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const CommandNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();

  return (
    <>
      
      <BaseNode
        id={id}
        type="command"
        selected={selected}
        data={data}
        isConnectable={isConnectable}
      >
        {data.command && data.command.slice(0, 20) + (data.command.length > 20 ? '...' : '')}
      </BaseNode>
      
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          isDark ? "bg-gray-700" : "bg-gray-200"
        )}
      />
      <Handle
        type="source"
        position={Position.Right}
        id={`${id}-source`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          isDark ? "bg-gray-700" : "bg-gray-200"
        )}
      />
    </>
  );
});

CommandNode.displayName = 'CommandNode';

export default CommandNode; 
===========================================
<components/diagram/nodes/ConditionalNode.jsx>
===========================================
import { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { GitBranch } from 'lucide-react';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const ConditionalNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();
  const conditions = data.conditions || [];
  
  // Calculate positions for output handles
  const getHandlePosition = (index, total) => {
    // Space them evenly in the top 75% of the node
    const availableSpace = 75;
    const spacing = availableSpace / Math.max(1, total);
    return 12.5 + (index * spacing); // Start at 12.5% to center in the available space
  };

  return (
    <>
      
      <BaseNode
        id={id}
        type="conditional"
        icon={GitBranch}
        color="orange"
        selected={selected}
        data={data}
        isConnectable={isConnectable}
      />
      
      {/* Input Handle */}
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className="handle-left handle-input-dark"
      />

      {conditions.length == 1 && (
        <Handle
          key={`condition-0`}
          type="source"
          position={Position.Right}
          id={`output-0`}
          isConnectable={isConnectable}
          className="handle-right handle-output-dark"
        />
      )}
      {conditions.length > 1 && conditions.map((_, index) => (
        <Handle
          key={`condition-${index}`}
          type="source"
          position={Position.Right}
          id={`output-${index + 1}`}
          isConnectable={isConnectable}
          className="handle-right handle-output-dark"
          style={{
            top: `${getHandlePosition(index, conditions.length - 1)}%`
          }}
        />
      ))}

      {/* Else Handle - Shows up when there's at least one condition */}
      {conditions.length > 0 && (
        <Handle
          type="source"
          position={Position.Bottom}
          id="output-else"
          isConnectable={isConnectable}
          className="handle-bottom handle-output-dark handle-red-dark"
        />
      )}
    </>
  );
});

ConditionalNode.displayName = 'ConditionalNode';

export default ConditionalNode; 
===========================================
<components/diagram/nodes/DatabaseQueryNode.jsx>
===========================================
import { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Database } from 'lucide-react';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const DatabaseQueryNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();

  return (
    <>
      <BaseNode
        id={id}
        type="databaseQuery"
        selected={selected}
        data={data}
        isConnectable={isConnectable}
      />
      
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className={cn(
          "handle-left",
          isDark && "handle-input-dark",
          !isDark && "handle-input-light"
        )}
      />
      
      <Handle
        type="source"
        position={Position.Right}
        id={`${id}-source`}
        isConnectable={isConnectable}
        className={cn(
          "handle-right",
          isDark && "handle-output-dark",
          !isDark && "handle-output-light"
        )}
      />
    </>
  );
});

DatabaseQueryNode.displayName = 'DatabaseQueryNode';

export default DatabaseQueryNode; 
===========================================
<components/diagram/nodes/FileOpNode.jsx>
===========================================
import { memo } from 'react';
import { FileText } from 'lucide-react';
import { Handle, Position } from 'reactflow';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const FileOpNode = memo(({ data, isConnectable, selected, id }) => {
  const { isDark } = useTheme();

  return (
    <BaseNode
      id={id}
      type="fileop"
      icon={FileText}
      color="orange"
      isConnectable={isConnectable}
      selected={selected}
      data={data}
      handles={[
        {
          type: "target",
          position: Position.Left,
          id: `${id}-target`,
          className: cn(
            "w-3 h-3",
            isDark ? "bg-gray-700" : "bg-gray-200"
          )
        },
        {
          type: "source",
          position: Position.Right,
          id: `${id}-source`,
          className: cn(
            "w-3 h-3",
            isDark ? "bg-gray-700" : "bg-gray-200"
          )
        }
      ]}
    />
  );
});

FileOpNode.displayName = 'FileOpNode';

export default FileOpNode; 
===========================================
<components/diagram/nodes/FormatNode.jsx>
===========================================
import { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { FileCode } from 'lucide-react';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const FormatNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();

  return (
    <>
      <BaseNode
        id={id}
        type="format"
        icon={FileCode}
        selected={selected}
        data={data}
      />
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          isDark ? "bg-gray-700" : "bg-gray-200"
        )}
      />


      <Handle
        type="source"
        position={Position.Right}
        id={`${id}-source`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          isDark ? "bg-gray-700" : "bg-gray-200"
        )}
      />
    </>
  );
});

FormatNode.displayName = 'FormatNode';

export default FormatNode; 
===========================================
<components/diagram/nodes/HTTPNode.jsx>
===========================================
import { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Globe } from 'lucide-react';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const HTTPNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();

  return (
    <>
      
      <BaseNode
        id={id}
        type="http"
        selected={selected}
        data={data}
        isConnectable={isConnectable}
      />
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className={cn(
          "handle-left",
          isDark && "handle-input-dark",
          !isDark && "handle-input-light"
        )}
      />
      
      <Handle
        type="source"
        position={Position.Right}
        id={`${id}-source`}
        isConnectable={isConnectable}
        className={cn(
          "handle-right",
          isDark && "handle-output-dark",
          !isDark && "handle-output-light"
        )}
      />
      
    </>
  );
});

HTTPNode.displayName = 'HTTPNode';

export default HTTPNode; 
===========================================
<components/diagram/nodes/IteratorNode.jsx>
===========================================
import { memo } from 'react';
import { RefreshCw } from 'lucide-react';
import { Handle, Position } from 'reactflow';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const IteratorNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();

  return (
    <>
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          isDark ? "bg-gray-700" : "bg-gray-200"
        )}
      />
      
      <BaseNode
        id={id}
        type="iterator"
        icon={RefreshCw}
        color="cyan"
        selected={selected}
        data={data}
        isConnectable={isConnectable}
      />
      
      <Handle
        type="source"
        position={Position.Right}
        id={`${id}-source`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          isDark ? "bg-gray-700" : "bg-gray-200"
        )}
      />
    </>
  );
});

IteratorNode.displayName = 'IteratorNode';

export default IteratorNode; 
===========================================
<components/diagram/nodes/LoggerNode.jsx>
===========================================
import { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { FileText } from 'lucide-react';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const LoggerNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();

  const inputHandleStyle = cn(
    "w-3 h-3",
    isDark ? "bg-cyan-700 border-cyan-500" : "bg-cyan-100 border-cyan-500"
  );

  return (
    <>
      <BaseNode
        id={id}
        type="logger"
        icon={FileText}
        color={data?.color}
        selected={selected}
        data={data}
        isConnectable={isConnectable}
      />
      
      <Handle
        type="target"
        position={Position.Top}
        id={`${id}-top`}
        isConnectable={isConnectable}
        className={inputHandleStyle}
      />

      <Handle
        type="target"
        position={Position.Bottom}
        id={`${id}-bottom`}
        isConnectable={isConnectable}
        className={inputHandleStyle}
      />

      <Handle
        type="target"
        position={Position.Right}
        id={`${id}-right`}
        isConnectable={isConnectable}
        className={inputHandleStyle}
      />

      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-left`}
        isConnectable={isConnectable}
        className={inputHandleStyle}
      />
    </>
  );
});

LoggerNode.displayName = 'LoggerNode';

export default LoggerNode; 
===========================================
<components/diagram/nodes/NodeLabel.jsx>
===========================================
import { useState, useCallback, useContext } from 'react';
import { DiagramContext } from '../../../contexts/DiagramContext';

const NodeLabel = ({ id, isSelected }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(id);
  const { renameNode } = useContext(DiagramContext);

  const handleDoubleClick = useCallback(() => {
    setIsEditing(true);
    setEditValue(id);
  }, [id]);

  const handleBlur = useCallback(() => {
    if (editValue !== id) {
      const success = renameNode(id, editValue);
      if (!success) {
        setEditValue(id); // Reset if rename failed
      }
    }
    setIsEditing(false);
  }, [id, editValue, renameNode]);

  const handleKeyDown = useCallback((e) => {
    if (e.key === 'Enter') {
      e.target.blur();
    } else if (e.key === 'Escape') {
      setEditValue(id);
      setIsEditing(false);
    }
  }, [id]);

  return (
    <div className="absolute -top-6 left-0 right-0 text-center">
      {isEditing ? (
        <input
          type="text"
          value={editValue}
          onChange={(e) => setEditValue(e.target.value)}
          onBlur={handleBlur}
          onKeyDown={handleKeyDown}
          className={`
            px-1 py-0.5 text-sm rounded border
            ${isSelected ? 'border-blue-500' : 'border-gray-300'}
            focus:outline-none focus:border-blue-500
            dark:bg-gray-800 dark:border-gray-600
          `}
          autoFocus
        />
      ) : (
        <span
          onDoubleClick={handleDoubleClick}
          className={`
            px-1 py-0.5 text-sm rounded cursor-pointer
            ${isSelected ? 'text-blue-500' : 'text-gray-600'}
            hover:bg-gray-100 dark:hover:bg-gray-700
            dark:text-gray-300
          `}
        >
          {id}
        </span>
      )}
    </div>
  );
};

export default NodeLabel; 
===========================================
<components/diagram/nodes/ParserNode.jsx>
===========================================
import { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { FileJson } from 'lucide-react';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const ParserNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();

  return (
    <>
      <BaseNode
        id={id}
        type="parser"
        icon={FileJson}
        color="purple"
        selected={selected}
        data={data}
        isConnectable={isConnectable}
      />
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          "border-2 border-cyan-500",
          "bg-cyan-700"
        )}
      />
      
      
      <Handle
        type="source"
        position={Position.Right}
        id={`${id}-source`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          "border-2 border-green-500",
          "bg-green-700"
        )}
      />
    </>
  );
});

ParserNode.displayName = 'ParserNode';

export default ParserNode; 
===========================================
<components/diagram/nodes/PromptNode.jsx>
===========================================
import { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Sparkles } from 'lucide-react';
import { cn } from '../../../utils';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';

const PromptNode = memo(({ 
  data, 
  selected,
  id,
  isConnectable 
}) => {
  const { isDark } = useTheme();

  return (
    <>
      <BaseNode
        id={id}
        type="prompt"
        selected={selected}
        data={data}
        isConnectable={isConnectable}
        icon={<Sparkles size={16} className="text-semantic-purple" />}
        label="Prompt"
      />
      
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className={cn(
          "handle-left",
          isDark && "handle-input-dark",
          !isDark && "handle-input-light"
        )}
      />
      
      <Handle
        type="source"
        position={Position.Right}
        id={`${id}-source`}
        isConnectable={isConnectable}
        className={cn(
          "handle-right",
          isDark && "handle-output-dark",
          !isDark && "handle-output-light"
        )}
      />
    </>
  );
});

PromptNode.displayName = 'PromptNode';

export default PromptNode; 
===========================================
<components/diagram/nodes/RSSNode.jsx>
===========================================
import { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Rss } from 'lucide-react';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { cn } from '../../../utils';

const RSSNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();

  return (
    <>
      <BaseNode
        id={id}
        type="rss"
        selected={selected}
        data={data}
        isConnectable={isConnectable}
      />
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className={cn(
          "handle-left",
          isDark && "handle-input-dark",
          !isDark && "handle-input-light"
        )}
      />
      <Handle
        type="source"
        position={Position.Right}
        id={`${id}-source`}
        isConnectable={isConnectable}
        className={cn(
          "handle-right",
          isDark && "handle-output-dark",
          !isDark && "handle-output-light"
        )}
      />
    </>
  );
});

RSSNode.displayName = 'RSSNode';

export default RSSNode; 
===========================================
<components/diagram/nodes/TestNode.jsx>
===========================================
import { memo, useMemo, useState} from 'react';
import { Handle, Position } from 'reactflow';
import { Check, X } from 'lucide-react';
import { cn } from '../../../utils';
import BaseNode from './BaseNode';
import { useTheme } from '../../../contexts/ThemeContext';
import { useDiagram } from '../../../contexts/DiagramContext';

const TestNode = memo(({ data, selected, id, isConnectable }) => {
  const { isDark } = useTheme();
  const { lastOutput, executingNodeIds} = useDiagram();

  const [localTestData, setLocalTestData] = useState(null);
  
  // Get execution status from the diagram context
  const isExecuting = executingNodeIds?.has?.(id) || false;
  
  // Get test results from lastOutput, handling the nested structure
  const testResults = useMemo(() => {
    if (!lastOutput || lastOutput.nodeId !== id) return null;
    
    let testData = {
        ...localTestData,
        results: lastOutput.data?.response?.results || [],
        passed: lastOutput.data?.response?.success || false,
    }
    setLocalTestData(testData);
    return testData;
  }, [lastOutput, id]);
  

  // Dynamic styling based on test results
  const getStatusStyles = () => {
    if (isExecuting) {
      return "animate-pulse bg-yellow-500/20";
    }
    if (localTestData?.passed === true) {
      return "bg-green-500/20 dark:bg-green-500/30";
    }
    if (localTestData?.passed === false) {
      return "bg-red-500/20 dark:bg-red-500/30";
    }
    return "";
  };

  const getIconColor = () => {
    if (isExecuting) return "text-yellow-500";
    if (localTestData?.passed === true) return "text-green-500";
    if (localTestData?.passed === false) return "text-red-500";
    return "text-slate-500";
  };

  const getBorderColor = () => {
    if (isExecuting) return "border-yellow-500";
    if (localTestData?.passed === true) return "border-green-500";
    if (localTestData?.passed === false) return "border-red-500";
    return "border-slate-200 dark:border-slate-700";
  };

  // Get summary of test results
  const getTestSummary = () => {
    if (!localTestData?.results) return '';
    const passed = localTestData.results.filter(r => r.success).length;
    const total = localTestData.results.length;
    return ` (${passed}/${total})`;
  };

  return (
    <>
      <BaseNode
        id={id}
        type="test"
        selected={selected}
        data={{
          ...data,
          testResults: localTestData,
        }}
        className={cn(
          "transition-all duration-300",
          getStatusStyles(),
        )}
      >
        <div className="flex items-center gap-2">
          {localTestData?.passed ? <Check size={16} className={cn("transition-colors", getIconColor())} /> : ''}
          <div className="flex flex-col">

            {localTestData && (
              <span className={cn(
                "text-xs",
                localTestData?.passed ? "text-green-500" : "text-red-500"
              )}>

                {getTestSummary()}
              </span>
            )}
          </div>
        </div>
      </BaseNode>

      {/* Input Handle */}
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}-target`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          "border-2",
          isDark ? "bg-slate-700" : "bg-slate-200",
          getBorderColor()
        )}
      />

      {/* Output Handle */}
      <Handle
        type="source"
        position={Position.Right}
        id={`${id}-source`}
        isConnectable={isConnectable}
        className={cn(
          "w-3 h-3",
          "border-2",
          isDark ? "bg-slate-700" : "bg-slate-200",
        )}
      />
    </>
  );
});

TestNode.displayName = 'TestNode';

export default TestNode;
===========================================
<components/diagram/nodes/index.js>
===========================================
import PromptNode from './PromptNode';
import ParserNode from './ParserNode';
import ConditionalNode from './ConditionalNode';
import FileOpNode from './FileOpNode';
import HTTPNode from './HTTPNode';
import FormatNode from './FormatNode';
import LoggerNode from './LoggerNode';

export const nodeTypes = {
  prompt: PromptNode,
  parser: ParserNode,
  conditional: ConditionalNode,
  fileop: FileOpNode,
  http: HTTPNode,
  format: FormatNode,
  logger: LoggerNode,
};

export {
  PromptNode,
  ParserNode,
  ConditionalNode,
  FileOpNode,
  HTTPNode,
  FormatNode,
}; 
===========================================
<components/diagram/utility/UtilityDrawer.jsx>
===========================================
import { useState, memo, useEffect, useRef } from 'react';
import { useDiagram } from '../../../contexts/DiagramContext';
import { cn } from '../../../utils';
import { useTheme } from '../../../contexts/ThemeContext';
import { Body1, Body2 } from '../../common/Typography';
import NodeInfo from './panels/NodeInfo';
import DebugPanel from './panels/DebugPanel';
import LogsPanel from './panels/LogsPanel';
import UtilitySidebar from './UtilitySidebar';
import SidebarItem from '../../common/SidebarItem';
import { Info, FileText, Bug } from 'lucide-react';

const UtilityDrawer = memo(() => {
  const [isOpen, setIsOpen] = useState(true);
  const [activeTab, setActiveTab] = useState('info');
  const { isDark } = useTheme();
  const { selectedNode, autoOpenDrawer, autoCloseDrawer } = useDiagram();
  const drawerRef = useRef(null);
  const lastNodeRef = useRef(null);

  useEffect(() => {
    if (selectedNode && autoOpenDrawer) {
      lastNodeRef.current = selectedNode.id;
      setIsOpen(true);
      setActiveTab('info');
    }
  }, [selectedNode, autoOpenDrawer]);

  const handleToggle = () => {
    setIsOpen(!isOpen);
  };

  const handleTabClick = (tabId) => {
    setActiveTab(tabId);
    if (!isOpen) {
      setIsOpen(true);
    }
  };

  const handleBlur = (e) => {

    if (autoCloseDrawer && 
        !e.currentTarget.contains(e.relatedTarget) && 
        (!e.relatedTarget || !e.relatedTarget.closest('.react-flow__node'))) {
      setIsOpen(false);
    }
  };

  return (
    <div
      id="utility-drawer"
      ref={drawerRef}
      className={cn(
        "fixed top-0 right-0 h-full",
        "bg-slate-300 dark:bg-slate-900",
        "border-l border-slate-200 dark:border-slate-700",
        "transition-all duration-250 ease-in-out",
        "z-50",
        "flex flex-row",
        isOpen ? `w-[30vw] min-w-[500px]` : `w-[72px]`
      )}
      onBlur={handleBlur}
      tabIndex={0}
    >
      <UtilitySidebar
        position="left"
        open={isOpen}
        callback={handleToggle}
      >
        <SidebarItem
          utility={true}
          icon={<Info size={20} />}
          text="Node Info"
          active={activeTab === 'info'}
          onClick={() => handleTabClick('info')}
        />
        <SidebarItem
          utility={true}
          icon={<FileText size={20} />}
          text="Logs"
          active={activeTab === 'logs'}
          onClick={() => handleTabClick('logs')}
        />
        <SidebarItem
          utility={true}
          icon={<Bug size={20} />}
          text="Debug"
          active={activeTab === 'debug'}
          onClick={() => handleTabClick('debug')}
        />
      </UtilitySidebar>
      
      {isOpen && (
        <div className="flex-1 min-w-0">
          <div className="h-full overflow-y-auto">
            <div className="p-4">
              {activeTab === 'info' && <NodeInfo node={selectedNode} />}
              {activeTab === 'logs' && <LogsPanel />}
              {activeTab === 'debug' && <DebugPanel />}
            </div>
          </div>
        </div>
      )}
    </div>
  );
});

UtilityDrawer.displayName = 'UtilityDrawer';

export default UtilityDrawer;
===========================================
<components/diagram/utility/UtilitySidebar.jsx>
===========================================
import { createContext, useContext, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../../contexts/ThemeContext';
import Box from '../../common/Box';
import {ChevronLeft, ChevronRight} from 'lucide-react';

const UtilitySidebar = ({
  children,
  position = 'right',
  className = '',
  width = 72,
  callback,
  open = true,
  ...props
}) => {

  const [isOpen, setIsOpen] = useState(open);
  const [activePanel, setActivePanel] = useState(null);
  const {isDark} = useTheme()

  const handleToggle = () => {
    setIsOpen(!isOpen);
    if (callback) callback();
  }

  useEffect(() => {
    setIsOpen(open);
  }, [open]);


  return (
    <Box
      className={`
        flex
        flex-col
        h-screen
        sticky
        top-0
        ${position === 'left' ? 'left-0' : 'right-0'}
        overflow-x-hidden
        overflow-y-auto
        bg-slate-700
        border-l-0
        border-slate-700
        ${className}
      `.trim()}
      style={{
        width: width,
      }}
      opacity={10}
      blur={2}
      rounded="none"
      {...props}
    >
      <div className="flex-1 py-2 text-slate-300">
        {children}
      </div>
      <div
      onClick={handleToggle} 
      className={`
        absolute
        left-0
        top-1/2
        -translate-y-1/2
        flex
        justify-center
        items-center
        w-[30px]
        h-[60px]
        border-r border-t border-b
        border-slate-700
        cursor-pointer
        bg-slate-800
        hover:bg-slate-700
        rounded-r-md
      `}>
        {isOpen ? <ChevronRight size={20} color="white" /> : <ChevronLeft size={20} color="white" />}
      </div>

    </Box>
  );
};

UtilitySidebar.propTypes = {
  children: PropTypes.node.isRequired,
  position: PropTypes.oneOf(['left', 'right']),
  width: PropTypes.number,
  className: PropTypes.string,
  callback: PropTypes.func,
  open: PropTypes.bool,
};

export default UtilitySidebar; 
===========================================
<components/diagram/utility/nodeConfigs/CommandNodeConfig.jsx>
===========================================
import { memo, useState } from 'react';
import { Body2 } from '../../../common/Typography';
import { useDiagram } from '../../../../contexts/DiagramContext';
import TextArea from '../../../common/TextArea';
import Input from '../../../common/Input';
import Button from '../../../common/Button';
import Box from '../../../common/Box';
import { Plus, Trash2, Terminal, Timer, Folder, Variable } from 'lucide-react';
import TreeView from '../../../common/TreeView';

const CommandNodeConfig = memo(({ node }) => {
  const { updateNodeData } = useDiagram();
  const [newVarName, setNewVarName] = useState('');
  const [newVarValue, setNewVarValue] = useState('');

  const handleCommandChange = (e) => {
    updateNodeData(node.id, 'command', e.target.value);
  };

  const handleWorkingDirChange = (e) => {
    updateNodeData(node.id, 'workingDirectory', e.target.value);
  };

  const handleTimeoutChange = (e) => {
    const timeout = parseInt(e.target.value) || 30000;
    updateNodeData(node.id, 'timeout', timeout);
  };

  const handleAddEnvVar = () => {
    if (!newVarName || !newVarValue) return;
    const currentVars = node.data?.environmentVars || [];
    updateNodeData(node.id, 'environmentVars', [
      ...currentVars,
      {
        variable: 'CREATE_NEW',
        newVariableName: newVarName,
        value: newVarValue
      }
    ]);
    setNewVarName('');
    setNewVarValue('');
  };

  const handleRemoveEnvVar = (index) => {
    const currentVars = node.data?.environmentVars || [];
    updateNodeData(
      node.id, 
      'environmentVars', 
      currentVars.filter((_, i) => i !== index)
    );
  };

  return (
    <div className="space-y-6">
      {/* Command Section */}
      <Box padding={4} blur={2} opacity={2} className="space-y-4">
        <div className="flex items-center gap-2">
          <Terminal size={16} className="text-slate-500" />
          <Body2 className="font-medium">Command</Body2>
        </div>
        <TextArea
          value={node.data?.command || ''}
          onChange={handleCommandChange}
          placeholder="Enter command (e.g., 'echo {{input}}')"
          variant="glass"
          rows={4}
          helper="Use {{variable}} for dynamic values"
        />
      </Box>

      {/* Options Section */}
      <Box padding={4} blur={2} opacity={2} className="space-y-4">
        <div className="flex items-center gap-2 mb-4">
          <Timer size={16} className="text-slate-500" />
          <Body2 className="font-medium">Options</Body2>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <Input
            startIcon={Folder}
            value={node.data?.workingDirectory || ''}
            onChange={handleWorkingDirChange}
            placeholder="/path/to/working/directory"
            variant="glass"
            helper="Working Directory"
          />
          <Input
            type="number"
            value={node.data?.timeout || 30000}
            onChange={handleTimeoutChange}
            placeholder="30000"
            variant="glass"
            helper="Timeout (ms)"
          />
        </div>
      </Box>

      {/* Environment Variables Section */}
      <Box padding={4} blur={2} opacity={2} className="space-y-4">
        <div className="flex items-center gap-2 mb-4">
          <Variable size={16} className="text-slate-500" />
          <Body2 className="font-medium">Environment Variables</Body2>
        </div>

        <div className="flex gap-2">
          <Input
            value={newVarName}
            onChange={(e) => setNewVarName(e.target.value)}
            placeholder="Variable Name"
            variant="glass"
            className="flex-1"
          />
          <Input
            value={newVarValue}
            onChange={(e) => setNewVarValue(e.target.value)}
            placeholder="Value Template"
            variant="glass"
            className="flex-1"
          />
          <Button
            variant="glass"
            size="md"
            onClick={handleAddEnvVar}
            disabled={!newVarName || !newVarValue}
            startIcon={<Plus size={16} />}
          >
            Add
          </Button>
        </div>

        <div className="space-y-2 mt-4">
          {(node.data?.environmentVars || []).map((envVar, index) => (
            <Box 
              key={index} 
              padding={3} 
              blur={1} 
              opacity={1}
              className="flex items-center justify-between"
            >
              <div className="flex-1">
                <Body2 className="font-medium">
                  {envVar.variable === 'CREATE_NEW' ? 
                    envVar.newVariableName : 
                    envVar.variable}
                </Body2>
                <div className="text-sm text-slate-500">{envVar.value}</div>
              </div>
              <Button
                variant="ghost"
                size="sm"
                color="red"
                onClick={() => handleRemoveEnvVar(index)}
                startIcon={<Trash2 size={16} />}
              />
            </Box>
          ))}
        </div>
      </Box>

      {/* Output Section */}
      {node.data?.result && (
        <Box padding={4} blur={2} opacity={2} className="space-y-4">
          <Body2 className="font-medium">Output</Body2>
          <TreeView 
            data={node.data.result}
            onSelect={() => {}}
          />
        </Box>
      )}
    </div>
  );
});

CommandNodeConfig.displayName = 'CommandNodeConfig';

export default CommandNodeConfig;
===========================================
<components/diagram/utility/nodeConfigs/ConditionalNodeConfig.jsx>
===========================================
import { memo, useCallback, useMemo, useEffect, useState } from 'react';
import { Plus, X, Info } from 'lucide-react';
import { useDiagram } from '../../../../contexts/DiagramContext';
import Select from '../../../common/Select';
import Input from '../../../common/Input';
import Button from '../../../common/Button';
import { Body2 } from '../../../common/Typography';

const OPERATORS = [
  { value: '==', label: 'equals' },
  { value: '>=', label: 'greater than or equal to' },
  { value: '<=', label: 'less than or equal to' },
  { value: 'contains', label: 'contains' }
];

const ConditionalNodeConfig = memo(({ node }) => {
  const { updateNodeData, lastInput } = useDiagram();
  const [lastInputCache, setLastInputCache] = useState(null);

  useEffect(() => {
    if (lastInput?.[node.id]) {
      setLastInputCache(lastInput[node.id]);
    }
  }, [lastInput, node.id]);

  const inputData = useMemo(() => lastInput?.[node.id], [lastInput, node.id]);

  const handleInputChange = useCallback((field, value) => {
    updateNodeData(node.id, field, value);
  }, [node.id, updateNodeData]);

  const handleConditionChange = useCallback((index, field, value) => {
    const conditions = [...(node.data.conditions || [])];
    conditions[index] = {
      ...conditions[index],
      [field]: value
    };
    handleInputChange('conditions', conditions);
  }, [node.data.conditions, handleInputChange]);

  const handleAddCondition = useCallback(() => {
    const conditions = [...(node.data.conditions || [])];
    if (conditions.length < 3) {
      conditions.push({
        field: '',
        operator: '==',
        value: ''
      });
      handleInputChange('conditions', conditions);
    }
  }, [node.data.conditions, handleInputChange]);

  const handleRemoveCondition = useCallback((index) => {
    const conditions = [...(node.data.conditions || [])].filter((_, i) => i !== index);
    handleInputChange('conditions', conditions);
  }, [node.data.conditions, handleInputChange]);

  const getConditionLabel = (index) => {
    if (index === 0) return 'If';
    return 'Else if';
  };

  // Template variables help section
  const templateHelp = (
    <div className="p-4 mt-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg">
      <div className="flex items-start gap-2">
        <Info size={16} className="text-slate-500 mt-0.5" />
        <div className="text-sm space-y-1">
          <p className="font-medium text-slate-500">Template Variables</p>
          <p className="text-slate-500">
            You can use template variables in both field and value inputs:
          </p>
          <ul className="list-disc list-inside text-slate-500">
            <li><code>{'{{data.field}}'}</code> - Access data from previous nodes</li>
            <li><code>{'{{response.status}}'}</code> - HTTP response status</li>
            <li><code>{'{{response.body.field}}'}</code> - Response body fields</li>
          </ul>
        </div>
      </div>
    </div>
  );

  return (
    <div className="space-y-6">
      {/* Conditions */}
      <div className="space-y-4">
        {(node.data.conditions || []).map((condition, index) => (
          <div key={index} className="space-y-2 p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg">
            <div className="flex items-center justify-between">
              <Body2 className="font-medium">
                {getConditionLabel(index)}
              </Body2>
              <Button
                variant="text"
                color="red"
                size="sm"
                onClick={() => handleRemoveCondition(index)}
              >
                <X size={16} />
              </Button>
            </div>

            <div className="flex gap-2">
              <Input
                value={condition.field || ''}
                onChange={(e) => handleConditionChange(index, 'field', e.target.value)}
                placeholder="{{data.field}}"
                variant="filled"
                className="flex-1"
              />
              <Select
                value={condition.operator || '=='}
                onChange={(value) => handleConditionChange(index, 'operator', value)}
                options={OPERATORS}
                className="w-48"
              />
              <Input
                value={condition.value || ''}
                onChange={(e) => handleConditionChange(index, 'value', e.target.value)}
                placeholder="{{data.value}}"
                variant="filled"
                className="flex-1"
              />
            </div>
          </div>
        ))}

        {/* Else Section - Only shows if there's at least one condition */}
        {(node.data.conditions || []).length > 0 && (
          <div className="p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg">
            <Body2 className="font-medium text-slate-500">
              Else (bottom output)
            </Body2>
            <p className="text-sm text-slate-500 mt-1">
              This path will be taken if no conditions match
            </p>
          </div>
        )}

        {/* Add Condition Button */}
        {(node.data.conditions || []).length < 3 && (
          <Button
            variant="light"
            color="purple"
            size="sm"
            startIcon={<Plus size={16} />}
            onClick={handleAddCondition}
            fullWidth
          >
            Add {(node.data.conditions || []).length === 0 ? 'If Condition' : 'Else If Condition'}
          </Button>
        )}
      </div>

      {/* Help Text */}
      {(node.data.conditions || []).length === 0 && (
        <div className="text-sm text-slate-500 text-center p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg">
          Start by adding an "If" condition. Additional conditions will be evaluated in order.
        </div>
      )}

      {/* Template Variables Help */}
      {templateHelp}

      {/* Last Input Section */}
      {lastInputCache && (
        <div className="space-y-2">
          <Body2 className="font-medium">Last Input Data</Body2>
          <pre className="text-xs bg-slate-100 dark:bg-slate-800 rounded-md p-2 overflow-auto max-h-[200px]">
            {JSON.stringify(lastInputCache, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
});

ConditionalNodeConfig.displayName = 'ConditionalNodeConfig';

export default ConditionalNodeConfig; 
===========================================
<components/diagram/utility/nodeConfigs/DatabaseQueryNodeConfig.jsx>
===========================================
import { memo, useState, useMemo, useEffect } from 'react';
import { Plus, X } from 'lucide-react';
import { useDiagram } from '../../../../contexts/DiagramContext';
import { useApi } from '../../../../contexts/ApiContext';
import { Body2, Caption } from '../../../common/Typography';
import Button from '../../../common/Button';
import Input from '../../../common/Input';
import CodeEditor from '../../../common/CodeEditor';

const ParameterRow = memo(({ parameter, onUpdate, onDelete }) => {
  return (
    <div className="flex gap-2">
      <Input
        value={parameter.name}
        onChange={(e) => onUpdate({ ...parameter, name: e.target.value })}
        placeholder="Parameter name"
        variant="filled"
        className="flex-1"
      />
      <Input
        value={parameter.value}
        onChange={(e) => onUpdate({ ...parameter, value: e.target.value })}
        placeholder="Value template"
        variant="filled"
        className="flex-1"
      />
      <Button
        variant="text"
        color="red"
        size="sm"
        onClick={onDelete}
      >
        <X size={16} />
      </Button>
    </div>
  );
});

const DatabaseQueryNodeConfig = memo(({ node }) => {
  const { updateNodeData, lastOutput } = useDiagram();
  const api = useApi();
  const [isExpanded, setIsExpanded] = useState(false);
  const [connections, setConnections] = useState([]);
  const [loading, setLoading] = useState(true);

  // Initialize query if it doesn't exist
  useEffect(() => {
    if (!node.data.query) {
      updateNodeData(node.id, 'query', '');
    }
  }, [node.id]);

  // Load available connections
  useEffect(() => {
    const loadConnections = async () => {
      try {
        const result = await api.storage.listConnections();
        if (result.success) {
          setConnections(result.data || []);
        }
      } catch (error) {
        console.error('Failed to load connections:', error);
      } finally {
        setLoading(false);
      }
    };
    loadConnections();
  }, [api.storage]);

  // Debug logging
  useEffect(() => {
    console.log('Node data updated:', {
      ...node.data,
      query: node.data.query || 'not set'
    });
  }, [node.data]);

  // Get query results from lastOutput
  const queryResult = useMemo(() => {
    if (!lastOutput || lastOutput.nodeId !== node.id) return null;
    return lastOutput.data?.response;
  }, [lastOutput, node.id]);

  const handleConnectionChange = (connectionId) => {
    updateNodeData(node.id, 'connectionId', connectionId);
  };

  const handleAddParameter = () => {
    const parameters = [...(node.data.parameters || [])];
    parameters.push({
      id: `param-${Date.now()}`,
      name: '',
      value: ''
    });
    updateNodeData(node.id, 'parameters', parameters);
  };

  const handleUpdateParameter = (index, updatedParam) => {
    const parameters = [...(node.data.parameters || [])];
    parameters[index] = updatedParam;
    updateNodeData(node.id, 'parameters', parameters);
  };

  const handleDeleteParameter = (index) => {
    const parameters = [...(node.data.parameters || [])];
    parameters.splice(index, 1);
    updateNodeData(node.id, 'parameters', parameters);
  };

  const handleQueryChange = (value) => {
    console.log('Query changed to:', value);
    updateNodeData(node.id, 'query', value);
  };

  const selectedConnection = connections.find(conn => conn.id === node.data.connectionId);

  return (
    <div className="space-y-4">
      {/* Connection Selector */}
      <div className="space-y-2">
        <Body2 className="font-medium">Database Connection</Body2>
        {loading ? (
          <Caption>Loading connections...</Caption>
        ) : connections.length === 0 ? (
          <div className="text-center p-4 border border-dashed border-slate-300 dark:border-slate-600 rounded-md">
            <Caption>No database connections configured.</Caption>
            <Button
              variant="light"
              size="sm"
              className="mt-2"
              onClick={() => {
                // TODO: Navigate to settings page
              }}
            >
              Configure Connections
            </Button>
          </div>
        ) : (
          <select
            value={node.data.connectionId || ''}
            onChange={(e) => handleConnectionChange(e.target.value)}
            className="w-full px-3 py-2 rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800"
          >
            <option value="">Select a connection</option>
            {connections.map((conn) => (
              <option key={conn.id} value={conn.id}>
                {conn.name} ({conn.type})
              </option>
            ))}
          </select>
        )}
        {selectedConnection && (
          <Caption className="text-slate-500">
            {selectedConnection.type} • {selectedConnection.host || selectedConnection.file}
          </Caption>
        )}
      </div>

      {/* Query Editor */}
      <div className="space-y-2">
        <Body2 className="font-medium">SQL Query</Body2>
        <CodeEditor
          value={node.data.query || ''}
          updateField="query"
          node={node}
          language="sql"
          placeholder=""
          className="min-h-[100px]"
        />
        <Caption className="text-slate-500">
          Current query: {node.data.query || 'No query set'}
        </Caption>
      </div>

      {/* Parameters */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <Body2 className="font-medium">Query Parameters</Body2>
          <Button
            variant="light"
            color="green"
            size="sm"
            onClick={handleAddParameter}
            startIcon={<Plus size={16} />}
          >
            Add Parameter
          </Button>
        </div>
        
        <div className="space-y-2">
          {(node.data.parameters || []).map((param, index) => (
            <ParameterRow
              key={param.id}
              parameter={param}
              onUpdate={(updatedParam) => handleUpdateParameter(index, updatedParam)}
              onDelete={() => handleDeleteParameter(index)}
            />
          ))}
        </div>
      </div>

      {/* Query Results */}
      {queryResult && (
        <div className="space-y-2">
          <div 
            className="flex items-center gap-2 cursor-pointer"
            onClick={() => setIsExpanded(!isExpanded)}
          >
            <Body2 className="font-medium">Query Results</Body2>
            <span className="text-xs text-slate-500">
              ({queryResult.rowCount || 0} rows)
            </span>
          </div>
          
          {isExpanded && (
            <div className="bg-slate-100 dark:bg-slate-800 rounded-md p-2 overflow-auto max-h-[300px]">
              <pre className="text-xs">
                {JSON.stringify(queryResult.rows, null, 2)}
              </pre>
            </div>
          )}
        </div>
      )}
    </div>
  );
});

export default DatabaseQueryNodeConfig; 
===========================================
<components/diagram/utility/nodeConfigs/FileOpNodeConfig.jsx>
===========================================
import { memo, useCallback } from 'react';
import { useDiagram } from '../../../../contexts/DiagramContext';
import { Body2 } from '../../../common/Typography';
import Select from '../../../common/Select';
import Input from '../../../common/Input';

const OPERATION_TYPES = [
  { value: 'read', label: 'Read File' },
  { value: 'write', label: 'Write File' }
];

const FileOpNodeConfig = memo(({ node }) => {
  const { updateNodeData } = useDiagram();

  const handleInputChange = (field, value) => {
    updateNodeData(node.id, field, value);
  };

  const handleFileUpload = useCallback((e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      const content = event.target.result;
      handleInputChange('content', content);
      handleInputChange('fileName', file.name);
    };
    reader.readAsText(file);
  }, [handleInputChange]);

  return (
    <div className="space-y-6">
      {/* Operation Type Selection */}
      <div>
        <Body2 className="font-medium mb-2">Operation Type</Body2>
        <Select
          value={node.data?.operation || 'read'}
          onChange={(value) => handleInputChange('operation', value)}
          options={OPERATION_TYPES}
        />
      </div>

      {/* File Upload for Read Operation */}
      {node.data?.operation === 'read' && (
        <div>
          <Body2 className="font-medium mb-2">Upload File</Body2>
          <div className="border-2 border-dashed rounded-lg p-4 text-center hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors">
            <input
              type="file"
              onChange={handleFileUpload}
              className="hidden"
              id={`file-upload-${node.id}`}
            />
            <label
              htmlFor={`file-upload-${node.id}`}
              className="cursor-pointer text-sm text-gray-600 dark:text-gray-300"
            >
              {node.data?.fileName ? (
                <span>Selected: {node.data.fileName}</span>
              ) : (
                <span>Click to upload a file</span>
              )}
            </label>
          </div>
        </div>
      )}

      {/* Filename Input for Write Operation */}
      {node.data?.operation === 'write' && (
        <div>
          <Body2 className="font-medium mb-2">Output Filename</Body2>
          <Input
            value={node.data?.fileName || ''}
            onChange={(e) => handleInputChange('fileName', e.target.value)}
            placeholder="output.txt"
          />
        </div>
      )}

      {/* Content Preview */}
      {node.data?.content && (
        <div>
          <Body2 className="font-medium mb-2">Content Preview</Body2>
          <div className="p-2 bg-gray-50 dark:bg-gray-700 rounded-md text-sm font-mono max-h-32 overflow-auto">
            {typeof node.data.content === 'string' 
              ? node.data.content.substring(0, 200) + (node.data.content.length > 200 ? '...' : '')
              : 'Content is not text'}
          </div>
        </div>
      )}
    </div>
  );
});

FileOpNodeConfig.displayName = 'FileOpNodeConfig';

export default FileOpNodeConfig; 
===========================================
<components/diagram/utility/nodeConfigs/FormatNodeConfig.jsx>
===========================================
import { memo, useCallback, useRef } from 'react';
import { useDiagram } from '../../../../contexts/DiagramContext';
import Select from '../../../common/Select';
import { Body2 } from '../../../common/Typography';
import TreeView from '../../../common/TreeView';
import xml from '../../../../utils/xml';

const FORMAT_TYPES = [
  { value: 'json', label: 'JSON' },
  { value: 'text', label: 'Text' },
  { value: 'xml', label: 'XML' }
];

const FormatNodeConfig = memo(({ node }) => {
  const { updateNodeData } = useDiagram();
  const textareaRef = useRef(null);

  // Get the last input data from lastInput
  const sourceData = node.data?.lastInput;
  
  console.log('FormatNodeConfig - node data:', node.data);
  console.log('FormatNodeConfig - source data:', sourceData);

  const handleInputChange = useCallback((field, value) => {
    updateNodeData(node.id, field, value);
  }, [node.id, updateNodeData]);

  const insertTemplate = (path) => {
    const textarea = textareaRef.current;
    if (!textarea) return;

    // Create the jq template string
    const template = `{{${path}}}`;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = textarea.value;
    const before = text.substring(0, start);
    const after = text.substring(end);

    handleInputChange('template', before + template + after);
    
    // Reset cursor position
    setTimeout(() => {
      textarea.focus();
      const newCursor = start + template.length;
      textarea.setSelectionRange(newCursor, newCursor);
    }, 0);
  };

  const getStructuredData = () => {
    if (!sourceData) {
      console.log('No source data available');
      return null;
    }
    
    try {
      // Process each source node's data
      const processedData = Object.entries(sourceData).reduce((acc, [nodeId, data]) => {
        // If the data contains XML content, parse it
        if (data?.response?.headers?.['content-type']?.includes('xml') && 
            typeof data.response.data === 'string') {
          try {
            const xmlDoc = xml.parse(data.response.data);
            data.response.data = xml.toObject(xmlDoc);
          } catch (e) {
            console.error('Error parsing XML for node', nodeId, e);
          }
        }

        return {
          ...acc,
          [nodeId]: data
        };
      }, {});

      console.log('Processed source data:', processedData);
      return processedData;
    } catch (e) {
      console.error('Error processing source data:', e);
      return sourceData;
    }
  };

  return (
    <div className="space-y-4">
      {/* Format Type Selection */}
      <div>
        <Body2 className="font-medium mb-2">Format Type</Body2>
        <Select
          value={node.data?.formatType || 'json'}
          onChange={(value) => handleInputChange('formatType', value)}
          options={FORMAT_TYPES}
        />
      </div>

      {/* Input Data Preview */}
      <div>
        <Body2 className="font-medium mb-2">
          Source Data Structure
          <span className="text-xs text-slate-500 ml-2">
            (click fields to add to template)
          </span>
        </Body2>
        <div className="bg-slate-100 dark:bg-slate-800 p-3 rounded-md overflow-x-auto max-h-96 overflow-y-auto">
          {getStructuredData() ? (
            <TreeView 
              data={getStructuredData()} 
              onSelect={insertTemplate}
            />
          ) : (
            <div className="text-sm text-slate-500">
              No source data available
            </div>
          )}
        </div>
      </div>

      {/* Template Input */}
      <div>
        <Body2 className="font-medium mb-2">Template</Body2>
        <textarea
          ref={textareaRef}
          value={node.data?.template || ''}
          onChange={(e) => handleInputChange('template', e.target.value)}
          placeholder="Enter your template here, example: {{HTTP_01.response.data}}"
          className="w-full h-48 p-2 font-mono text-sm border rounded-md"
        />
      </div>
    </div>
  );
});

FormatNodeConfig.displayName = 'FormatNodeConfig';

export default FormatNodeConfig;
===========================================
<components/diagram/utility/nodeConfigs/HTTPNodeConfig.jsx>
===========================================
import { memo, useCallback, useEffect, useState, useMemo } from 'react';
import { Plus, X, Play, Info } from 'lucide-react';
import { cn } from '../../../../utils';
import { useDiagram } from '../../../../contexts/DiagramContext';
import Input from '../../../common/Input';
import Select from '../../../common/Select';
import Button from '../../../common/Button';
import { Body2, Caption } from '../../../common/Typography';
import { executeHttpAction } from '../../../../actions';
import FileUpload from '../../../common/FileUpload';
import JQParser from '../../../../utils/jq';
import CodeEditor from '../../../common/CodeEditor';
const jq = new JQParser();

const HTTP_METHODS = [
  { value: 'GET', label: 'GET' },
  { value: 'POST', label: 'POST' },
  { value: 'PUT', label: 'PUT' },
  { value: 'PATCH', label: 'PATCH' },
  { value: 'DELETE', label: 'DELETE' }
];

const CONTENT_TYPES = [
  { value: 'json', label: 'JSON' },
  { value: 'xml', label: 'XML' },
  { value: 'form', label: 'Form' },
  { value: 'text', label: 'Text' },
  { value: 'html', label: 'HTML' },
  { value: 'upload', label: 'Upload' },
];

const CONTENT_TYPE_HEADERS = {
  json: 'application/json',
  xml: 'application/xml',
  form: 'application/x-www-form-urlencoded',
  text: 'text/plain',
  html: 'text/html',
  upload: 'multipart/form-data'
};

const CloseButton = ({ onClick }) => (
  <Button
    variant="text"
    color="red"
    size="sm"
    className="min-w-[32px] hover:bg-semantic-red/10"
    onClick={onClick}
  >
    <X size={16} className="text-semantic-red" />
  </Button>
);

// Check if we're in template mode at cursor position
const isTemplating = (value, position) => {
  if (!position || !value) return false;
  
  // Find the last '{{' before cursor
  const lastOpenBrace = value.lastIndexOf('{{', position);
  if (lastOpenBrace === -1) return false;

  // Find the next '}}' after cursor
  const nextCloseBrace = value.indexOf('}}', position);
  
  // We're in template mode if we found '{{' and either haven't found '}}' or cursor is before it
  return lastOpenBrace !== -1 && (nextCloseBrace === -1 || position <= nextCloseBrace);
};

const EnvironmentVariableRow = memo(({ variable, onUpdate, onDelete }) => {
  const { environment } = useDiagram();
  const [selectedVar, setSelectedVar] = useState(variable.variable || '');
  const [newVarName, setNewVarName] = useState(variable.newVariableName || '');

  // Get existing environment variables for the dropdown
  const envVarOptions = useMemo(() => {
    const existingVars = Object.keys(environment.variables || {}).map(name => ({
      value: name,
      label: name
    }));
    return [
      { value: 'CREATE_NEW', label: 'Create New Variable' },
      ...existingVars
    ];
  }, [environment.variables]);

  return (
    <div className="flex items-center gap-2">
      <Select
        value={selectedVar}
        onChange={(value) => {
          setSelectedVar(value);
          onUpdate({
            ...variable,
            variable: value,
            newVariableName: value === 'CREATE_NEW' ? newVarName : ''
          });
        }}
        options={envVarOptions}
        placeholder="Select variable"
        className="flex-1"
        variant="glass"
        size="sm"
      />
      
      {selectedVar === 'CREATE_NEW' && (
        <Input
          value={newVarName}
          onChange={(e) => {
            setNewVarName(e.target.value);
            onUpdate({
              ...variable,
              variable: selectedVar,
              newVariableName: e.target.value
            });
          }}
          placeholder="New variable name"
          variant="filled"
          className="flex-1"
          size="sm"
        />
      )}
      
      <Input
        value={variable.value || ''}
        onChange={(e) => onUpdate({ ...variable, value: e.target.value })}
        placeholder="Value template"
        variant="filled"
        className="flex-1"
        size="sm"
      />
      
      <Button
        variant="text"
        color="red"
        size="sm"
        onClick={onDelete}
        className="shrink-0"
      >
        <X size={16} />
      </Button>
    </div>
  );
});

const HTTPNodeConfig = memo(({ node }) => {
  const { updateNodeData, lastInput, environment, setEnvironmentVariable } = useDiagram();
  const [testData, setTestData] = useState(null);
  const [activeField, setActiveField] = useState(null);
  const [cursorPosition, setCursorPosition] = useState(null);
  const [lastInputCache, setLastInputCache] = useState(null);

  // Update lastInputCache whenever lastInput changes
  useEffect(() => {
    if (lastInput?.[node.id]) {
      setLastInputCache(lastInput[node.id]);
    }
  }, [lastInput, node.id]);

  // Get input data for this node
  const inputData = useMemo(() => lastInput?.[node.id], [lastInput, node.id]);

  console.log('environment', environment);

  // Format URL with template values
  const formatUrl = useCallback((url, data) => {
    if (!url || !data) return url;
    
    return url.replace(/\{\{(.*?)\}\}/g, (match, path) => {
      try {
        const value = jq.evaluate(path.trim(), data);
        // Handle different types of values
        if (typeof value === 'object') {
          return JSON.stringify(value);
        }
        return value?.toString() || '';
      } catch (error) {
        console.error('Error evaluating template:', error);
        return match;
      }
    });
  }, []);

  // Handle URL change with template processing
  const handleUrlChange = useCallback((value, selectionStart) => {
    setCursorPosition(selectionStart);
    
    if (isTemplating(value, selectionStart)) {
      setActiveField('url');
    } else {
      setActiveField(null);
    }

    updateNodeData(node.id, 'url', value);
  }, [node.id, updateNodeData]);

  // Handle suggestion selection
  const handleSuggestionSelect = useCallback((path, field) => {
    if (!activeField || cursorPosition === null) return;
    
    const currentValue = node.data[field] || '';
    const template = `${path}}}`;  // Only add closing braces
    
    // Find the last '{{' before cursor
    const lastOpenBrace = currentValue.lastIndexOf('{{', cursorPosition);
    
    // Insert the template after the '{{'
    const newValue = currentValue.substring(0, lastOpenBrace + 2) + 
                    template + 
                    currentValue.substring(cursorPosition);

    updateNodeData(node.id, field, newValue);
    setActiveField(null);
  }, [activeField, cursorPosition, node.id, updateNodeData]);

  // Modified input change handler with debug logging
  const handleInputChange = useCallback((field, value, selectionStart) => {

    setCursorPosition(selectionStart);
    
    const templateCheck = isTemplating(value, selectionStart);

    
    if (templateCheck) {

      setActiveField(field);
    } else {
      setActiveField(null);
    }

    updateNodeData(node.id, field, value);
  }, [node.id, updateNodeData, isTemplating]);

  // Modified header change handler
  const handleHeaderChange = useCallback((headerId, field, value, selectionStart) => {
    const headers = [...(node.data?.headers || [])];
    const headerIndex = headers.findIndex(h => (h.id || h.key) === headerId);
    
    if (headerIndex !== -1) {
      if (field === 'value') {
        setCursorPosition(selectionStart);
        const templateCheck = isTemplating(value, selectionStart);
        if (templateCheck) {
          setActiveField(`headers.${headerId}`);
        } else if (value.indexOf('{{', selectionStart) === -1) {
          setActiveField(null);
        }
      }
      
      headers[headerIndex] = { ...headers[headerIndex], [field]: value };
      updateNodeData(node.id, 'headers', headers);
    }
  }, [node.id, node.data?.headers, updateNodeData, isTemplating]);

  const handleMethodChange = useCallback((method) => {
    handleInputChange('method', method);
  }, [handleInputChange, node.data.method]);

  const handleParamChange = useCallback((paramId, field, value) => {
    const newParams = (node.data.params || []).map(param => {
      if (param.id === paramId) {
        return { ...param, [field]: value };
      }
      return param;
    });
    handleInputChange('params', newParams);
  }, [node.data.params, handleInputChange]);

  const handleRemoveHeader = useCallback((headerId) => {
    const headers = [...(node.data?.headers || [])];
    const filteredHeaders = headers.filter(h => (h.id || h.key) !== headerId);
    handleInputChange('headers', filteredHeaders);
  }, [node.data?.headers, handleInputChange]);

  const handleRemoveParam = useCallback((paramId) => {
    const newParams = (node.data.params || []).filter(param => param.id !== paramId);
    handleInputChange('params', newParams);
  }, [node.data.params, handleInputChange]);

  const handleAddParam = useCallback(() => {
    const newParams = [...(node.data.params || []), { id: `param-${Date.now()}`, key: '', value: '' }];
    handleInputChange('params', newParams);
  }, [node.data.params, handleInputChange]);

  const handleAddHeader = useCallback(() => {
    const headers = [...(node.data?.headers || [])];
    headers.push({
      id: `header-${Date.now()}`,
      key: '',
      value: ''
    });
    handleInputChange('headers', headers);
  }, [node.data?.headers, handleInputChange]);

  const handleFormDataChange = useCallback((file) => {
    const newFormData = [...(node.data.formData || []), file];
    handleInputChange('formData', newFormData);
  }, [node.data.formData, handleInputChange]);

  const handleContentTypeChange = (value) => {
    // Get current headers array
    const headers = [...(node.data?.headers || [])];

    // Remove any existing content-type header
    const filteredHeaders = headers.filter(h => h.key.toLowerCase() !== 'content-type');

    // Add new content-type header
    const newHeaders = [
      ...filteredHeaders,
      {
        id: 'content-type-header',  // Use consistent ID for content-type
        key: 'Content-Type',
        value: CONTENT_TYPE_HEADERS[value]
      }
    ];

    updateNodeData(node.id, 'headers', newHeaders);
    updateNodeData(node.id, 'contentType', value);
  };

  const handleTest = async () => {
    setTestData(null); // Clear previous results
    try {
      const result = await executeHttpAction(node.data);
      setTestData(result);
    } catch (error) {
      setTestData({
        success: false,
        error: { message: error.message }
      });
    }
  };

  // Render test results
  const renderTestResults = () => {
    if (!testData) return null;

    return (
      <div className="space-y-4 mt-6 pt-6 border-t">
        <Body2 className="font-medium">Test Results</Body2>
        
        {/* Status */}
        <div className="flex items-center gap-2">
          <div className={cn(
            "w-2 h-2 rounded-full",
            testData.success ? "bg-semantic-green" : "bg-semantic-red"
          )} />
          <Body2>
            Status: {testData.response?.status || 'Error'}
          </Body2>
        </div>

        {/* Error Message */}
        {testData.error && (
          <div className="p-4 bg-semantic-red/10 text-semantic-red rounded-md text-sm">
            {testData.error.message}
          </div>
        )}

        {/* Response Headers */}
        {testData.response?.headers && (
          <div className="space-y-2">
            <Body2 className="font-medium text-sm">Response Headers</Body2>
            <pre className="text-xs p-3 bg-slate-50 dark:bg-slate-800/50 rounded-md overflow-auto max-h-32">
              {JSON.stringify(testData.response.headers, null, 2)}
            </pre>
          </div>
        )}

        {/* Response Data */}
        {testData && (
          <div className="space-y-2">
            <Body2 className="font-medium text-sm">Response Data</Body2>
            <pre className="text-xs p-3 bg-slate-50 dark:bg-slate-800/50 rounded-md overflow-auto max-h-96">
              {typeof testData.response?.data === 'string' 
                ? testData.response.data 
                : JSON.stringify(testData.response?.data, null, 2)}
            </pre>

            <Body2 className="font-medium text-sm">Full Output (sent to next node)</Body2>
            <pre className="text-xs p-3 bg-slate-50 dark:bg-slate-800/50 rounded-md overflow-auto max-h-96">
              {typeof testData === 'string' 
                ? testData 
                : JSON.stringify(testData, null, 2)}
            </pre>

            {/* Debug Info */}
            {1 === 0 && (
              <div className="mt-2 p-2 bg-slate-100 dark:bg-slate-800 rounded text-xs">
                <div>Response Type: {typeof testData}</div>
                <div>Has Response Data: {testData.response?.data ? 'Yes' : 'No'}</div>
                <div>Status: {testData.response?.status}</div>
              </div>
            )}
          </div>
        )}
      </div>
    );
  };

  // Add debug display with more details
  const debugInfo = (
    <div className="p-2 mb-4 bg-slate-100 dark:bg-slate-800 rounded text-xs font-mono space-y-1">
      <div>Node ID: {node.id}</div>
      <div>Type: {node.type}</div>
      <div className="text-xs text-slate-400 mt-1">
        Last updated: {new Date().toLocaleTimeString()}
      </div>
    </div>
  );

  // Update template help section to show nested object example
  const templateHelp = (
    <div className="p-4 bg-slate-100 dark:bg-slate-800 rounded-md mb-4">
      <div className="flex items-center gap-2 mb-2">
        <Info size={16} className="text-semantic-blue" />
        <Body2 className="font-medium">Template Variables</Body2>
      </div>
      <div className="text-sm space-y-2">
        <p>Use <code className="px-1 py-0.5 bg-slate-200 dark:bg-slate-700 rounded">{'{{variableName}}'}</code> to insert values from input data.</p>
        <p>For nested objects, use dot notation: <code className="px-1 py-0.5 bg-slate-200 dark:bg-slate-700 rounded">{'{{data.token}}'}</code></p>
        <p>Examples:</p>
        <ul className="list-disc list-inside space-y-1">
          <li><code className="px-1 py-0.5 bg-slate-200 dark:bg-slate-700 rounded">Bearer {'{{token}}'}</code></li>
          <li><code className="px-1 py-0.5 bg-slate-200 dark:bg-slate-700 rounded">Bearer {'{{data.token}}'}</code></li>
          <li><code className="px-1 py-0.5 bg-slate-200 dark:bg-slate-700 rounded">{'{{user.id}}'}</code></li>
        </ul>
      </div>
    </div>
  );

  // Add CORS warning banner at the top
  const corsWarning = (
    <div className="p-4 mb-4 bg-semantic-yellow/10 border border-semantic-yellow/20 rounded-md">
      <div className="flex items-start gap-2">
        <Info size={16} className="text-semantic-yellow mt-0.5" />
        <div className="text-sm space-y-1">
          <p className="font-medium text-semantic-yellow">CORS Warning</p>
          <p>Some requests may fail due to CORS (Cross-Origin Resource Sharing) restrictions. To resolve this:</p>
          <ul className="list-disc list-inside">
            <li>Enable CORS on your API server</li>
            <li>Use a CORS proxy service</li>
            <li>Add appropriate CORS headers to your server response</li>
          </ul>
        </div>
      </div>
    </div>
  );

  const renderBodyInput = () => {
    const contentType = node.data?.contentType || 'json';

    switch (contentType) {
      case 'upload':
        return (
          <FileUpload
            value={node.data?.body?.file}
            onChange={(file) => {
              updateNodeData(node.id, 'body', {
                file: file,
                filename: file.name,
                type: file.type,
                size: file.size
              });
            }}
            onClear={() => {
              updateNodeData(node.id, 'body', null);
            }}
            maxSize={10 * 1024 * 1024} // 10MB limit
          />
        );
      default:
        return (
          <Body2 className="font-medium">
            <CodeEditor
              value={node.data.body || ''}
              language="json"
              node={node}
              updateField="body"
              placeholder='{"key": "value"}'
            />

            debug: 
            {node.data.body}
          </Body2>
        );
    }
  };

  // Debug output for visibility
  console.log('Render state:', {
    activeField,
    cursorPosition,
    inputData,
    showingSuggestions: Boolean(activeField && inputData)
  });

  // Modified to include "Create New" option
  const envVarOptions = useMemo(() => {
    const existingVars = Object.keys(environment.variables || {}).map(key => ({
      value: key,
      label: key
    }));

    return [
      ...existingVars,
      { value: 'CREATE_NEW', label: '+ Create New', className: 'text-semantic-green' }
    ];
  }, [environment.variables]);

  // Modified handler for environment variable changes
  const handleEnvVarChange = useCallback((varId, field, value, selectionStart) => {
    const envVars = [...(node.data?.environmentVars || [])];
    const varIndex = envVars.findIndex(v => v.id === varId);
    
    if (varIndex !== -1) {
      if (field === 'variable') {
        if (value === 'CREATE_NEW') {
          // Initialize new variable with empty name
          envVars[varIndex] = { 
            ...envVars[varIndex],
            variable: 'CREATE_NEW',
            newVariableName: '' // Store the new name here
          };
        } else {
          // Clear newVariableName when selecting existing variable
          const { newVariableName, ...rest } = envVars[varIndex];
          envVars[varIndex] = { 
            ...rest,
            variable: value 
          };
        }
      } else if (field === 'newVariableName') {
        // Update the new variable name
        envVars[varIndex] = { 
          ...envVars[varIndex],
          newVariableName: value 
        };
      } else {
        // Handle other fields (like 'value')
        envVars[varIndex] = { 
          ...envVars[varIndex], 
          [field]: value 
        };
        
        if (field === 'value' && selectionStart !== undefined) {
          setCursorPosition(selectionStart);
          if (isTemplating(value, selectionStart)) {
            setActiveField(`envVars.${varId}`);
          } else {
            setActiveField(null);
          }
        }
      }
      
      updateNodeData(node.id, 'environmentVars', envVars);
    }
  }, [node.id, updateNodeData, setCursorPosition, setActiveField]);

  // Render variable name input or select based on state
  const renderVariableField = (envVar) => {
    if (envVar.variable === 'CREATE_NEW') {
      return (
        <Input
          value={envVar.newVariableName || ''}
          onChange={(e) => handleEnvVarChange(envVar.id, 'newVariableName', e.target.value)}
          placeholder="New variable name"
          variant="filled"
          size="sm"
          className="flex-1"
        />
      );
    }

    return (
      <Select
        value={envVar.variable}
        onChange={(value) => handleEnvVarChange(envVar.id, 'variable', value)}
        options={envVarOptions}
        placeholder="Select variable"
        variant="glass"
        size="sm"
        className="flex-1"
      />
    );
  };

  // Modified add handler to initialize with empty variable
  const handleAddEnvVar = useCallback(() => {
    const envVars = [...(node.data?.environmentVars || [])];
    envVars.push({
      id: `env-${Date.now()}`,
      variable: '',
      value: ''
    });
    updateNodeData(node.id, 'environmentVars', envVars);
  }, [node.id, node.data?.environmentVars, updateNodeData]);

  const handleDeleteEnvironmentVar = (index) => {
    const newEnvironmentVars = [...(node.data.environmentVars || [])];
    newEnvironmentVars.splice(index, 1);
    updateNodeData(node.id, 'environmentVars', newEnvironmentVars);
  };

  const handleUpdateEnvironmentVar = (index, updatedVar) => {
    const newEnvironmentVars = [...(node.data.environmentVars || [])];
    newEnvironmentVars[index] = updatedVar;
    updateNodeData(node.id, 'environmentVars', newEnvironmentVars);
  };

  return (
    <div className="space-y-6 relative">
      {/* Method & URL */}
      <div className="space-y-4">
        <div className="flex gap-4">
          <div className="w-[150px]">
            <Select
              variant="glass"
              value={node.data.method || 'GET'}
              onChange={handleMethodChange}
              options={HTTP_METHODS}
              size="sm"
            />
          </div>
          <div className="flex-1 relative">
            <Input
              variant="filled"
              size="md"
              fullWidth
              value={node.data.url || ''}
              onChange={(e) => handleUrlChange(e.target.value, e.target.selectionStart)}
              placeholder="https://api.example.com/endpoint"
              showSuggestions={false}
            />
            
          </div>
        </div>
      </div>

      {/* Headers */}
      <div className="space-y-2">
        <div className="flex flex-row items-center justify-between">
          <Body2 className="font-medium flex flex-row items-center justify-center">
            <span>Headers</span>
            <Button variant="light" color="green" circular size="xs" startIcon={<Plus size={16} />} onClick={handleAddHeader} className="ml-2"/>
          </Body2>
        </div>
        
        {node.data?.headers?.map((header) => (
          <div key={header.id} className="flex gap-2">
            <Input
              value={header.key}
              onChange={(e) => handleHeaderChange(header.id, 'key', e.target.value)}
              placeholder="Header name"
              variant="filled"
              size="sm"
              className="flex-1"
            />
            <Input
              value={header.value}
              onChange={(e) => handleHeaderChange(header.id, 'value', e.target.value, e.target.selectionStart)}
              placeholder="Value"
              variant="filled"
              size="sm"
              className="flex-1"
              showSuggestions={activeField === `headers.${header.id}` && inputData}
              suggestions={[]}
              onSuggestionSelect={(path) => handleSuggestionSelect(path, `headers.${header.id}`)}
            />
            <CloseButton onClick={() => handleRemoveHeader(header.id)} />
          </div>
        ))}
      </div>

      {/* Query Parameters */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <Body2 className="font-medium flex flex-row items-center justify-center">
            Query Parameters
            <Button variant="light" color="green" circular size="xs" startIcon={<Plus size={16} />} onClick={handleAddParam} className="ml-2"/>
          </Body2>
        </div>
        
        {(node.data?.params || []).map((param) => (
          <div key={param.id} className="flex gap-2">
            <Input
              value={param.key}
              onChange={(e) => handleParamChange(param.id, 'key', e.target.value)}
              placeholder="Parameter name"
              variant="filled"
              size="sm"
              className="flex-1"
            />
            <Input
              value={param.value}
              onChange={(e) => handleParamChange(param.id, 'value', e.target.value)}
              placeholder="Value"
              variant="filled"
              size="sm"
              className="flex-1"
            />
            <CloseButton onClick={() => handleRemoveParam(param.id)} />
          </div>
        ))}
      </div>

      {/* Body - Only for POST/PUT/PATCH */}
      {['POST', 'PUT', 'PATCH'].includes(node.data.method) && (
        <div className="space-y-2">
          {/* Content Type */}
          <div>
            <Body2>Content Type</Body2>
            <Select
              value={node.data?.contentType || ''}
              onChange={handleContentTypeChange}
              options={CONTENT_TYPES}
              variant="glass"
              size="sm"
            />
          </div>
          {renderBodyInput()}
        </div>
      )}

      {/* Environment Variables Section */}
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <Body2 className="font-medium">Environment Variables</Body2>
          <Button
            variant="light"
            color="green"
            size="sm"
            onClick={handleAddEnvVar}
            startIcon={<Plus size={16} />}
          >
            Add Variable
          </Button>
        </div>
        
        <div className="space-y-2">
          {(node.data.environmentVars || []).map((envVar, index) => (
            <EnvironmentVariableRow
              key={index}
              variable={envVar}
              onUpdate={(updatedVar) => handleUpdateEnvironmentVar(index, updatedVar)}
              onDelete={() => handleDeleteEnvironmentVar(index)}
            />
          ))}
        </div>
      </div>

      {/* Test section */}
      <div className="space-y-2">
        <Button
          color="purple"
          fullWidth={true}
          startIcon={<Play size={16} />}
          onClick={handleTest}
          disabled={!node.data.url}
        >
          Test Request
        </Button>
      </div>
      {/* Test Results */}
      {renderTestResults()}

      {/* Debug Info */}
      {debugInfo}

      {/* Last Input Data Display */}
      {lastInputCache && (
        <div className="space-y-2">
          <Body2 className="font-medium">Last Input Data</Body2>
          <pre className="text-xs bg-slate-100 dark:bg-slate-800 rounded-md p-2 overflow-auto max-h-[200px]">
            {JSON.stringify(lastInputCache, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
});

HTTPNodeConfig.displayName = 'HTTPNodeConfig';

export default HTTPNodeConfig; 
===========================================
<components/diagram/utility/nodeConfigs/IteratorNodeConfig.jsx>
===========================================
import { memo, useState, useEffect, useCallback } from 'react';import { RefreshCw } from 'lucide-react';
import { Body2 } from '../../../common/Typography';
import Input from '../../../common/Input';
import Select from '../../../common/Select';
import { useDiagram } from '../../../../contexts/DiagramContext';

const ITERATOR_MODES = [
  { value: 'input', label: 'Input Iteration' },
  { value: 'custom', label: 'Custom List' }
];

const DELIMITER_OPTIONS = [
  { delimiter: "\n", value: 'newline', label: 'New Line' },
  { delimiter: ',', value: 'comma', label: 'Comma (,)' },
  { delimiter: ';', value: 'semicolon', label: 'Semicolon (;)' },
  { delimiter: '\t', value: 'tab', label: 'Tab' },
  { delimiter: 'custom', value: 'custom', label: 'Custom Delimiter' }
];

const IteratorNodeConfig = memo(({ node }) => {
  const { updateNodeData, lastInput } = useDiagram();
  const [arrayPath, setArrayPath] = useState(node.data?.arrayPath || '');
  const [customList, setCustomList] = useState(node.data?.rawText || '');
  const [previewItems, setPreviewItems] = useState([]);

  // Handle mode changes
  const handleModeChange = useCallback((value) => {
    updateNodeData(node.id, 'mode', value);
    if (value === 'input') {
      // Clear custom list data when switching to input mode
      updateNodeData(node.id, 'outputList', []);
      updateNodeData(node.id, 'rawText', '');
    } else {
      // Restore custom list when switching to custom mode
      const items = customList.split('\n').map(item => item.trim()).filter(Boolean);
      updateNodeData(node.id, 'outputList', items);
      updateNodeData(node.id, 'rawText', customList);
    }
  }, [node.id, customList, updateNodeData]);

  return (
    <div className="space-y-4">
      {/* Mode Selection */}
      <div>
        <Body2 className="font-medium mb-1">Iterator Mode</Body2>
        <Select
          variant="filled"
          value={node.data?.mode}
          onChange={handleModeChange}
          options={ITERATOR_MODES}
          className="mb-2"
        />

        {node.data?.mode === 'input' && (
          <div>
            <Body2 className="font-medium mb-1">Array Path</Body2>
            <Input
              value={arrayPath}
              onChange={(e) => {
                const value = e.target.value;
                setArrayPath(value);
                updateNodeData(node.id, 'arrayPath', value);
              }}
              placeholder="RSS_04.response.items[]"
              helperText="Path to the array in the input data (e.g., RSS_04.response.items[])"
            />
          </div>
        )}
      </div>

      {/* Custom List Mode */}
      {node.data?.mode === 'custom' && (
        <div>
          <Body2 className="font-medium mb-1">Input List</Body2>
          <textarea
            className="w-full p-2 h-32 rounded border border-slate-200 dark:border-slate-700 bg-transparent font-mono text-sm"
            value={customList}
            onChange={(e) => {
              const newValue = e.target.value;
              setCustomList(newValue);
              const items = newValue.split('\n').map(item => item.trim()).filter(Boolean);
              setPreviewItems(items);
              updateNodeData(node.id, 'rawText', newValue);
              updateNodeData(node.id, 'outputList', items);
            }}
            placeholder="Enter items, one per line"
          />
        </div>
      )}

      {/* Preview Items */}
      {previewItems.length > 0 && (
        <div>
          <div className="flex items-center justify-between">
            <Body2 className="font-medium">Items to Iterate</Body2>
            <span className="text-xs text-[var(--foreground)]/60">
              {previewItems.length} items
            </span>
          </div>
          <pre className="mt-1 text-xs bg-slate-100 dark:bg-slate-800 rounded-md p-2 max-h-48 overflow-auto">
            {JSON.stringify(previewItems, null, 2)}
          </pre>
        </div>
      )}

      {/* Current Item Preview */}
      {node.data?.result && (
        <div>
          <Body2 className="font-medium mb-1">Last Iteration Item</Body2>
          <pre className="p-2 bg-slate-100 dark:bg-slate-800 rounded text-sm">
            {JSON.stringify(node.data.result, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
});

IteratorNodeConfig.displayName = 'IteratorNodeConfig';

export default IteratorNodeConfig;
===========================================
<components/diagram/utility/nodeConfigs/ParserNodeConfig.jsx>
===========================================
import { memo, useCallback, useState, useEffect } from 'react';
import { ChevronDown, ChevronRight } from 'lucide-react';
import { useDiagram } from '../../../../contexts/DiagramContext';
import Select from '../../../common/Select';
import Input from '../../../common/Input';
import { Body2 } from '../../../common/Typography';

const PARSER_MODES = [
  { value: 'json', label: 'JSON' },
  { value: 'xml', label: 'XML' },
  { value: 'text', label: 'Plain Text (Coming Soon)', disabled: true }
];

const ParserNodeConfig = memo(({ node }) => {
  const { updateNodeData, lastInput } = useDiagram();
  const [isReferenceExpanded, setIsReferenceExpanded] = useState(false);
  const [lastInputCache, setLastInputCache] = useState(null);

  useEffect(() => {
    if (lastInput?.[node.id]) {
      setLastInputCache(lastInput[node.id]);
    }
  }, [lastInput, node.id]);

  const handleInputChange = useCallback((field, value) => {
    updateNodeData(node.id, field, value);
  }, [node.id, updateNodeData]);

  const handleModeChange = useCallback((mode) => {
    handleInputChange('mode', mode);
    // Set default expression based on mode
    const defaultExpr = mode === 'xml' ? '//root' : 'HTTP_01.response.data';
    handleInputChange('template', defaultExpr);
  }, [handleInputChange]);

  const renderExpressionHelp = () => {
    if (node.data.mode === 'xml') {
      return (
        <div className="text-xs text-[var(--foreground)]/60 space-y-1">
          <p>XPath Examples:</p>
          <ul className="list-disc list-inside">
            <li><code>//book</code> - Get all book elements</li>
            <li><code>//book[@category='fiction']</code> - Get books with category 'fiction'</li>
            <li><code>//book/title</code> - Get all book titles</li>
            <li><code>//book[price&gt;30]/title</code> - Get titles of books over $30</li>
            <li><code>//book[1]</code> - Get the first book</li>
          </ul>
        </div>
      );
    }
  
    return (
      <div className="text-xs text-[var(--foreground)]/60 space-y-2">
        <p>Expression Examples:</p>
        <ul className="list-disc list-inside space-y-1">
          <li><code>HTTP_01.response.data</code> - Get the entire data array</li>
          <li><code>HTTP_01.response.data[].name</code> - Get names from all items</li>
          <li><code>HTTP_01.response.data[0]</code> - Get first item in array</li>
          <li><code>PARSER_01.response.status</code> - Get response status</li>
        </ul>
  
        <button 
          className="flex items-center gap-1 text-semantic-blue hover:underline mt-2"
          onClick={() => setIsReferenceExpanded(!isReferenceExpanded)}
        >
          {isReferenceExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
          Expression Reference
        </button>
  
        {isReferenceExpanded && (
        <div className="max-w-2xl mx-auto p-4 space-y-6">
          <div className="space-y-2">
            <h2 className="text-lg font-semibold">Object Access</h2>
            <div className="bg-slate-100 dark:bg-slate-800 p-3 rounded-md font-mono text-sm">
              <pre>{`HTTP_01.response.data    // Access nested object\nHTTP_01.response.status  // Get single value\nsource.path.to.field    // Deep object traversal`}</pre>
            </div>
          </div>
         
          <div className="space-y-2">
            <h2 className="text-lg font-semibold">Array Operations</h2>
            <div className="bg-slate-100 dark:bg-slate-800 p-3 rounded-md font-mono text-sm">
              <pre>{`data[]                   // Get entire array\ndata[].name             // Get field from each item\ndata[0]                 // Get first array item\ndata[1].field          // Get field from second item`}</pre>
            </div>
          </div>
         
          <div className="space-y-2">
            <h2 className="text-lg font-semibold">Common Patterns</h2>
            <ul className="space-y-1 font-mono text-sm">
              <li><code className="bg-slate-100 dark:bg-slate-800 px-1">HTTP_01.response.data[].id</code> - Extract all IDs</li>
              <li><code className="bg-slate-100 dark:bg-slate-800 px-1">HTTP_01.response.data[0]</code> - First item</li>
              <li><code className="bg-slate-100 dark:bg-slate-800 px-1">HTTP_01.response.headers</code> - Get headers object</li>
              <li><code className="bg-slate-100 dark:bg-slate-800 px-1">PARSER_01.response.data[].email</code> - Get all emails</li>
            </ul>
          </div>
         
          <div className="space-y-2">
            <h2 className="text-lg font-semibold">Response Examples</h2>
            <div className="bg-slate-100 dark:bg-slate-800 p-3 rounded-md font-mono text-sm">
              <pre>{`// Get status code\nHTTP_01.response.status\n\n// Get all user IDs\nHTTP_01.response.data[].id\n\n// Get first user's name\nHTTP_01.response.data[0].name`}</pre>

            </div>
          </div>
        </div>
        )}
      </div>
    );
  };

  return (
    <div className="space-y-6">
     {/* Expression Input */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <Body2 className="font-medium">
            JQ Expression
          </Body2>
          
        </div>
        <Input
          value={node.data.template || ''}
          onChange={(e) => handleInputChange('template', e.target.value)}
          placeholder='HTTP_01.response.data'
          variant="filled"
        />
        {renderExpressionHelp()}
      </div>

      {/* Preview */}
      {node.data.result && (
        <div className="space-y-2">
          <Body2 className="font-medium">Result Preview</Body2>
          <pre className="p-4 bg-slate-100 dark:bg-slate-800 rounded-md overflow-auto max-h-96 text-sm">
            {typeof node.data.result === 'string' 
              ? node.data.result 
              : JSON.stringify(node.data.result, null, 2)
            }
          </pre>
        </div>
      )}

      {/* Error Display */}
      {node.data.error && (
        <div className="p-4 mt-4 text-sm text-semantic-red bg-semantic-red/10 rounded-md">
          {node.data.error}
        </div>
      )}

      {/* Last Input Section */}
      {lastInputCache && (
        <div className="space-y-2">
          <Body2 className="font-medium">Last Input Data</Body2>
          <pre className="text-xs bg-slate-100 dark:bg-slate-800 rounded-md p-2 overflow-auto max-h-[200px]">
            {JSON.stringify(lastInputCache, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
});

ParserNodeConfig.displayName = 'ParserNodeConfig';

export default ParserNodeConfig; 
===========================================
<components/diagram/utility/nodeConfigs/RSSNodeConfig.jsx>
===========================================
import { useState, useEffect } from 'react';
import Input from '../../../common/Input';
import Select from '../../../common/Select';
import { Body2 } from '../../../common/Typography';
import { useDiagram } from '../../../../contexts/DiagramContext';

const RSSNodeConfig = ({ node }) => {
  const { updateNodeData } = useDiagram();

  const handleChange = (field, value) => {
    updateNodeData(node.id, field, value);
  };

  return (
    <div className="space-y-4">
      <div>
        <Body2>Feed URL</Body2>
        <Input
          value={node.data.url || ''}
          onChange={(e) => handleChange('url', e.target.value)}
          placeholder="https://example.com/feed.xml"
        />
      </div>

      <div>
        <Body2>Max Items</Body2>
        <Input
          type="number"
          min={1}
          max={100}
          value={node.data.maxItems || 10}
          onChange={(e) => handleChange('maxItems', Math.max(1, parseInt(e.target.value) || 1))}
        />
      </div>

      <div>
        <Body2>Sort By</Body2>
        <Select
          value={node.data.sortBy || 'published'}
          onChange={(value) => handleChange('sortBy', value)}
          options={[
            { value: 'published', label: 'Published Date' },
            { value: 'created', label: 'Created Date' },
            { value: 'title', label: 'Title' }
          ]}
        />
      </div>

      <div>
        <Body2>Sort Direction</Body2>
        <Select
          value={node.data.sortDirection || 'desc'}
          onChange={(value) => handleChange('sortDirection', value)}
          options={[
            { value: 'desc', label: 'Descending' },
            { value: 'asc', label: 'Ascending' }
          ]}
        />
      </div>
    </div>
  );
};

export default RSSNodeConfig; 
===========================================
<components/diagram/utility/nodeConfigs/TestNodeConfig.jsx>
===========================================
import { memo, useCallback, useState, useMemo, useEffect } from 'react';
import { Plus, X, Info, Check, ChevronDown, ChevronRight } from 'lucide-react';
import { useDiagram } from '../../../../contexts/DiagramContext';
import { Body2 } from '../../../common/Typography';
import Button from '../../../common/Button';
import Input from '../../../common/Input';
import Select from '../../../common/Select';
import Switch from '../../../common/Switch';
import { cn } from '../../../../utils';
import { v4 as uuidv4 } from 'uuid';

const TEST_TYPES = [
  { value: 'status', label: 'Status Code' },
  { value: 'headers', label: 'Headers' },
  { value: 'body', label: 'Response Body' }
];

const OPERATORS = [
  { value: 'equals', label: 'Equals' },
  { value: 'not_equals', label: 'Not Equals' },
  { value: 'contains', label: 'Contains' },
  { value: 'not_contains', label: 'Does Not Contain' },
  { value: 'greater_than', label: 'Greater Than' },
  { value: 'less_than', label: 'Less Than' },
  { value: 'exists', label: 'Exists' },
  { value: 'not_exists', label: 'Does Not Exist' }
];

const TestCaseRow = ({ test, onUpdate, onDelete, index, sourceNodes, nodeId }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const { lastOutput } = useDiagram();
  
  const testResult = useMemo(() => {
    if (!lastOutput || lastOutput.nodeId !== nodeId) return null;
    const results = lastOutput.data?.response?.results || [];
    return results.find(r => r.id === test.id);
  }, [lastOutput, nodeId, test.id]);

  const handleChange = (field, value) => {
    onUpdate(index, { ...test, [field]: value });
  };

  const sourceNodeOptions = sourceNodes.map(node => ({
    value: node.id,
    label: `${node.data?.name || 'Unnamed Node'} (${node.id})`
  }));

  // Get status indicator component
  const StatusIndicator = () => {
    if (!test.sourceNodeId) return null;
    if (!testResult) {
      return <div className="w-4 h-4 rounded-full bg-slate-200 dark:bg-slate-700 shrink-0" title="Not yet run" />;
    }
    const icon = testResult.success ? 
      <Check size={16} className="text-green-500 shrink-0" /> : 
      <X size={16} className="text-red-500 shrink-0" />;
    const text = testResult.success ? "Pass" : "Fail";
    const textColor = testResult.success ? "text-green-500" : "text-red-500";
    
    return (
      <div className="flex items-center gap-1">
        {icon}
        <span className={`text-xs ${textColor}`}>{text}</span>
      </div>
    );
  };

  return (
    <div className="p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg space-y-3">
      {/* Header with name and actions */}
      <div className="flex items-center gap-2">
        <Input
          value={test.name || ''}
          onChange={(e) => handleChange('name', e.target.value)}
          placeholder="Test name"
          variant="solid"
          className="flex-1"
        />
        <StatusIndicator />
        <Button
          variant="text"
          color="red"
          size="sm"
          onClick={() => onDelete(index)}
        >
          <X size={16} />
        </Button>
      </div>

      {/* Source Node Selection */}
      <Select
        value={test.sourceNodeId}
        onChange={(value) => handleChange('sourceNodeId', value)}
        options={sourceNodeOptions}
        placeholder="Select source node"
        className="w-full"
        variant="glass"
        size="sm"
      />

      {/* Test Configuration Section */}
      {test.type === 'status' ? (
        // Status Code Test - Single Row
        <div className="flex gap-2">
          <Select
            value={test.type}
            onChange={(value) => handleChange('type', value)}
            options={TEST_TYPES}
            placeholder="Test type"
            variant="glass"
            size="sm"
            className="w-32"
          />
          <Select
            value={test.operator}
            onChange={(value) => handleChange('operator', value)}
            options={OPERATORS}
            placeholder="Operator"
            variant="glass"
            size="sm"
            className="w-40"
          />
          <Input
            value={test.expected || ''}
            onChange={(e) => handleChange('expected', e.target.value)}
            placeholder="Status code"
            variant="solid"
            className="w-24"
          />
        </div>
      ) : (
        // Headers and Body Tests - Two Rows
        <div className="space-y-2">
          <Select
            value={test.type}
            onChange={(value) => handleChange('type', value)}
            options={TEST_TYPES}
            placeholder="Test type"
            variant="glass"
            size="sm"
            className="w-full"
          />
          <div className="flex gap-2">
            <Input
              value={test.type === 'headers' ? test.header : test.path}
              onChange={(e) => handleChange(test.type === 'headers' ? 'header' : 'path', e.target.value)}
              placeholder={test.type === 'headers' ? 'Header name' : 'JSON path'}
              variant="solid"
              className="flex-1"
            />
            <Select
              value={test.operator}
              onChange={(value) => handleChange('operator', value)}
              options={OPERATORS}
              placeholder="Operator"
              variant="glass"
              size="sm"
              className="w-40"
            />
            {test.operator !== 'exists' && test.operator !== 'not_exists' && (
              <Input
                value={test.expected || ''}
                onChange={(e) => handleChange('expected', e.target.value)}
                placeholder="Expected value"
                variant="solid"
                className="flex-1"
              />
            )}
          </div>
        </div>
      )}

      {/* Stop on Failure Switch */}
      <div className="flex items-center gap-2 pt-2">
        <Switch
          checked={test.stopOnFailure}
          onChange={(e) => handleChange('stopOnFailure', e.target.checked)}
        />
        <Body2>Stop on failure</Body2>
      </div>

      {/* Test Results Section */}
      {test.sourceNodeId && testResult && (
        <>
          <div 
            className="mt-3 pt-3 border-t border-slate-200 dark:border-slate-700 cursor-pointer hover:bg-slate-100 dark:hover:bg-slate-700/50 rounded p-2 flex items-center gap-2"
            onClick={() => setIsExpanded(!isExpanded)}
          >
            {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
            <span className="text-sm text-slate-500">
              {testResult.error ? `Error: ${testResult.error}` : 
               testResult.success ? "Test passed" : "Test failed"}
            </span>
          </div>

          {isExpanded && (
            <div className="mt-2 p-3 bg-slate-100 dark:bg-slate-700/50 rounded-md space-y-2 text-sm">
              {testResult.error ? (
                <div className="text-red-500 text-xs bg-red-100 dark:bg-red-900/30 p-2 rounded">
                  {testResult.error}
                </div>
              ) : (
                <>
                  <div className="flex justify-between items-center">
                    <span className="text-slate-500">Expected:</span>
                    <code className="px-2 py-1 bg-slate-200 dark:bg-slate-800 rounded text-xs">
                      {testResult.expected}
                    </code>
                  </div>
                  <div className="flex justify-between items-center">
                    <span className="text-slate-500">Actual:</span>
                    <code className="px-2 py-1 bg-slate-200 dark:bg-slate-800 rounded text-xs">
                      {testResult.actual}
                    </code>
                  </div>
                  {testResult.message && (
                    <div className="text-xs bg-slate-200 dark:bg-slate-800 p-2 rounded">
                      {testResult.message}
                    </div>
                  )}
                </>
              )}
            </div>
          )}
        </>
      )}
    </div>
  );
};

const TestNodeConfig = memo(({ node }) => {
  const { updateNodeData, nodes, edges, lastOutput, executingNodeIds} = useDiagram();
  const [localTestData, setLocalTestData] = useState(null);

  const isExecuting = executingNodeIds?.has?.(node.id) || false;
  
  // Updated source nodes detection using edges
  const sourceNodes = useMemo(() => {
    // Find all edges that target this node
    const inputEdges = edges.filter(edge => edge.target === node.id);
    
    // Get the source nodes for these edges
    return nodes.filter(n => inputEdges.some(edge => edge.source === n.id));
  }, [nodes, edges, node.id]);

  const testResults = useMemo(() => {
    if (!lastOutput || lastOutput.nodeId !== node.id) return null;
    
    let testData = {
        ...localTestData,
        results: lastOutput.data?.response?.results || [],
        passed: lastOutput.data?.response?.success || false,
    }
    setLocalTestData(testData);
    return testData;
  }, [lastOutput, node.id]);

  const getResultById = (id) => {
    console.log("test results", testResults);
    return testResults?.results?.find(result => result.id === id);
  };

  const handleAddTest = useCallback(() => {
    const tests = [...(node.data.tests || [])];
    const testId = uuidv4(); // Generate a unique ID
    tests.push({
      id: testId,
      name: `Test Case ${tests.length + 1}`,
      type: 'status',
      operator: 'equals',
      expected: '200',
      stopOnFailure: false,
      sourceNodeId: sourceNodes.length === 1 ? sourceNodes[0].id : null // Auto-select if only one source
    });
    updateNodeData(node.id, 'tests', tests);
  }, [node.id, node.data.tests, updateNodeData, sourceNodes]);

  const handleUpdateTest = useCallback((index, updatedTest) => {
    const tests = [...(node.data.tests || [])];
    tests[index] = updatedTest;
    updateNodeData(node.id, 'tests', tests);
  }, [node.id, node.data.tests, updateNodeData]);

  const handleDeleteTest = useCallback((index) => {
    const tests = [...(node.data.tests || [])].filter((_, i) => i !== index);
    updateNodeData(node.id, 'tests', tests);
  }, [node.id, node.data.tests, updateNodeData]);

  const handleSettingChange = useCallback((setting, value) => {
    updateNodeData(node.id, setting, value);
  }, [node.id, updateNodeData]);

  return (
    <div className="space-y-6">
      {/* Settings Section */}
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <Body2 className="font-medium">Test Settings</Body2>
        </div>
        
        <div className="space-y-3 p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg">
          <div className="flex items-center justify-between">
            <Body2>Require all tests to pass</Body2>
            <Switch
              checked={node.data.requireAll}
              onChange={(e) => handleSettingChange('requireAll', e.target.checked)}
            />
          </div>
          
          <div className="flex items-center justify-between">
            <Body2>Continue on failure</Body2>
            <Switch
              checked={node.data.continueOnFailure}
              onChange={(e) => handleSettingChange('continueOnFailure', e.target.checked)}
            />
          </div>

          <div className="space-y-2">
            <Body2>Timeout (ms)</Body2>
            <Input
              type="number"
              value={node.data.timeout || 5000}
              onChange={(e) => handleSettingChange('timeout', parseInt(e.target.value))}
              min={0}
              max={30000}
              variant="solid"
            />
          </div>
        </div>
      </div>

      {/* Test Cases Section */}
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <Body2 className="font-medium">Test Cases</Body2>
          <Button
            variant="light"
            color="green"
            size="sm"
            onClick={handleAddTest}
            startIcon={<Plus size={16} />}
          >
            Add Test Case
          </Button>
        </div>

        <div className="space-y-4">
          {(!node.data.tests || node.data.tests.length === 0) && (
            <div className="text-center p-8 bg-slate-50 dark:bg-slate-800/50 rounded-lg">
              <Body2 className="text-slate-500">No test cases added yet</Body2>
            </div>
          )}

          {(node.data.tests || []).map((test, index) => (
            <TestCaseRow
              key={index}
              test={test}
              index={index}
              onUpdate={handleUpdateTest}
              onDelete={() => handleDeleteTest(index)}
              sourceNodes={sourceNodes}
              nodeId={node.id}
            />
          ))}
        </div>
      </div>

      {/* Help Section */}
      <div className="p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg">
        <div className="flex items-start gap-2">
          <Info size={16} className="text-blue-500 mt-0.5" />
          <div className="space-y-2">
            <Body2 className="font-medium">Using Test Cases</Body2>
            <ul className="text-sm space-y-1 text-slate-600 dark:text-slate-300">
              <li>• Use dot notation for nested body paths (e.g., data.user.name)</li>
              <li>• Headers are case-insensitive</li>
              <li>• Use template variables with {'{{}}'} syntax</li>
              <li>• Status codes can use ranges (e.g., 2xx, {'>='}400)</li>
            </ul>
          </div>
        </div>
      </div>

      {/* Test Results */}
      {node.data.result && (
        <div className="space-y-2">
          <Body2 className="font-medium">Last Test Results</Body2>
          <pre className="p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg text-xs overflow-auto">
            {JSON.stringify(node.data.result, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
});

TestNodeConfig.displayName = 'TestNodeConfig';

export default TestNodeConfig;
===========================================
<components/diagram/utility/nodeConfigs/index.js>
===========================================
import HttpNodeConfig from './HttpNodeConfig';
import FormatNodeConfig from './FormatNodeConfig';
import FileOpNodeConfig from './FileOpNodeConfig';
import ParserNodeConfig from './ParserNodeConfig';
import ConditionalNodeConfig from './ConditionalNodeConfig';

export const nodeConfigs = {
  http: HttpNodeConfig,
  format: FormatNodeConfig,
  fileop: FileOpNodeConfig,
  parser: ParserNodeConfig,
  conditional: ConditionalNodeConfig,
}; 
===========================================
<components/diagram/utility/panels/DebugPanel.jsx>
===========================================
import { memo, useState } from 'react';
import { ChevronDown, ChevronRight, Plus, X } from 'lucide-react';
import { useDiagram } from '../../../../contexts/DiagramContext';
import { Body1, Body2 } from '../../../common/Typography';
import { cn } from '../../../../utils';
import Input from '../../../common/Input';
import Button from '../../../common/Button';

// Properties to exclude from the debug view
const EXCLUDED_PROPS = new Set([
  'selected', 'dragging', 'positionAbsolute', 'width', 'height'
]);

const TreeNode = memo(({ label, value, depth = 0 }) => {
  const [isExpanded, setIsExpanded] = useState(true);  // Default to expanded
  
  // Filter and transform the value if it's a node
  const processValue = (val) => {
    if (typeof val === 'object' && val !== null) {
      const processed = {};
      Object.entries(val).forEach(([key, v]) => {
        if (!EXCLUDED_PROPS.has(key)) {
          processed[key] = v;
        }
      });
      return processed;
    }
    return val;
  };

  // Handle different value types
  if (value === null) return (
    <div style={{ marginLeft: `${depth * 20}px` }} className="text-slate-400">
      {label}: null
    </div>
  );
  
  if (typeof value !== 'object') return (
    <div style={{ marginLeft: `${depth * 20}px` }}>
      {label}: <span className={cn(
        typeof value === 'string' && 'text-green-600 dark:text-green-400',
        typeof value === 'number' && 'text-blue-600 dark:text-blue-400',
        typeof value === 'boolean' && 'text-purple-600 dark:text-purple-400'
      )}>{JSON.stringify(value)}</span>
    </div>
  );
  
  const processedValue = processValue(value);
  
  if (Array.isArray(processedValue)) {
    return (
      <div style={{ marginLeft: `${depth * 20}px` }}>
        <div 
          className="flex items-center gap-1 cursor-pointer hover:text-semantic-blue"
          onClick={() => setIsExpanded(!isExpanded)}
        >
          {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
          {label}: Array({processedValue.length})
        </div>
        {isExpanded && processedValue.map((item, index) => (
          <TreeNode 
            key={index}
            label={`[${index}]`}
            value={item}
            depth={depth + 1}
          />
        ))}
      </div>
    );
  }
  
  return (
    <div style={{ marginLeft: `${depth * 20}px` }}>
      <div 
        className="flex items-center gap-1 cursor-pointer hover:text-semantic-blue"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
        {label}: Object
      </div>
      {isExpanded && Object.entries(processedValue).map(([key, val]) => (
        <TreeNode 
          key={key}
          label={key}
          value={val}
          depth={depth + 1}
        />
      ))}
    </div>
  );
});

const EnvironmentVariableRow = memo(({ name, value, onChange, onDelete }) => {
  return (
    <div className="flex items-center gap-2 mb-2">
      <Input
        value={name}
        onChange={(e) => onChange('name', e.target.value)}
        placeholder="Variable name"
        variant="filled"
        className="flex-1"
      />
      <Input
        value={value}
        onChange={(e) => onChange('value', e.target.value)}
        placeholder="Value"
        variant="filled"
        className="flex-1"
      />
      <Button
        variant="text"
        color="red"
        size="sm"
        onClick={onDelete}
        className="shrink-0"
      >
        <X size={16} />
      </Button>
    </div>
  );
});

const DebugPanel = memo(() => {
  const { nodes, edges, environment, setEnvironmentVariable } = useDiagram();
  const [variables, setVariables] = useState(
    Object.entries(environment.variables || {}).map(([name, value]) => ({ name, value }))
  );

  const handleVariableChange = (index, field, value) => {
    const newVariables = [...variables];
    const variable = newVariables[index];
    
    // If changing name, we need to delete old variable and add new one
    if (field === 'name' && variable.name) {
      setEnvironmentVariable(variable.name, undefined); // Delete old variable
    }
    
    // Update the variable in our state
    newVariables[index] = { ...variable, [field]: value };
    setVariables(newVariables);
    
    // Update the environment if we have both name and value
    if (newVariables[index].name && newVariables[index].value !== undefined) {
      setEnvironmentVariable(newVariables[index].name, newVariables[index].value);
    }
  };

  const handleAddVariable = () => {
    setVariables([...variables, { name: '', value: '' }]);
  };

  const handleDeleteVariable = (index) => {
    const variable = variables[index];
    if (variable.name) {
      setEnvironmentVariable(variable.name, undefined); // Delete from environment
    }
    const newVariables = variables.filter((_, i) => i !== index);
    setVariables(newVariables);
  };

  return (
    <div className="space-y-4">
      <Body1 className="font-medium">Debug Panel</Body1>
      
      {/* Flow Structure Section */}
      <div className="space-y-4 p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg text-sm font-mono h-[40vh] overflow-y-auto">
        <Body2 className="font-medium mb-2 border-b border-slate-200 dark:border-slate-700 pb-2">
          Flow Structure
        </Body2>
        <div>
          <div className="space-y-1">
            <TreeNode label="nodes" value={nodes} />
            <TreeNode label="edges" value={edges} />
          </div>
        </div>
      </div>

      {/* Environment Variables Section */}
      <div className="space-y-4 p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg text-sm h-[40vh] overflow-y-auto">
        <div className="flex items-center justify-between border-b border-slate-200 dark:border-slate-700 pb-2">
          <Body2 className="font-medium">Environment Variables</Body2>
          <Button
            variant="light"
            color="green"
            size="sm"
            onClick={handleAddVariable}
            startIcon={<Plus size={16} />}
          >
            Add Variable
          </Button>
        </div>
        <div className="space-y-2">
          {variables.map((variable, index) => (
            <EnvironmentVariableRow
              key={index}
              name={variable.name}
              value={variable.value}
              onChange={(field, value) => handleVariableChange(index, field, value)}
              onDelete={() => handleDeleteVariable(index)}
            />
          ))}
          {variables.length === 0 && (
            <div className="text-center p-4 text-slate-500">
              No environment variables set
            </div>
          )}
        </div>
      </div>
    </div>
  );
});

DebugPanel.displayName = 'DebugPanel';
EnvironmentVariableRow.displayName = 'EnvironmentVariableRow';

export default DebugPanel; 
===========================================
<components/diagram/utility/panels/LogsPanel.jsx>
===========================================
import { memo } from 'react';
import { FileText } from 'lucide-react';
import { useLogger } from '../../../../contexts/LoggerContext';
import Button from '../../../common/Button';
import { Body1, Body2, Caption } from '../../../common/Typography';
import Typography from '../../../common/Typography';
import { useState } from 'react';
import { ChevronDown, ChevronUp } from 'lucide-react';
import moment from 'moment';

const LogsPanel = memo(() => {
  const { logs, clearLogs } = useLogger();
  const [expandedLogs, setExpandedLogs] = useState({});

  if (logs.length === 0) {
    return (
      <div className="h-full flex flex-col items-center justify-center p-8 text-center">
        <FileText size={32} className="text-slate-400 mb-4" />
        <Body1 className="font-medium mb-2">No logs yet</Body1>
        <Body2 className="text-slate-500 mb-6">
          Execute the workflow to see data at specific points during execution.
        </Body2>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      <div className="flex items-center justify-between p-4 border-b border-slate-200 dark:border-slate-700">
        <Body1 className="font-medium">Execution Logs</Body1>
        <Button variant="light" color="red" size="sm" onClick={clearLogs}>
          Clear
        </Button>
      </div>

      <div className="flex-1 overflow-auto flex flex-col w-full">
        {logs.map((log) => {
          const iterationLabel = log.iteration 
            ? `Iteration ${log.iteration.current}/${log.iteration.total}`
            : '';

          return (
            <div
              key={log.id}
              className="p-4 border-b border-slate-200 dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-800/50"
            >
              <div className="flex items-center justify-between mb-2">
                <div className="w-full">
                  <Body2 className="font-medium flex items-center gap-2">
                    <span>Execution @ {moment(log.timestamp).format('HH:mm:ss')}</span>
                    {iterationLabel && (
                      <span className="text-xs px-2 py-1 bg-slate-200 dark:bg-slate-700 rounded">
                        {iterationLabel}
                      </span>
                    )}
                    <Typography variant="caption" color="green">
                      {log.type} {log.name}
                    </Typography>
                  </Body2>

                  {log.sources && (
                    <Caption className="text-slate-500">
                      Source{log.sourceIds?.length > 1 ? 's' : ''}: {log.sources}
                    </Caption>
                  )}

                  {log.sourceData && Object.entries(log.sourceData).map(([source, data]) => (
                    <div key={source} className="mt-2">
                      <Caption className="text-slate-600 font-medium">
                        Data from {source}:
                      </Caption>
                      <pre className="text-xs p-3 bg-slate-500 text-slate-100 dark:bg-slate-800 rounded-md overflow-auto max-h-96 mt-1">
                        {JSON.stringify(data, null, 2)}
                      </pre>
                    </div>
                  ))}

                  {/* Output Data */}
                  {log.data && (
                    <div className="mt-2">
                      <Caption className="text-slate-600 font-medium">
                        Output:
                      </Caption>
                      <pre className="text-xs p-3 bg-slate-500 text-slate-100 dark:bg-slate-800 rounded-md overflow-auto max-h-96 mt-1">
                        {JSON.stringify(log.data, null, 2)}
                      </pre>
                    </div>
                  )}
                </div>
              </div>

              {/* Debug Info */}
              <div className="flex-col items-center justify-between mb-2">
                <div className="w-full">
                  <button
                    className="w-full text-left text-xs p-2 hover:bg-slate-200 dark:hover:bg-slate-800 rounded-md transition-colors"
                    onClick={() => setExpandedLogs(prev => ({
                      ...prev,
                      [log.id]: !prev[log.id]
                    }))}
                  >
                    <span className="flex items-center gap-2">
                      Debug Data {expandedLogs[log.id] ? <ChevronUp size={16} /> : <ChevronDown size={16} />}
                    </span>
                  </button>
                </div>

                {expandedLogs[log.id] && (
                  <div className="w-full">
                    <pre className="text-xs text-green-300 p-3 bg-slate-600 dark:bg-slate-900 rounded-md overflow-y-auto overflow-x-hidden max-h-96 mt-1">
                      {JSON.stringify({
                        ...log,
                        data: undefined,
                        sourceData: undefined
                      }, null, 2)}
                    </pre>
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
});

LogsPanel.displayName = 'LogsPanel';

export default LogsPanel; 
===========================================
<components/diagram/utility/panels/NodeInfo.jsx>
===========================================
import { memo, useEffect, useState } from 'react';
import { cn } from '../../../../utils';
import { useTheme } from '../../../../contexts/ThemeContext';
import { NODE_TYPES } from '../../../../constants/nodeTypes';
import { Body1, Body2 } from '../../../common/Typography';
import { useDiagram } from '../../../../contexts/DiagramContext';
import { Info, Loader } from 'lucide-react';

const NodeInfo = memo(({ node }) => {
  if (!node) node = {};
  const { isDark } = useTheme(); 
  const { updateNodeData } = useDiagram();
  const nodeType = NODE_TYPES[node.type];
  const [fakeLoading, setFakeLoading] = useState(false)

  const handleNameChange = (e) => {
    updateNodeData(node.id, 'name', e.target.value);
  };

  if (!nodeType) {

    return (
      <div className="p-4 text-center text-slate-400">
        <Body2>
          {node.type ? 'No valid node selected' : 'No node selected'}
        </Body2>
      </div>
    );
  }

  const ConfigComponent = nodeType.config;

  return (
    <div className="space-y-4">
      {/* Node Header Info */}
      <div className="pb-4 border-b border-slate-200 dark:border-slate-700">
        <div className="flex items-center gap-2">
          {nodeType.icon && (
            <nodeType.icon 
              size={20} 
              className={`text-semantic-${nodeType.color}`}
            />
          )}
          <Body1 className="font-semibold">
            {nodeType.label} Node
          </Body1>
        </div>
        <div className="text-slate-500">
          <Body2>ID: {node.id}</Body2>
        </div>
        <div className="mt-2">
          <input
            type="text"
            className={cn(
              "w-full px-2 py-1",
              "bg-transparent",
              "border border-slate-200 dark:border-slate-700",
              "rounded",
              "text-sm",
              "focus:outline-none focus:ring-1",
              `focus:ring-semantic-${nodeType.color}`,
              "placeholder:text-slate-400"
            )}
            value={node.data?.name || ''}
            onChange={handleNameChange}
            placeholder={"Enter a name (optional)"}
          />
        </div>
      </div>

      {/* Node Description */}
      <div className="px-1">
        <Body2 className="text-slate-500">{nodeType.description}</Body2>
      </div>

      {/* Node Configuration */}
      <div className="space-y-4">
        {ConfigComponent ? (
          <ConfigComponent node={node} />
        ) : (
          <div className="text-center text-slate-400 mt-4">
            <Body2>Configuration not available for this node type</Body2>
          </div>
        )}
      </div>
    </div>
  );
});

NodeInfo.displayName = 'NodeInfo';
NodeInfo.info = {
  label: 'Node Info',
  icon: Info,
  description: 'View information about the selected node',
  color: 'purple',
}

export default NodeInfo; 
===========================================
<components/layout/Layout.jsx>
===========================================
import { useState } from 'react';
import { Outlet, useLocation, useNavigate } from 'react-router-dom';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import Navbar from '../common/Navbar';
import Sidebar from '../common/Sidebar';
import Box from '../common/Box';
import IconButton from '../common/IconButton';
import SidebarItem from '../common/SidebarItem';
import {
  Home,
  Waves,
  Settings
} from 'lucide-react';

const Layout = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const [sidebarExpanded, setSidebarExpanded] = useState(true);

  const navigationItems = [
    {
      icon: <Home className="w-5 h-5" />,
      text: 'Dashboard',
      path: '/',
    },
    {
      icon: <Waves className="w-5 h-5" />,
      text: 'Flows',
      path: '/flows',
    },
    {
      icon: <Settings className="w-5 h-5" />,
      text: 'Settings',
      path: '/settings',
    },
  ];

  return (
    <div className="relative flex h-[calc(100vh-40px)] overflow-hidden text-dark-text bg-white dark:bg-slate-900">
      {/* Sidebar with darker background */}
      <Sidebar>
        {navigationItems.map((item) => (
          <SidebarItem
            showToggle={true}
            key={item.path}
            icon={item.icon}
            text={item.text}
            active={location.pathname === item.path}
            onClick={() => navigate(item.path)}
          />
        ))}
      </Sidebar>

      {/* Main Content Area */}
      <div className="flex-1 flex flex-col min-w-0" id="main-content">
        {/* Page Content */}
        <Box
          id="page-content"
          className={`
            flex-1
            transition-all
            duration-300
            border-none
            ${sidebarExpanded ? 'ml-0' : '-ml-[200px]'}
          `.trim()}
        >
          <div className="w-full" id="page-content-inner">
            <Outlet />
          </div>
        </Box>
      </div>
    </div>
  );
};

export default Layout; 
===========================================
<components/logical/TreeSuggest.js>
===========================================
const generatePathSuggestions = (data) => {
  const paths = [];
  
  const traverse = (obj, path = '') => {
    if (!obj || typeof obj !== 'object') return;
    
    Object.entries(obj).forEach(([key, value]) => {
      const currentPath = path ? `${path}.${key}` : key;
      paths.push(currentPath);
      
      // Handle arrays
      if (Array.isArray(value)) {
        // Add array notation
        paths.push(`${currentPath}[]`);
        
        // Sample first item for array structure
        if (value.length > 0 && typeof value[0] === 'object') {
          traverse(value[0], `${currentPath}[]`);
        }
        
        // Add direct index access for small arrays
        if (value.length <= 5) {
          value.forEach((_, index) => {
            paths.push(`${currentPath}[${index}]`);
          });
        }
      }
      // Recurse into nested objects
      else if (value && typeof value === 'object') {
        traverse(value, currentPath);
      }
    });
  };
  
  traverse(data);
  return paths;
};

export default generatePathSuggestions; 
===========================================
<components/settings/DatabaseConnectionForm.jsx>
===========================================
import { useState, memo, useEffect } from 'react';
import { Body2, Caption } from '../common/Typography';
import Button from '../common/Button';
import Input from '../common/Input';

const DATABASE_TYPES = {
  POSTGRES: 'postgres',
  MYSQL: 'mysql',
  SQLITE: 'sqlite'
};

const DATABASE_CONFIGS = {
  [DATABASE_TYPES.POSTGRES]: {
    name: 'PostgreSQL',
    fields: ['host', 'port', 'database', 'username', 'password', 'ssl'],
    defaults: {
      port: '5432',
      host: 'localhost'
    }
  },
  [DATABASE_TYPES.MYSQL]: {
    name: 'MySQL',
    fields: ['host', 'port', 'database', 'username', 'password', 'ssl'],
    defaults: {
      port: '3306',
      host: 'localhost'
    }
  },
  [DATABASE_TYPES.SQLITE]: {
    name: 'SQLite',
    fields: ['file'],
    defaults: {
      file: ''
    }
  }
};

const DatabaseConnectionForm = memo(({ onSubmit, onCancel, initialData = null }) => {
  const [dbType, setDbType] = useState(initialData?.type || '');
  const [sqliteMode, setSqliteMode] = useState('existing');
  const [formData, setFormData] = useState({
    name: initialData?.name || '',
    ...initialData?.config || {}
  });
  const [testStatus, setTestStatus] = useState(null);
  const [isSaving, setIsSaving] = useState(false);

  // Add useEffect to log state changes
  useEffect(() => {
    console.log('Current state:', {
      dbType,
      formData,
      sqliteMode
    });
  }, [dbType, formData, sqliteMode]);

  const handleTypeSelect = (type) => {
    console.log('Setting database type to:', type);
    setDbType(type);
    setFormData(prev => ({
      name: prev.name,
      ...DATABASE_CONFIGS[type].defaults
    }));
  };

  const handleInputChange = (field, value) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  const handleTestConnection = async () => {
    setTestStatus('testing');
    try {
      // Ensure we have the required fields
      if (!dbType) {
        throw new Error('Database type is required');
      }

      if (dbType === 'sqlite' && !formData.file) {
        throw new Error('Database file is required');
      }

      // Create test config
      const testConfig = {
        type: dbType,
        ...(dbType === 'sqlite' 
          ? { file: formData.file }
          : {
              host: formData.host,
              port: formData.port,
              database: formData.database,
              username: formData.username,
              password: formData.password,
              ssl: formData.ssl
            })
      };

      console.log('Sending test config:', {
        ...testConfig,
        password: testConfig.password ? '[REDACTED]' : undefined
      });

      // Use the storage.testConnection method directly
      const result = await window.api.storage.testConnection(testConfig);
      
      console.log('Test connection result:', result);
      
      setTestStatus(result.success ? 'success' : 'error');
      if (!result.success) {
        throw new Error(result.error || 'Connection test failed');
      }
    } catch (error) {
      console.error('Connection test failed:', error);
      setTestStatus('error');
    }
  };

  const handleSqliteFileSelect = async () => {
    try {
      const options = {
        filters: [{ name: 'SQLite Database', extensions: ['db', 'sqlite', 'sqlite3'] }]
      };

      if (sqliteMode === 'new') {
        const result = await window.api.invoke('dialog.save-file', {
          ...options,
          title: 'Create New SQLite Database',
          defaultPath: 'database.db'
        });
        if (result.success) {
          handleInputChange('file', result.filePath);
        }
      } else {
        const result = await window.api.invoke('dialog.open-file', {
          ...options,
          title: 'Select Existing SQLite Database'
        });
        if (result.success) {
          handleInputChange('file', result.filePath);
        }
      }
    } catch (error) {
      console.error('Failed to select SQLite file:', error);
    }
  };

  const handleSubmit = async () => {
    if (!formData.name?.trim()) {
      return;
    }

    setIsSaving(true);
    try {
      // Prepare connection data
      const connectionData = {
        id: initialData?.id,
        name: formData.name.trim(),
        type: dbType,
        config: {}
      };

      // Add appropriate config based on database type
      if (dbType === 'sqlite') {
        connectionData.config = {
          file: formData.file
        };
      } else {
        // For MySQL and PostgreSQL
        connectionData.config = {
          host: formData.host,
          port: formData.port,
          database: formData.database,
          username: formData.username,
          password: formData.password,
          ssl: formData.ssl
        };
      }

      console.log('Submitting connection:', {
        ...connectionData,
        config: {
          ...connectionData.config,
          password: connectionData.config.password ? '[REDACTED]' : undefined
        }
      });

      // Use invoke directly instead of through the API context
      const result = await window.api.invoke('storage.save-connection', connectionData);

      if (!result.success) {
        throw new Error(result.error || 'Failed to save connection');
      }

      if (onSubmit) {
        await onSubmit(result);
      }
    } catch (error) {
      console.error('Failed to save connection:', error);
    } finally {
      setIsSaving(false);
    }
  };

  if (!dbType) {
    return (
      <div className="space-y-4">
        <Body2 className="font-medium">Select Database Type</Body2>
        <div className="grid grid-cols-3 gap-4">
          {Object.entries(DATABASE_CONFIGS).map(([type, config]) => (
            <button
              key={type}
              onClick={() => handleTypeSelect(type)}
              className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg hover:border-purple-500 dark:hover:border-purple-400 transition-colors"
            >
              <Body2 className="font-medium">{config.name}</Body2>
              <Caption className="text-slate-500">Click to configure</Caption>
            </button>
          ))}
        </div>
      </div>
    );
  }

  const config = DATABASE_CONFIGS[dbType];

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <Body2 className="font-medium">{config.name} Connection</Body2>
        <Button variant="light" onClick={() => setDbType('')}>
          Change Type
        </Button>
      </div>

      {/* SQLite Mode Toggle */}
      {dbType === DATABASE_TYPES.SQLITE && (
        <div className="flex items-center gap-2 p-2 bg-slate-100 dark:bg-slate-800 rounded-lg">
          <button
            onClick={() => setSqliteMode('existing')}
            className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors ${
              sqliteMode === 'existing'
                ? 'bg-white dark:bg-slate-700 shadow-sm'
                : 'text-slate-600 dark:text-slate-400 hover:text-slate-900 dark:hover:text-slate-100'
            }`}
          >
            Existing Database
          </button>
          <button
            onClick={() => setSqliteMode('new')}
            className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors ${
              sqliteMode === 'new'
                ? 'bg-white dark:bg-slate-700 shadow-sm'
                : 'text-slate-600 dark:text-slate-400 hover:text-slate-900 dark:hover:text-slate-100'
            }`}
          >
            New Database
          </button>
        </div>
      )}

      <div className="space-y-4">
        {/* Connection Name field */}
        <Input
          label="Connection Name"
          value={formData.name || ''}
          onChange={(e) => handleInputChange('name', e.target.value)}
          placeholder="Enter a name for this connection"
          required
        />

        {/* Database-specific fields */}
        {config.fields.map(field => (
          <div key={field}>
            {field === 'file' && dbType === DATABASE_TYPES.SQLITE ? (
              <div className="space-y-2">
                <Input
                  label="Database File"
                  value={formData[field] || ''}
                  onChange={(e) => handleInputChange(field, e.target.value)}
                  placeholder={sqliteMode === 'new' ? 'Choose location for new database' : 'Select existing database file'}
                  readOnly
                />
                <Button
                  variant="light"
                  onClick={handleSqliteFileSelect}
                  className="w-full"
                >
                  {sqliteMode === 'new' ? 'Choose Location' : 'Select File'}
                </Button>
              </div>
            ) : (
              <Input
                label={field.charAt(0).toUpperCase() + field.slice(1)}
                type={field === 'password' ? 'password' : 'text'}
                value={formData[field] || ''}
                onChange={(e) => handleInputChange(field, e.target.value)}
                placeholder={`Enter ${field}`}
              />
            )}
          </div>
        ))}
      </div>

      <div className="flex items-center gap-4">
        <Button
          color="purple"
          onClick={handleTestConnection}
          disabled={testStatus === 'testing'}
        >
          {testStatus === 'testing' ? 'Testing...' : 'Test Connection'}
        </Button>
        {testStatus && (
          <Caption
            className={
              testStatus === 'success'
                ? 'text-green-500'
                : testStatus === 'error'
                ? 'text-red-500'
                : ''
            }
          >
            {testStatus === 'success'
              ? 'Connection successful!'
              : testStatus === 'error'
              ? 'Connection failed'
              : ''}
          </Caption>
        )}
      </div>

      <div className="flex items-center gap-4">
        <Button 
          color="purple" 
          onClick={handleSubmit}
          disabled={isSaving || !formData.name.trim()}
        >
          {isSaving ? 'Saving...' : 'Save Connection'}
        </Button>
        <Button variant="light" onClick={onCancel}>
          Cancel
        </Button>
      </div>
    </div>
  );
});

export default DatabaseConnectionForm; 
===========================================
<constants/nodeTypes.js>
===========================================
import { 
  ArrowUpDown, 
  Code, 
  FileCog, 
  FileJson, 
  GitBranch, 
  RefreshCw, 
  MessageSquare, 
  TestTube,
  Database,
  Terminal,
  Rss
} from 'lucide-react';

// First import all node configs
import HTTPNodeConfig from '../components/diagram/utility/nodeConfigs/HTTPNodeConfig';
import FormatNodeConfig from '../components/diagram/utility/nodeConfigs/FormatNodeConfig';
import FileOpNodeConfig from '../components/diagram/utility/nodeConfigs/FileOpNodeConfig';
import ParserNodeConfig from '../components/diagram/utility/nodeConfigs/ParserNodeConfig';
import ConditionalNodeConfig from '../components/diagram/utility/nodeConfigs/ConditionalNodeConfig';
import IteratorNodeConfig from '../components/diagram/utility/nodeConfigs/IteratorNodeConfig';
import TestNodeConfig from '../components/diagram/utility/nodeConfigs/TestNodeConfig';
import DatabaseQueryNodeConfig from '../components/diagram/utility/nodeConfigs/DatabaseQueryNodeConfig';
import CommandNodeConfig from '../components/diagram/utility/nodeConfigs/CommandNodeConfig';
// Then import all node components
import HTTPNode from '../components/diagram/nodes/HTTPNode';
import FormatNode from '../components/diagram/nodes/FormatNode';
import FileOpNode from '../components/diagram/nodes/FileOpNode';
import ParserNode from '../components/diagram/nodes/ParserNode';
import ConditionalNode from '../components/diagram/nodes/ConditionalNode';
import IteratorNode from '../components/diagram/nodes/IteratorNode';
import PromptNode from '../components/diagram/nodes/PromptNode';
import LoggerNode from '../components/diagram/nodes/LoggerNode';
import TestNode from '../components/diagram/nodes/TestNode';
import DatabaseQueryNode from '../components/diagram/nodes/DatabaseQueryNode';
import CommandNode from '../components/diagram/nodes/CommandNode';
import RSSNode from '../components/diagram/nodes/RSSNode';
import RSSNodeConfig from '../components/diagram/utility/nodeConfigs/RSSNodeConfig';

export const NODE_CATEGORIES = {
  input: {
    label: 'Input/Output',
    color: 'orange'
  },
  transform: {
    label: 'Transform',
    color: 'purple'
  },
  flow: {
    label: 'Flow Control',
    color: 'yellow'
  },
  ai: {
    label: 'AI',
    color: 'red'
  },
  utility: {
    label: 'Utility',
    color: 'blue'
  },
  testing: {
    label: 'Testing',
    color: 'green'
  }
};

export const NODE_TYPES = {
  test: {
    type: 'test',
    label: 'Test Case',
    description: 'Validate response data against test conditions',
    category: 'testing',
    icon: TestTube,
    component: TestNode,
    config: TestNodeConfig,
    defaultData: {
      name: 'Test Case',
      tests: [],
      requireAll: true,
      continueOnFailure: false,
      timeout: 5000
    },
  },
  http: {
    type: 'http',
    label: 'HTTP Request',
    description: 'Make HTTP requests to external APIs',
    category: 'input',
    icon: ArrowUpDown,
    component: HTTPNode,
    config: HTTPNodeConfig,
    defaultData: {
      name: 'HTTP Request',
      method: 'GET',
      url: '',
      headers: [
        { id: 'default-content-type', key: 'Content-Type', value: 'application/json' }
      ],
      contentType: 'json',
      body: null
    },
  },
  format: {
    type: 'format',
    label: 'Format',
    description: 'Format and transform data using templates',
    category: 'transform',
    icon: Code,
    component: FormatNode,
    config: FormatNodeConfig,
    defaultData: {
      name: 'Format',
      template: '',
    },
  },
  fileop: {
    type: 'fileop',
    label: 'File Operation',
    description: 'Read from or write to files',
    category: 'input',
    icon: FileCog,
    component: FileOpNode,
    config: FileOpNodeConfig,
    defaultData: {
      name: 'File Operation',
      operation: 'read',
      path: '',
    },
  },
  parser: {
    type: 'parser',
    label: 'Parser',
    description: 'Parse data using JQ expressions (currently JSON only)',
    category: 'transform',
    icon: FileJson,
    component: ParserNode,
    config: ParserNodeConfig,
    defaultData: {
      name: 'Parser',
      format: 'json',
    },
  },
  conditional: {
    type: 'conditional',
    label: 'Conditional',
    description: 'Branch flow based on conditions',
    category: 'flow',
    icon: GitBranch,
    component: ConditionalNode,
    config: ConditionalNodeConfig,
    defaultData: {
      name: 'Conditional',
      conditions: [],
    },
  },
  iterator: {
    type: 'iterator',
    label: 'Iterator',
    description: 'Iterate through array or list items',
    category: 'flow',
    icon: RefreshCw,
    component: IteratorNode,
    config: IteratorNodeConfig,
    defaultData: {
      name: 'Iterator',
      inputType: 'json',
      testInput: '',
    },
  },
  prompt: {
    type: 'prompt',
    label: 'Prompt',
    description: 'Use an AI prompt to generate text',
    category: 'ai',
    icon: MessageSquare,
    component: PromptNode,
  },
  databaseQuery: {
    type: 'databaseQuery',
    label: 'Database Query',
    description: 'Execute SQL queries against a database',
    category: 'input',
    icon: Database,
    component: DatabaseQueryNode,
    config: DatabaseQueryNodeConfig,
    defaultData: {
      name: 'Database Query',
      query: 'SELECT * FROM table_name',
      parameters: [],
      timeout: 30000,
    },
  },
  command: {
    type: 'command',
    label: 'Command',
    description: 'Execute system commands',
    icon: Terminal,
    component: CommandNode,
    config: CommandNodeConfig,
    defaultData: {
      name: 'Command',
      command: '',
    },
    category: 'input'
  },
  rss: {
    type: 'rss',
    label: 'RSS Feed',
    description: 'Fetch and parse RSS/ATOM feeds',
    category: 'input',
    icon: Rss,
    component: RSSNode,
    config: RSSNodeConfig,
    defaultData: {
      name: 'RSS Feed',
      url: '',
      timeout: 30000,
      maxItems: 10,
      sortBy: 'published',
      sortDirection: 'desc'
    },
  },
};

// Helper functions at the end
export const getNodeTypes = () => {
  return Object.fromEntries(
    Object.entries(NODE_TYPES).map(([key, value]) => [key, value.component])
  );
};

export const paletteItems = Object.values(NODE_TYPES)
  .sort((a, b) => a.type.localeCompare(b.type))
  .map(node => ({
    type: node.type,
    label: node.label,
    description: node.description,
    color: node.color,
    icon: node.icon,
  }));

export const getDefaultData = (type) => {
  return NODE_TYPES[type]?.defaultData || {};
};

export const getNodeColor = (type) => {
  const category = NODE_TYPES[type]?.category;
  return NODE_CATEGORIES[category]?.color || 'gray';
};
===========================================
<contexts/ApiContext.jsx>
===========================================
import React, { createContext, useContext, useCallback } from 'react';

const ApiContext = createContext(null);

export function ApiProvider({ children }) {
  // Nodes API
  const executeCommand = useCallback(async (command, options) => {
    return await window.api.invoke('nodes.command.execute', command, options);
  }, []);

  const saveFile = useCallback(async (path, content) => {
    return await window.api.invoke('nodes.file.save', path, content);
  }, []);

  const openFile = useCallback(async (path) => {
    return await window.api.invoke('nodes.file.open', path);
  }, []);

  // Storage API for flows
  const saveFlow = useCallback(async (flowData) => {
    return await window.api.invoke('storage.save-flow', flowData);
  }, []);

  const openFlow = useCallback(async (flowId) => {
    return await window.api.invoke('storage.open-flow', flowId);
  }, []);

  // Database Connections API
  const saveConnection = useCallback(async (connectionData) => {
    console.log('ApiContext: sending connection data:', {
      ...connectionData,
      config: {
        ...connectionData.config,
        password: connectionData.config?.password ? '[REDACTED]' : undefined
      }
    });
    return await window.api.invoke('storage.save-connection', connectionData);
  }, []);

  const listConnections = useCallback(async () => {
    return await window.api.invoke('storage.list-connections');
  }, []);

  const deleteConnection = useCallback(async (connectionId) => {
    return await window.api.invoke('storage.delete-connection', connectionId);
  }, []);

  const testConnection = useCallback(async (connectionData) => {
    return await window.api.invoke('storage.test-connection', connectionData);
  }, []);

  const api = {
    nodes: {
      command: {
        execute: executeCommand
      },
      file: {
        save: saveFile,
        open: openFile
      }
    },
    storage: {
      saveFlow,
      openFlow,
      saveConnection,
      listConnections,
      deleteConnection,
      testConnection
    }
  };

  return (
    <ApiContext.Provider value={api}>
      {children}
    </ApiContext.Provider>
  );
}

export function useApi() {
  const context = useContext(ApiContext);
  if (!context) {
    throw new Error('useApi must be used within an ApiProvider');
  }
  return context;
} 
===========================================
<contexts/DiagramContext.jsx>
===========================================
import { createContext, useContext, useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { initStorage, saveState, loadState, clearState } from '../utils/storageUtils';
import FlowExecutor from '../executor/FlowExecutor';
import { 
  applyNodeChanges, 
  applyEdgeChanges, 
  addEdge 
} from 'reactflow';
import { findPreviousNodes } from '../utils/graphUtils';
import { useLogger } from './LoggerContext';
import { openDB } from 'idb';

const STORAGE_KEY = 'workflow_data';

// Add this constant for state properties we want to persist
const PERSISTED_STATE_KEYS = [
  'nodes',
  'edges',
  'nodeCounter',
  'nodeSequence',
];

const DB_NAME = 'workflow_db';
const STORE_NAME = 'workflow_store';
const DB_VERSION = 1;

const LOCAL_STORAGE_KEYS = {
  NODES: 'flowNodes',
  EDGES: 'flowEdges',
  ENVIRONMENT: 'flowEnvironment'
};

export const DiagramContext = createContext(null);

export const useDiagram = () => {
  const context = useContext(DiagramContext);
  if (!context) {
    throw new Error('useDiagram must be used within a DiagramProvider');
  }
  return context;
};

export const DiagramProvider = ({ children }) => {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [history, setHistory] = useState([]);
  const [nodeCounter, setNodeCounter] = useState({});
  const [selectedNode, setSelectedNode] = useState(null);
  const [isExecuting, setIsExecuting] = useState(false);
  const [executingNodeIds, setExecutingNodeIds] = useState(new Set());
  const [executor, setExecutor] = useState(null);
  const [sequence, setSequence] = useState(1);
  const [nodeSequence, setNodeSequence] = useState({});
  const { addLog } = useLogger();
  const [storage, setStorage] = useState({});
  const [utilityDrawerOpen, setUtilityDrawerOpen] = useState(false);
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [autoOpenDrawer, setAutoOpenDrawer] = useState(true);
  const [autoCloseDrawer, setAutoCloseDrawer] = useState(true);

  // Change ref to state
  const [initialLoadComplete, setInitialLoadComplete] = useState(false);

  // Add new state for options
  const [edgeType, setEdgeType] = useState('smoothstep');
  const [stepDelay, setStepDelay] = useState(300);
  const [background, setBackground] = useState('dots');
  const [showMinimap, setShowMinimap] = useState(true);
  const [lastInput, setLastInput] = useState(null);
  const [lastOutput, setLastOutput] = useState(null);

  // Initialize environment from localStorage
  const [environment, setEnvironment] = useState(() => {
    const savedEnv = localStorage.getItem(LOCAL_STORAGE_KEYS.ENVIRONMENT);
    return savedEnv ? JSON.parse(savedEnv) : { variables: {} };
  });

  useEffect(() => {
    if (!initialLoadComplete || !storage) return;
  
    const stateToSave = {
      nodes,
      edges,
      nodeCounter,
      nodeSequence,
      timestamp: Date.now(),
    };
  
    // Only save if there's actual state to save
    if (nodes.length > 0 || edges.length > 0 || 
        Object.keys(nodeCounter).length > 0 || 
        Object.keys(nodeSequence).length > 0) {
      
      saveState(storage, stateToSave);
    }
  }, [nodes, edges, nodeCounter, nodeSequence, initialLoadComplete, storage]);

  useEffect(() => {
    // track lastInput changes
    console.log('lastInput changed:', lastInput);
  }, [lastInput]);
  
  // Update environment variable and persist to localStorage
  const setEnvironmentVariable = useCallback((name, value) => {
    setEnvironment(prev => {
      const newEnv = {
        ...prev,
        variables: {
          ...prev.variables,
          [name]: value
        }
      };

      // Remove the variable if value is undefined
      if (value === undefined) {
        delete newEnv.variables[name];
      }

      // Save to localStorage
      localStorage.setItem(LOCAL_STORAGE_KEYS.ENVIRONMENT, JSON.stringify(newEnv));
      return newEnv;
    });
  }, []);

  const removeEnvironmentVariable = useCallback((key) => {
    setEnvironment(prev => {
      const newVars = { ...prev.variables };
      delete newVars[key];
      return {
        ...prev,
        variables: newVars
      };
    });
  }, []);

  const clearEnvironment = useCallback(() => {
    setEnvironment({
      variables: {},
      description: 'Default Environment'
    });
  }, []);

  const setEnvironmentDescription = useCallback((description) => {
    setEnvironment(prev => ({
      ...prev,
      description
    }));
  }, []);

  // Save nodes and edges to localStorage whenever they change
  useEffect(() => {
    localStorage.setItem(LOCAL_STORAGE_KEYS.NODES, JSON.stringify(nodes));
  }, [nodes]);

  useEffect(() => {
    localStorage.setItem(LOCAL_STORAGE_KEYS.EDGES, JSON.stringify(edges));
  }, [edges]);

  // Initialize nodes and edges from localStorage
  useEffect(() => {
    const savedNodes = localStorage.getItem(LOCAL_STORAGE_KEYS.NODES);
    const savedEdges = localStorage.getItem(LOCAL_STORAGE_KEYS.EDGES);
    
    if (savedNodes) {
      setNodes(JSON.parse(savedNodes));
    }
    if (savedEdges) {
      setEdges(JSON.parse(savedEdges));
    }
  }, []);

  // Create a new executor instance when nodes, edges, or environment changes
  useEffect(() => {
    const executor = new FlowExecutor(
      nodes,
      edges,
      addToHistory,
      addLog,
      setExecutingNodeIds,
      updateNodeData,
      setLastOutput,
      setLastInput,
      setEnvironmentVariable,
      environment
    );
    setExecutor(executor);
  }, [nodes, edges, environment]);

  useEffect(() => {
    if (initialLoadComplete) return;
  
    const initialize = async () => {

      const storageSystem = await initStorage();
      setStorage(storageSystem);
      
      const savedState = await loadState(storageSystem);
      if (savedState) {

        PERSISTED_STATE_KEYS.forEach(key => {
          if (savedState[key]) {
            switch (key) {
              case 'nodes':
                setNodes(savedState[key]);
                break;
              case 'edges':
                setEdges(savedState[key]);
                break;
              case 'nodeCounter':
                setNodeCounter(savedState[key]);
                break;
              case 'nodeSequence':
                setNodeSequence(savedState[key]);
                break;
            }
          }
        });
      }
      
      setInitialLoadComplete(true);
    };
  
    initialize();
  }, [initialLoadComplete]);

  // Update clearWorkflow to clear all persisted state
  const clearWorkflow = useCallback(() => {
    setNodes([]);
    setEdges([]);
    setSelectedNode(null);
    setNodeSequence({});
    setNodeCounter({});
    if (storage) {
      clearState(storage);
    }
  }, [storage]);


  const addToHistory = useCallback((entry) => {
    setHistory(prev => [...prev, entry]);
  }, []);

  const clearHistory = useCallback(() => {
    setHistory([]);
  }, []);

  const generateNodeId = useCallback((type) => {
    // Map node types to 4 letter prefixes
    const typeToPrefix = {
      http: 'HTTP',
      parser: 'PRSR',
      conditional: 'COND',
      iterator: 'ITER',
      fileop: 'FILE',
      prompt: 'PRMT',
      test: 'TEST',
      databaseQuery: 'DBQ',
      format: 'FRMT',
      command: 'CMD',
      rss: 'RSS'
    };

    // Use exact type match instead of toLowerCase()
    const prefix = typeToPrefix[type] || 'NODE';
    const nextCount = (nodeCounter[prefix] || 0) + 1;
    
    setNodeCounter(prev => ({
      ...prev,
      [prefix]: nextCount
    }));
    
    return `${prefix}_${String(nextCount).padStart(2, '0')}`;
  }, [nodeCounter]);

  const updateNodeData = useCallback((nodeId, field, value) => {

    
    setNodes(prevNodes => {
      const newNodes = prevNodes.map(node => {
        if (node.id === nodeId) {
          // Create a new node object with updated data
          const newNode = {
            ...node,
            data: {
              ...node.data,
              [field]: value
            }
          };
          
          // Also update selectedNode if this is the selected node
          if (selectedNode?.id === nodeId) {
            setSelectedNode(newNode);
          }
          
          return newNode;
        }
        return node;
      });
      
      return newNodes;
    });
  }, [selectedNode]);

  const clearSelection = useCallback(() => {
    setSelectedNode(null);
  }, []);

  const updateNodeSequence = useCallback((nodeId, newSequence) => {
    setNodes(prevNodes => {
      const newNodes = prevNodes.map(node => {
        if (node.id === nodeId) {
          return {
            ...node,
            data: {
              ...node.data,
              sequence: newSequence
            }
          };
        }
        return node;
      });
      return newNodes;
    });
  }, []);

  const incrementSequence = useCallback(() => {
    setSequence(prev => prev + 1);
  }, []);

  const resetSequences = useCallback(() => {
    setNodes(prevNodes => 
      prevNodes.map(node => ({
        ...node,
        data: {
          ...node.data,
          sequence: null
        }
      }))
    );
    setSequence(1);
  }, []);

  const startExecution = useCallback(async () => {
    setIsExecuting(true);
    setExecutingNodeIds(new Set());
    try {
      const executor = new FlowExecutor(
        nodes,
        edges,
        addToHistory,
        addLog,
        setExecutingNodeIds,
        updateNodeData,
        setLastOutput,
        setLastInput,
        setEnvironmentVariable,
        environment
      );
      
      const result = await executor.execute(updateNodeSequence, incrementSequence);
      setIsExecuting(false);
      setExecutingNodeIds(new Set());
      
    } catch (error) {
      console.error('Execution failed:', error);
      setIsExecuting(false);
      setExecutingNodeIds(new Set());
    }
  }, [nodes, edges, addToHistory, addLog, updateNodeSequence, incrementSequence, updateNodeData, setLastOutput, setLastInput, setEnvironmentVariable, environment]);

  const pauseExecution = useCallback(() => {
    setIsExecuting(false);
  }, []);

  const stopExecution = useCallback(() => {
    setIsExecuting(false);
    setExecutor(null);
    resetSequences();
  }, [resetSequences]);

  // Handle node changes from React Flow
  const onNodesChange = useCallback(
    (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
    []
  );

  // Handle edge changes from React Flow
  const onEdgesChange = useCallback(
    (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
    []
  );

  // Handle new connections
  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    []
  );

  const setStartNode = useCallback((nodeId) => {
    setNodes(prevNodes => {
      return prevNodes.map(node => ({
        ...node,
        data: {
          ...node.data,
          isStartNode: node.id === nodeId
        }
      }));
    });
  }, []);

  const updateDiagramState = useCallback(() => {
    // This function will be called whenever the diagram state changes
    console.log('Diagram state updated');
  }, []);

  // Get input data for a node by looking at its previous nodes' outputs
  const getNodeInputData = useCallback((nodeId) => {
    const previousNodes = findPreviousNodes(nodeId, nodes, edges);
    
    const inputData = previousNodes.reduce((acc, node) => {
      if (node.data?.response) {
        if (typeof node.data.response === 'object' && node.data.response !== null) {
          return { ...acc, ...node.data.response };
        }
        return { ...acc, [node.id]: node.data.response };
      }
      return acc;
    }, {});

    console.log('Input data for node', nodeId, ':', inputData);
    return inputData;
  }, [nodes, edges]);

  // Add a method to get the last output for a specific node
  const getNodeOutput = useCallback((nodeId) => {
    const node = nodes.find(n => n.id === nodeId);
    if (!node) {
      console.warn(`Node not found: ${nodeId}`);
      return null;
    }
    
    // Return the node's last output from its data
    return node.data?.result?.response || null;
  }, [nodes]);

  const value = useMemo(() => ({
    nodes,
    edges,
    setNodes,
    setEdges,
    onNodesChange,
    onEdgesChange,
    onConnect,
    history,
    selectedNode,
    setSelectedNode,
    addToHistory,
    clearHistory,
    generateNodeId,
    updateNodeData,
    clearSelection,
    isExecuting,
    executingNodeIds,
    setIsExecuting,
    startExecution,
    pauseExecution,
    stopExecution,
    updateNodeSequence,
    incrementSequence,
    sequence,
    resetSequences,
    setStartNode,
    updateDiagramState,
    nodeSequence,
    setNodeSequence,
    getNodeInputData,
    clearWorkflow,
    edgeType,
    setEdgeType,
    stepDelay,
    setStepDelay,
    background,
    setBackground,
    showMinimap,
    setShowMinimap,
    environment,
    setEnvironmentVariable,
    removeEnvironmentVariable,
    clearEnvironment,
    setEnvironmentDescription,
    lastInput,
    lastOutput,
    setLastOutput,
    utilityDrawerOpen,
    setUtilityDrawerOpen,
    sidebarOpen,
    setSidebarOpen,
    autoOpenDrawer,
    setAutoOpenDrawer,
    autoCloseDrawer,
    setAutoCloseDrawer,
    getNodeOutput,
  }), [
    nodes,
    edges,
    setNodes,
    setEdges,
    onNodesChange,
    onEdgesChange,
    onConnect,
    history,
    selectedNode,
    setSelectedNode,
    addToHistory,
    clearHistory,
    generateNodeId,
    updateNodeData,
    clearSelection,
    isExecuting,
    executingNodeIds,
    setIsExecuting,
    startExecution,
    pauseExecution,
    stopExecution,
    updateNodeSequence,
    incrementSequence,
    sequence,
    resetSequences,
    setStartNode,
    updateDiagramState,
    nodeSequence,
    setNodeSequence,
    getNodeInputData,
    clearWorkflow,
    edgeType,
    stepDelay,
    setStepDelay,
    background,
    showMinimap,
    environment,
    setEnvironmentVariable,
    removeEnvironmentVariable,
    clearEnvironment,
    setEnvironmentDescription,
    lastInput,
    lastOutput,
    utilityDrawerOpen,
    setUtilityDrawerOpen,
    sidebarOpen,
    setSidebarOpen,
    autoOpenDrawer,
    setAutoOpenDrawer,
    autoCloseDrawer,
    setAutoCloseDrawer,
    getNodeOutput,
  ]);

  return (
    <DiagramContext.Provider value={value}>
      {children}
    </DiagramContext.Provider>
  );
};

export default DiagramProvider;
===========================================
<contexts/LoggerContext.jsx>
===========================================
import { createContext, useContext, useState, useCallback } from 'react';

const LoggerContext = createContext(null);

export const useLogger = () => {
  const context = useContext(LoggerContext);
  if (!context) {
    throw new Error('useLogger must be used within a LoggerProvider');
  }
  return context;
};

export const LoggerProvider = ({ children }) => {
  const [logs, setLogs] = useState([]);

  const addLog = useCallback((log) => {
    setLogs(prevLogs => [...prevLogs, {
      id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      ...log
    }]);
  }, []);

  const clearLogs = useCallback(() => {
    setLogs([]);
  }, []);

  return (
    <LoggerContext.Provider value={{ logs, addLog, clearLogs }}>
      {children}
    </LoggerContext.Provider>
  );
}; 
===========================================
<contexts/ThemeContext.jsx>
===========================================
import { createContext, useContext, useEffect, useState } from 'react';
import PropTypes from 'prop-types';

const ThemeContext = createContext();

export const useTheme = () => useContext(ThemeContext);

export const ThemeProvider = ({ children }) => {
  const [isDark, setIsDark] = useState(true); // Default to dark theme

  useEffect(() => {
    document.documentElement.classList.toggle('dark', isDark);
  }, [isDark]);

  const toggleTheme = () => setIsDark(!isDark);

  return (
    <ThemeContext.Provider value={{ isDark, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

ThemeProvider.propTypes = {
  children: PropTypes.node.isRequired,
}; 
===========================================
<executor/FlowExecutor.js>
===========================================
import { findNextNodes } from '../utils/graphUtils';
import xml from '../utils/xml';
import regex from '../utils/regex';
import Handlebars from 'handlebars';
import formatter from '../utils/formatter';
import JQParser from '../utils/jq';
import HttpNode from './basic/HttpNode';
import FormatNode from './basic/FormatNode';
import FileNode from './basic/FileNode';
import ParserNode from './basic/ParserNode';
import ConditionalNode from './basic/ConditionalNode';
import IteratorNode from './basic/IteratorNode';
import TestNode from './basic/TestNode';
import CommandNode from './basic/CommandNode';
import DatabaseQueryNode from './basic/DatabaseQueryNode';
import RSSNode from './basic/RSSNode';
const jq = new JQParser();

export default class FlowExecutor {
  constructor(nodes, edges, addToHistory, addLog, setExecutingNodeIds, updateNodeData, setLastOutput, setLastInput, setEnvironmentVariable, environment) {
    this.nodes = nodes;
    this.edges = edges;
    this.addAction = addToHistory;
    this.addLog = addLog;
    this.setExecutingNodeIds = setExecutingNodeIds;
    this.updateNodeData = updateNodeData;
    this.setLastOutput = setLastOutput;
    this.setLastInput = setLastInput;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.nodeOutputs = new Map();
    this.executionSequence = 1;
    this.loggedNodes = new Set();
    this.lastInput = null;
    this.stepDelay = 300;
    // Iterator state
    this.iteratorState = new Map(); // Map of nodeId -> { currentIndex, items }
    // Initialize executingNodes Set
    this.executingNodes = new Set();
    this.environment = environment;
    this.localEnvironment = { ...environment }; // Add local copy of environment
    
    // Initialize node executors
    this.httpNode = new HttpNode(
      this.getEnvVar.bind(this),
      this.setEnvironmentVariable,
      this.localEnvironment
    );
    this.formatNode = new FormatNode(this.updateNodeData);
    this.fileNode = new FileNode();
    this.parserNode = new ParserNode();
    this.conditionalNode = new ConditionalNode();
    this.iteratorNode = new IteratorNode(
      this.updateNodeData,
      this.getEnvVar.bind(this)
    );
    this.testNode = new TestNode();
    this.commandNode = new CommandNode();
    this.databaseQueryNode = new DatabaseQueryNode();
    this.rssNode = new RSSNode(
      this.getEnvVar.bind(this),
      this.setEnvironmentVariable,
      this.localEnvironment
    );
    this.executors = {
      command: this.commandNode,
      databaseQuery: this.databaseQueryNode,
      parser: this.parserNode,
      rss: this.rssNode,
      http: this.httpNode,
      format: this.formatNode,
      file: this.fileNode,
      conditional: this.conditionalNode,
      iterator: {
        execute: (data, inputData, sourceNodes) => this.iteratorNode.execute(data, inputData, sourceNodes)
      },
      test: this.testNode
    };
  }

  // Update getEnvVar to use local environment
  getEnvVar(varName) {
    const name = varName.startsWith('$') ? varName.slice(1) : varName;
    return this.localEnvironment?.variables?.[name];
  }

  logAction(nodeType, status, message, details = null) {
    ; // Debug
    if (this.addAction) {
      const action = {
        type: nodeType.toUpperCase(),
        status,
        message,
        data: details,
        timestamp: new Date().toISOString()
      };
      ; // Debug
      this.addAction(action);
    } else {
      ; // Debug
    }
  }

  async delay() {
    return new Promise(resolve => setTimeout(resolve, this.stepDelay));
  }

  async execute(updateNodeSequence, incrementSequence) {
    this.nodeOutputs.clear();
    this.resetIteratorState();
    
    try {
      // Get all nodes by levels
      const nodeLevels = this.getNodesByLevel();
      console.log('Execution levels:', nodeLevels);
      
      // Execute nodes level by level
      for (const level of nodeLevels) {
        console.log('Executing level:', level);
        
        // First, execute non-iterator nodes in this level
        const nonIteratorNodes = level.filter(nodeId => {
          const node = this.nodes.find(n => n.id === nodeId);
          return node.type !== 'iterator';
        });
  
        if (nonIteratorNodes.length > 0) {
          await Promise.all(nonIteratorNodes.map(nodeId => 
            this.executeNodeAtLevel(nodeId, updateNodeSequence, incrementSequence)
          ));
        }
  
        // Then handle iterator nodes sequentially
        const iteratorNodes = level.filter(nodeId => {
          const node = this.nodes.find(n => n.id === nodeId);
          return node.type === 'iterator';
        });
  
        for (const iteratorNodeId of iteratorNodes) {
          await this.executeIteratorAndDescendants(
            iteratorNodeId,
            updateNodeSequence,
            incrementSequence
          );
        }
      }
      
      return this.lastInput;
    } catch (error) {
      console.error('Workflow execution failed:', error);
      throw error;
    }
  }

  getNodesByLevel() {
    const levels = [];
    const visited = new Set();
    
    // Find start nodes (nodes with no incoming edges)
    const startNodes = this.nodes
      .filter(node => !this.edges.some(edge => edge.target === node.id))
      .map(node => node.id);
    
    if (startNodes.length > 0) {
      levels.push(startNodes);
      startNodes.forEach(nodeId => visited.add(nodeId));
    }

    // Build subsequent levels
    while (true) {
      const currentLevel = [];
      
      // Find nodes whose dependencies are all in previous levels
      this.nodes.forEach(node => {
        if (visited.has(node.id)) return;
        
        const dependencies = this.edges
          .filter(edge => edge.target === node.id)
          .map(edge => edge.source);
        
        if (dependencies.every(depId => visited.has(depId))) {
          currentLevel.push(node.id);
        }
      });
      
      if (currentLevel.length === 0) break;
      
      levels.push(currentLevel);
      currentLevel.forEach(nodeId => visited.add(nodeId));
    }
    
    return levels;
  }

  async executeNodeAtLevel(nodeId, updateNodeSequence, incrementSequence) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return;

    try {
      // Update executing nodes set
      this.executingNodes.add(nodeId);
      this.setExecutingNodeIds(new Set(this.executingNodes));
      await this.delay();
      
      // Update sequence
      updateNodeSequence(nodeId, this.executionSequence);
      this.executionSequence = incrementSequence();

      // Get input data from previous nodes
      const sourceNodeIds = this.edges
        .filter(edge => edge.target === nodeId)
        .map(edge => edge.source);
      
      console.log(`Source node IDs for ${nodeId}:`, sourceNodeIds);
      console.log('All edges:', this.edges);
      
      const sourceNodes = this.nodes
        .filter(n => sourceNodeIds.includes(n.id))
        .map(n => {
          const nodeOutput = this.nodeOutputs.get(n.id);
          console.log(`Output for source node ${n.id}:`, nodeOutput);
          return {
            id: n.id,
            type: n.type,
            data: nodeOutput
          };
        });

      console.log(`Source nodes for ${nodeId}:`, sourceNodes);

      // Create input context
      this.lastInput = {
        [nodeId]: sourceNodes.reduce((acc, source) => ({
          ...acc,
          [source.id]: source.data
        }), {})
      };
      
      // Update context if available
      if (this.setLastInput) {
        this.setLastInput(this.lastInput);
      }

      // Execute node
      const output = await this.executeNode(node, this.lastInput[nodeId], sourceNodes);
      this.nodeOutputs.set(nodeId, output);

      // Handle iterator nodes
      if (output?.isIterator) {
        // For now, we'll handle iterators sequentially within their level
        // This might need to be revisited for more complex iterator scenarios
        const iterationOutput = await this.handleIteratorNode(
          node,
          output,
          updateNodeSequence,
          incrementSequence
        );
        this.nodeOutputs.set(nodeId, iterationOutput);
      }

      // Clear this node from executing set
      this.executingNodes.delete(nodeId);
      this.setExecutingNodeIds(new Set(this.executingNodes));

      return output;
    } catch (error) {
      console.error(`Error executing node ${nodeId}:`, error);
      // Clear executing state on error
      this.executingNodes.delete(nodeId);
      this.setExecutingNodeIds(new Set(this.executingNodes));
      throw error;
    }
  }

  // New helper method for handling iterator nodes
  async handleIteratorNode(node, output, updateNodeSequence, incrementSequence) {
    if (!output?.iteration?.hasMore) {
      return output;
    }
  
    return output; // Return the current iteration output
  }

  async executeIteratorAndDescendants(nodeId, updateNodeSequence, incrementSequence) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return;
  
    try {
      const downstreamNodes = this.getDownstreamNodes(nodeId);
      let currentOutput = await this.executeNodeAtLevel(nodeId, updateNodeSequence, incrementSequence);
      
      if (!currentOutput?.isIterator) return currentOutput;
  
      // Continue while the outer iterator has more items
      while (currentOutput?.shouldContinue) {
        const currentOuterItem = currentOutput.response;
        
        // For each downstream node that is an iterator
        for (const downstreamId of downstreamNodes) {
          const downstreamNode = this.nodes.find(n => n.id === downstreamId);
          if (downstreamNode.type !== 'iterator') continue;
          
          // Execute the inner iterator
          let innerOutput = await this.executeNodeAtLevel(
            downstreamId,
            updateNodeSequence,
            incrementSequence
          );
          
          // Complete the full inner iteration cycle
          while (innerOutput?.shouldContinue) {
            innerOutput = await this.executeNodeAtLevel(
              downstreamId,
              updateNodeSequence,
              incrementSequence
            );
          }
        }
  
        // Get next item from outer iterator
        currentOutput = await this.executeNodeAtLevel(
          nodeId,
          updateNodeSequence,
          incrementSequence
        );
      }
  
      return currentOutput;
    } catch (error) {
      console.error(`Error executing iterator node ${nodeId}:`, error);
      throw error;
    }
  }
  
  async executeNode(node, inputData = null, sourceNodes = []) {
    const executor = this.executors[node.type];
    if (!executor) {
      throw new Error(`No execution method found for node type: ${node.type}`);
    }

    try {
      const result = await executor.execute(node.data, inputData, sourceNodes);

      // Log output for visualization/debugging
      if (this.setLastOutput) {
        this.setLastOutput({
          nodeId: node.id,
          type: node.type,
          data: result,
          timestamp: new Date().toISOString(),
          iteration: result?.iteration || inputData?.iteration,
          workflowContext: {
            iterationId: result?.iteration?.current ? `iteration_${result.iteration.current}` : undefined,
            parentNodeId: sourceNodes[0]?.id,
            sequence: node.type === 'iterator' ? 'start' : 
                     inputData?.iteration ? `step_${inputData.iteration.current}` : undefined
          }
        });
      }

      // Get iteration info from input or result
      const iterationInfo = result?.iteration || inputData?.iteration;
      
      // Create unique log key based on current node and iteration
      const logKey = `${node.type.toUpperCase()}_${node.id}${
        iterationInfo ? `_iter_${iterationInfo.current}` : ''
      }`;

      // Log the execution result
      const logEntry = {
        name: node.data.name || node.id,
        source: logKey,
        sourceNodes: sourceNodes.map(n => n.id).join(', '),
        data: result,
        timestamp: new Date().toISOString(),
        iteration: iterationInfo
      };

      this.addLog(logEntry);
      this.loggedNodes.add(logKey);

      // Preserve iteration context
      if (inputData?.iteration) {
        result.iteration = inputData.iteration;
      }

      return result;
    } catch (error) {
      console.error(`Error executing node ${node.id}:`, error);
      throw error;
    }
  }

  // Update resetIteratorState to use the iterator node's method
  resetIteratorState(nodeId) {
    this.iteratorNode.resetState(nodeId);
  }

  // Helper functions
  
  getDownstreamNodes(nodeId, visited = new Set()) {
    visited.add(nodeId);
    
    const directDownstream = this.edges
      .filter(edge => edge.source === nodeId)
      .map(edge => edge.target);
      
    directDownstream.forEach(id => {
      if (!visited.has(id)) {
        const furtherDownstream = this.getDownstreamNodes(id, visited);
        directDownstream.push(...furtherDownstream);
      }
    });
    
    return Array.from(new Set(directDownstream));
  }

  decodeHTMLEntities(text){
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
  };

  simplifyXmlObject(obj) {
    // Base case: if we have a content property, return its value
    if (obj && typeof obj === 'object' && 'content' in obj) {
      return obj.content;
    }

    // If we have children array, process each child
    if (obj && obj.children && Array.isArray(obj.children)) {
      const result = {};
      
      // Process each child
      obj.children.forEach(child => {
        // Get the first (and should be only) key of the child object
        const key = Object.keys(child)[0];
        
        // If we already have this key and it's not an array, convert to array
        if (key in result) {
          if (!Array.isArray(result[key])) {
            result[key] = [result[key]];
          }
          result[key].push(this.simplifyXmlObject(child[key]));
        } else {
          // Otherwise just process the child
          result[key] = this.simplifyXmlObject(child[key]);
        }
      });
      
      return result;
    }

    // If it's an object but not one of the above cases, process each property
    if (obj && typeof obj === 'object') {
      const result = {};
      for (const [key, value] of Object.entries(obj)) {
        result[key] = this.simplifyXmlObject(value);
      }
      return result;
    }

    // Default case: return the value as is
    return obj;
  }

  
} 
===========================================
<executor/basic/CommandNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class CommandNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
  }

  evaluateTemplate(template, context) {
    if (!template || !template.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined) {
            console.warn(`Environment variable ${path} not found`);
            value = '';
          }
        } else {
          value = jq.evaluate(path, context);
        }
        
        result = result.replace(match, String(value));
      }
    }
    return result;
  }

  async execute(data, inputData = null, sourceNodes = []) {
    try {
      const { 
        command = '', 
        workingDirectory,
        timeout = 30000,
        environmentVars = []
      } = data;

      // Evaluate command template
      const evaluatedCommand = this.evaluateTemplate(command, inputData);
      
      // Execute command through IPC
      const result = await window.api.executeCommand(evaluatedCommand, {
        workingDirectory,
        timeout,
        environmentVars
      });

      if (!result.success) {
        throw new Error(result.error);
      }

      return formatter.standardResponse(true, result.data);
      
    } catch (error) {
      return formatter.errorResponse(error.message);
    }
  }
}
===========================================
<executor/basic/ConditionalNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class ConditionalNode {
  async execute(data, inputData, sourceNodes) {
    try {
      const { conditions = [] } = data;

      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};
      
      if (!conditions.length) {
        console.warn('Conditional node has no conditions configured');
        return {
          success: true,
          outputPath: 'else'  // Default to else path if no conditions
        };
      }

      console.log('conditions', conditions);

      // Evaluate each condition in order
      for (let i = 0; i < conditions.length; i++) {
        const condition = conditions[i];
        let { field, operator, value } = condition;
        // try evaluating field and value as jq expressions, if failing, use the raw values
        try {
          field = jq.evaluate(field, context);
          value = jq.evaluate(value, context);
        } catch (e) {
          field = field;
          value = value;
        }

        console.log('parsed field, value', [field, value]);

        let conditionMet = false;

        switch (operator) {
          case '==':
            conditionMet = Number(field) == Number(value);  // Use loose equality for type coercion
            break;
          case '>=':
            conditionMet = Number(field) >= Number(value);
            break;
          case '<=':
            conditionMet = Number(field) <= Number(value);
            break;
          case 'contains':
            conditionMet = String(field).includes(String(value));
            break;
          default:
            throw new Error(`Unsupported operator: ${operator}`);
        }

        if (conditionMet) {
          return formatter.standardResponse(true, {
            success: true,
            outputPath: `output-${i + 1}`,
            data: inputData
          });
        }
      }

      // If no conditions matched, return else path
      return {
        success: true,
        outputPath: 'output-else'
      };

    } catch (error) {
      console.error('Conditional node execution failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }
} 
===========================================
<executor/basic/DatabaseQueryNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class DatabaseQueryNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
  }

  async execute(data, inputData) {
    try {
      console.log('DatabaseQueryNode executing with data:', {
        ...data,
        password: data.password ? '[REDACTED]' : undefined
      });

      const { connectionId, query = '', parameters = [] } = data;
      
      if (!connectionId) {
        return formatter.errorResponse('No database connection selected');
      }

      if (!query || !query.trim()) {
        console.log('Query is empty or undefined:', { query, dataType: typeof query });
        return formatter.errorResponse('Query cannot be empty');
      }

      // Process any template variables in the query
      let processedQuery = query;
      let processedParams = [];

      try {
        // Replace {{variable}} templates in query
        processedQuery = query.replace(/\{\{(.*?)\}\}/g, (match, path) => {
          try {
            const value = jq.evaluate(path.trim(), inputData);
            processedParams.push(value);
            return `$${processedParams.length}`; // Replace with parameterized query placeholder
          } catch (error) {
            throw new Error(`Failed to process template ${match}: ${error.message}`);
          }
        });

        // Process parameter values
        parameters.forEach(param => {
          if (!param.value) {
            throw new Error(`Parameter "${param.name}" has no value`);
          }
          const value = jq.evaluate(param.value, inputData);
          processedParams.push(value);
        });

        console.log('Executing query:', {
          connectionId,
          processedQuery,
          processedParams,
          originalQuery: query
        });

      } catch (error) {
        return formatter.errorResponse(`Query template processing failed: ${error.message}`);
      }

      try {
        // Execute query through IPC
        const result = await window.api.invoke('nodes.database.query', {
          connectionId,
          query: processedQuery,
          parameters: processedParams
        });

        if (!result.success) {
          throw new Error(result.error);
        }

        return formatter.standardResponse(true, {
          success: true,
          rowCount: result.data.rowCount,
          rows: result.data.rows,
          fields: result.data.fields
        });
      } catch (error) {
        return formatter.errorResponse(`Database query failed: ${error.message}`);
      }
    } catch (error) {
      return formatter.errorResponse(error.message);
    }
  }
} 
===========================================
<executor/basic/FileNode.js>
===========================================
import formatter from '../../utils/formatter';

export default class FileNode {
  async execute(data, inputData) {
    try {
      const { operation, fileName, content } = data;

      switch (operation) {
        case 'read':
          return {
            success: true,
            operation: 'read',
            fileName,
            content,
            timestamp: new Date().toISOString()
          };

        case 'write':
          // Create a blob from the input data
          let contentToWrite = inputData;
          
          // Convert to string if it's an object
          if (typeof inputData === 'object') {
            contentToWrite = JSON.stringify(inputData, null, 2);
          }

          const blob = new Blob([contentToWrite], { type: 'text/plain' });
          const url = window.URL.createObjectURL(blob);
          
          // Create a temporary link and trigger download
          const link = document.createElement('a');
          link.href = url;
          link.download = fileName || 'output.txt';
          document.body.appendChild(link);
          link.click();
          
          // Cleanup
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);

          return {
            success: true,
            operation: 'write',
            fileName,
            timestamp: new Date().toISOString()
          };

        default:
          throw new Error(`Unsupported file operation: ${operation}`);
      }
    } catch (error) {
      return formatter.errorResponse(`File operation failed: ${error.message}`);
    }
  }
} 
===========================================
<executor/basic/FormatNode.js>
===========================================
import Handlebars from 'handlebars';
import formatter from '../../utils/formatter';
import xml from '../../utils/xml';

export default class FormatNode {
  constructor(updateNodeData) {
    this.updateNodeData = updateNodeData;
  }

  decodeHTMLEntities(text) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
  }

  async execute(data, inputData, sourceNodes) {
    if (!data.id) return formatter.errorResponse('Node ID is missing', 'unknown');
  
    try {
      const { template, formatType } = data;
      if (!template) return formatter.errorResponse('Template is missing', data.id);
  
      // Process source data
      const sourceData = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};
  
      // Create template context
      const templateContext = {
        sourceData,
        inputData: sourceData[Object.keys(sourceData)[0]],
        data: sourceData[Object.keys(sourceData)[0]]?.response?.data,
        raw: sourceData[Object.keys(sourceData)[0]]?.response?.data
      };
  
      // Execute template
      const compiled = Handlebars.compile(template);
      let result = compiled(templateContext);
      result = this.decodeHTMLEntities(result);
  
      // Parse based on formatType
      let parsedResult;
      switch (formatType?.toLowerCase()) {
        case 'json':
          try {
            parsedResult = JSON.parse(result);
          } catch (e) {
            console.error('JSON parsing failed:', e);
            parsedResult = result;
          }
          break;
        
        case 'xml':
          try {
            parsedResult = xml.parse(result);
          } catch (e) {
            console.error('XML parsing failed:', e);
            parsedResult = result;
          }
          break;
        
        default:
          parsedResult = result;
      }
  
      // Update node data if available
      if (this.updateNodeData) {
        await this.updateNodeData(data.id, 'lastOutput', {
          sourceData,
          output: parsedResult,
          timestamp: new Date().toISOString()
        });
      }
  
      return formatter.standardResponse(true, parsedResult, null, data.id);
  
    } catch (error) {
      return formatter.errorResponse(error, data.id);
    }
  }
} 
===========================================
<executor/basic/HttpNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class HttpNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
  }

  // Helper function for evaluating templates with environment variables
  evaluateEnvTemplate(template, context) {
    if (!template.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined) {
            console.warn(`Environment variable ${path} not found`);
            value = '';
          }
        } else {
          value = jq.evaluate(path, context);
        }
        
        result = result.replace(match, value);
      }
    }
    return result;
  }

  async execute(data, inputData = null, sourceNodes = []) {
    try {
      const { method = 'GET', url, headers = [], params = [], body, environmentVars = [] } = data;
      
      // Log the environment state at execution time
      console.log('Executing HTTP node with environment:', {
        localEnvironment: this.localEnvironment,
        environmentVars
      });

      if (!url) {
        return formatter.errorResponse('URL is required but was not specified');
      }

      // Build context from source nodes
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      // Template the URL
      let templatedUrl = url;
      try {
        templatedUrl = this.evaluateEnvTemplate(url, context);
        console.log('Templated URL:', { original: url, templated: templatedUrl });
      } catch (error) {
        console.error('URL templating failed:', error, { url, context });
        return formatter.errorResponse(`URL templating failed: ${error.message}`);
      }

      // Template and convert headers array to object
      const headerObj = headers.reduce((acc, { key, value }) => {
        if (key && value) {
          try {
            const templatedKey = this.evaluateEnvTemplate(key, context);
            const templatedValue = this.evaluateEnvTemplate(value, context);
            acc[templatedKey] = templatedValue;
          } catch (error) {
            console.error('Header templating failed:', error);
            acc[key] = value;
          }
        }
        return acc;
      }, {});

      // Template and convert params array to URLSearchParams
      const templatedParams = params
        .filter(({ key, value }) => key && value)
        .map(({ key, value }) => {
          try {
            const templatedKey = this.evaluateEnvTemplate(key, context);
            const templatedValue = this.evaluateEnvTemplate(value, context);
            return [templatedKey, templatedValue];
          } catch (error) {
            console.error('Param templating failed:', error);
            return [key, value];
          }
        });

      const searchParams = new URLSearchParams(templatedParams);
      const fullUrl = `${templatedUrl}${searchParams.toString() ? '?' + searchParams.toString() : ''}`;

      console.log('Making request with:', {
        url: fullUrl,
        method,
        headers: headerObj,
        body
      });

      const fetchOptions = {
        method,
        headers: {
          'Content-Type': 'application/json',
          ...headerObj
        },
      };

      // Only add body for POST, PUT, PATCH
      if (['POST', 'PUT', 'PATCH'].includes(method) && body) {
        try {
          const templatedBody = this.evaluateEnvTemplate(body, context);
          fetchOptions.body = templatedBody;
        } catch (error) {
          console.error('Body templating failed:', error);
          fetchOptions.body = body;
        }
      }

      const response = await fetch(fullUrl, fetchOptions);
      const responseData = await response.text();
      
      // Try to parse as JSON, handle empty responses
      let parsedData;
      try {
        if (responseData && responseData.trim()) {
          parsedData = JSON.parse(responseData);
        } else {
          parsedData = null;
        }
      } catch (e) {
        console.error('JSON parsing failed:', e);
        parsedData = responseData;
      }

      const result = {
        status: response.status,
        headers: Object.fromEntries(response.headers.entries()),
        data: parsedData
      };

      const formattedResult = formatter.standardResponse(true, result);

      // Handle environment variable setting
      if (environmentVars?.length > 0) {
        for (const envVar of environmentVars) {
          const variableName = envVar.variable === 'CREATE_NEW' ? envVar.newVariableName : envVar.variable;
          
          if (variableName && envVar.value) {
            try {
              const envContext = {
                response: result,
                ...context
              };

              const templatedValue = this.evaluateEnvTemplate(envVar.value, envContext);
              console.log('Setting environment variable:', {
                name: variableName,
                value: templatedValue,
                template: envVar.value,
                context: envContext
              });
              
              // Update both global and local environment
              if (this.setEnvironmentVariable) {
                this.setEnvironmentVariable(variableName, templatedValue);
                
                // Update local environment immediately
                if (!this.localEnvironment.variables) {
                  this.localEnvironment.variables = {};
                }
                this.localEnvironment.variables[variableName] = templatedValue;
              }
            } catch (error) {
              console.error('Environment variable setting failed:', error, {
                variable: envVar,
                context: context
              });
            }
          }
        }
      }

      return formattedResult;

    } catch (error) {
      console.error('HTTP node execution failed:', error);
      return formatter.errorResponse(error.message);
    }
  }
} 
===========================================
<executor/basic/IteratorNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class IteratorNode {
  constructor(updateNodeData, getEnvVar) {
    this.updateNodeData = updateNodeData;
    this.getEnvVar = getEnvVar;
    this.iteratorState = new Map();
  }

  resetState(nodeId) {
    if (nodeId) {
      this.iteratorState.delete(nodeId);
    } else {
      this.iteratorState.clear();
    }
  }

  evaluateEnvTemplate(template, context) {
    if (!template?.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        value = jq.evaluate(path, context);
        result = result.replace(match, value);
      }
    }
    return result;
  }

  async execute(data, inputData) {
    try {
      const nodeId = data.id;
      const mode = data.mode || 'input';
      
      let itemsToIterate;
      if (mode === 'custom') {
        itemsToIterate = data.outputList;
      } else if (mode === 'input' && inputData) {
        // Handle RSS feed items array
        itemsToIterate = inputData?.response?.items || data.outputList || [];
      } else {
        itemsToIterate = [];
      }
  
      if (!Array.isArray(itemsToIterate)) {
        return formatter.errorResponse('Items to iterate must be an array');
      }
  
      let state = this.iteratorState.get(nodeId);
      const isInnerIterator = Boolean(inputData?.isIterator);
      const parentIteration = inputData?.isIterator ? inputData.iteration.current : 1;
  
      // Initialize state for new iteration cycle
      if (!state || 
          (!isInnerIterator && state.currentIndex >= state.items.length) ||
          (isInnerIterator && (state.parentIteration !== parentIteration || !inputData.shouldContinue))) {
        
        state = {
          currentIndex: 0,
          parentIteration,
          items: itemsToIterate.slice(),
          totalItems: itemsToIterate.length,
          isInnerIterator,
          completed: false
        };
        this.iteratorState.set(nodeId, state);
        
        if (mode === 'custom') {
          await this.updateNodeData(nodeId, 'outputList', itemsToIterate);
        }
      }
  
      // Check for completion
      if (state.currentIndex >= state.items.length) {
        if (!state.isInnerIterator || !inputData?.shouldContinue) {
          this.iteratorState.delete(nodeId);
          await this.updateNodeData(nodeId, 'result', null);
          await this.updateNodeData(nodeId, 'progress', {
            current: state.totalItems,
            total: state.totalItems,
            percentage: 100
          });
          return formatter.standardResponse(true, {
            complete: true,
            processedItems: state.totalItems
          });
        }
        
        // Reset inner iterator for next parent item
        state.currentIndex = 0;
        state.parentIteration = parentIteration;
        this.iteratorState.set(nodeId, state);
      }
  
      const currentItem = state.items[state.currentIndex];
      
      await this.updateNodeData(nodeId, 'result', currentItem);
      await this.updateNodeData(nodeId, 'progress', {
        current: state.currentIndex + 1,
        total: state.totalItems,
        percentage: Math.round(((state.currentIndex + 1) / state.totalItems) * 100)
      });
  
      state.currentIndex++;
      this.iteratorState.set(nodeId, state);
  
      const hasMore = state.currentIndex < state.items.length;
      
      return {
        ...formatter.standardResponse(true, currentItem),
        isIterator: true,
        shouldContinue: hasMore || (state.isInnerIterator && inputData?.shouldContinue),
        iteration: {
          current: state.currentIndex,
          total: state.totalItems,
          hasMore: hasMore || (state.isInnerIterator && inputData?.shouldContinue)
        },
        progress: {
          current: state.currentIndex,
          total: state.totalItems,
          percentage: Math.round((state.currentIndex / state.totalItems) * 100)
        }
      };
  
    } catch (error) {
      console.error('Iterator node execution failed:', error);
      return formatter.errorResponse(error.message);
    }
  }

  execute(inputData, parentIteration = 1) {
    // Initialize state if not already done
    if (!this.state) {
        const items = inputData?.response?.items || [];
        this.state = {
            items: items,
            currentIndex: 0,
            totalItems: items.length,
            isInnerIterator: inputData?.isIterator || false
        };
    }

    // Get current item
    const currentItem = this.state.items[this.state.currentIndex];
    const hasMore = this.state.currentIndex < this.state.totalItems - 1;

    // Calculate actual iteration number (1-based)
    const currentIteration = this.state.currentIndex + 1;

    // Calculate percentage (0-100)
    const percentage = Math.min(
        Math.round((currentIteration / this.state.totalItems) * 100),
        100
    );

    // Increment for next iteration
    this.state.currentIndex++;

    // Return response
    return {
        ...formatter.standardResponse(true, currentItem),
        isIterator: true,
        shouldContinue: hasMore,
        iteration: {
            current: currentIteration,
            total: this.state.totalItems,
            hasMore: hasMore
        },
        progress: {
            current: currentIteration,
            total: this.state.totalItems,
            percentage: percentage
        }
    };
  }
}
===========================================
<executor/basic/ParserNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class ParserNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
  }

  async execute(data, inputData) {
    try {
      console.log('Parser executing with data:', data);
      console.log('Input data:', inputData);

      const { template = '' } = data;

      if (!template.trim()) {
        return formatter.errorResponse('Template expression cannot be empty');
      }

      // Get the source node ID from the template
      const sourceNodeId = template.split('.')[0];
      
      // Get the source data from the nested structure
      const sourceData = inputData[Object.keys(inputData)[0]][sourceNodeId];
      console.log('Source data for parsing:', sourceData);

      if (!sourceData || !sourceData.success) {
        return formatter.errorResponse('No valid source data found');
      }

      try {
        // Adjust the template to remove the node ID prefix
        const adjustedTemplate = template.substring(template.indexOf('.') + 1);
        console.log('Using adjusted template:', adjustedTemplate);

        const result = jq.evaluate(adjustedTemplate, sourceData);
        console.log('Parser result:', result);
        return formatter.standardResponse(true, result);
      } catch (error) {
        console.error('Parser error:', error);
        return formatter.errorResponse(`Parser error: ${error.message}`);
      }
    } catch (error) {
      console.error('Parser execution error:', error);
      return formatter.errorResponse(error.message);
    }
  }
} 
===========================================
<executor/basic/RSSNode.js>
===========================================
import { parse } from 'rss-to-json';
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class RSSNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
  }

  // Helper function for evaluating templates with environment variables
  evaluateEnvTemplate(template, context) {
    if (!template.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined || value === null || value === '') {
            const varName = path.startsWith('$') ? path.slice(1) : path;
            throw new Error(`Environment variable "${varName}" is not set. Please configure this variable in your environment settings.`);
          }
        } else {
          value = jq.evaluate(path, context);
        }
        
        result = result.replace(match, value);
      }
    }
    return result;
  }

  async execute(data, inputData, sourceNodes = []) {
    try {
      console.log('RSS executing with data:', data);
      console.log('Input data:', inputData);

      const { url, maxItems = 10, sortBy = 'published', sortDirection = 'desc' } = data;
      
      if (!url) {
        return formatter.errorResponse('RSS Feed URL is required');
      }

      // Build context from source nodes
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      // Template the URL with better error handling
      let templatedUrl;
      try {
        templatedUrl = this.evaluateEnvTemplate(url, context);
      } catch (error) {
        console.error('URL templating failed:', error);
        return formatter.errorResponse(error.message);
      }

      try {
        // Parse the RSS feed
        const feed = await parse(`https://corsproxy.io/?key=9966be14&url=${encodeURIComponent(templatedUrl)}`);

        // Sort items if needed
        if (feed.items && Array.isArray(feed.items)) {
          feed.items.sort((a, b) => {
            const aValue = a[sortBy];
            const bValue = b[sortBy];
            return sortDirection === 'desc' ? 
              (bValue - aValue) : 
              (aValue - bValue);
          });

          // Limit number of items if specified
          if (maxItems > 0) {
            feed.items = feed.items.slice(0, maxItems);
          }
        }

        console.log('RSS result:', feed);
        return formatter.standardResponse(true, feed);
      } catch (error) {
        console.error('RSS Feed error:', error);
        return formatter.errorResponse(`RSS Feed error: ${error.message}`);
      }
    } catch (error) {
      console.error('RSS execution error:', error);
      return formatter.errorResponse(error.message);
    }
  }
} 
===========================================
<executor/basic/TestNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class TestNode {
  async execute(data, inputData, sourceNodes = []) {
    try {
      const { tests = [], requireAll = true, continueOnFailure = false } = data;
      
      // Build context mapping for source nodes
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      if (!tests.length) {
        return formatter.standardResponse(true, {
          success: true,
          message: 'No tests configured',
          results: []
        });
      }
  
      // Execute each test case
      const results = [];
      let allPassed = true;
  
      for (const test of tests) {
        try {
          const result = await this.executeTestCase(test, context);
          results.push(result);
          
          if (!result.success) {
            allPassed = false;
            if (!continueOnFailure && test.stopOnFailure) {
              break;
            }
          }
        } catch (error) {
          const errorResult = {
            id: test.id,
            name: test.name,
            success: false,
            error: error.message
          };
          results.push(errorResult);
          allPassed = false;
          
          if (!continueOnFailure && test.stopOnFailure) {
            break;
          }
        }
      }
  
      // Determine overall success based on requireAll setting
      const success = requireAll ? allPassed : results.some(r => r.success);
  
      return formatter.standardResponse(true, {
        success,
        message: success ? 'All tests passed' : 'Some tests failed',
        results,
        timestamp: new Date().toISOString(),
        data: context
      });
  
    } catch (error) {
      return formatter.errorResponse(error.message);
    }
  }

  async executeTestCase(test, context) {
    try {
      const { type, operator, expected, path, header, sourceNodeId, id, name } = test;
      let actual;
      
      // Get the source node's data
      const sourceData = context[sourceNodeId];
      if (!sourceData) {
        return {
          id,
          name,
          success: false,
          error: `Source node ${sourceNodeId} not found in context`
        };
      }
    
      // Get actual value based on test type
      try {
        switch (type) {
          case 'status':
            actual = sourceData?.response?.status;
            break;
            
          case 'headers':
            const headers = sourceData?.response?.headers || {};
            const headerKey = Object.keys(headers)
              .find(key => key.toLowerCase() === header?.toLowerCase());
            actual = headers[headerKey];
            break;
            
          case 'body':
            actual = jq.evaluate(path, sourceData);
            break;
            
          default:
            throw new Error(`Unsupported test type: ${type}`);
        }
      } catch (error) {
        return {
          id,
          name,
          success: false,
          error: `Failed to get test value: ${error.message}`
        };
      }
    
      // Compare values based on operator
      let success = false;
      let message = '';
    
      try {
        switch (operator) {
          case 'equals':
            success = String(actual) === String(expected);
            message = success ? 'Values match' : 'Values do not match';
            break;
            
          case 'not_equals':
            success = String(actual) !== String(expected);
            message = success ? 'Values differ as expected' : 'Values match when they should differ';
            break;
            
          case 'contains':
            success = String(actual).includes(String(expected));
            message = success ? 'Value contains expected string' : 'Value does not contain expected string';
            break;
            
          case 'not_contains':
            success = !String(actual).includes(String(expected));
            message = success ? 'Value does not contain string as expected' : 'Value contains string when it should not';
            break;
            
          case 'greater_than':
            success = Number(actual) > Number(expected);
            message = success ? 'Value is greater' : 'Value is not greater';
            break;
            
          case 'less_than':
            success = Number(actual) < Number(expected);
            message = success ? 'Value is less' : 'Value is not less';
            break;
            
          case 'exists':
            success = actual !== undefined && actual !== null;
            message = success ? 'Value exists' : 'Value does not exist';
            break;
            
          case 'not_exists':
            success = actual === undefined || actual === null;
            message = success ? 'Value does not exist as expected' : 'Value exists when it should not';
            break;
            
          default:
            throw new Error(`Unsupported operator: ${operator}`);
        }
      } catch (error) {
        return {
          id,
          name,
          success: false,
          error: `Comparison failed: ${error.message}`
        };
      }
    
      return {
        id,
        name,
        type,
        success,
        message,
        expected,
        actual,
        operator
      };
    } catch (error) {
      return {
        id: test.id,
        name: test.name,
        success: false,
        error: error.message
      };
    }
  }
} 
===========================================
<main.jsx>
===========================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'
import { ThemeProvider } from './contexts/ThemeContext'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <ThemeProvider>
      <App />
    </ThemeProvider>
  </React.StrictMode>,
)

===========================================
<pages/Dashboard.jsx>
===========================================
import { useState, useEffect } from 'react';
import { BarChart3, Activity, CheckCircle2, XCircle, Clock, ArrowRight } from 'lucide-react';
import moment from 'moment';
import { Body1, Body2, Caption } from '../components/common/Typography';
import { loadState } from '../utils/storageUtils';

const Dashboard = () => {
  const [metrics, setMetrics] = useState({
    totalWorkflows: 0,
    totalRuns: 0,
    successRate: 0,
    recentRuns: []
  });

  useEffect(() => {
    const loadMetrics = async () => {
      try {
        const storage = await loadState();
        const workflows = Object.values(storage || {});
        
        // Calculate metrics
        const runs = workflows.flatMap(w => w.history || []);
        const successfulRuns = runs.filter(r => r.success).length;
        
        setMetrics({
          totalWorkflows: workflows.length,
          totalRuns: runs.length,
          successRate: runs.length ? (successfulRuns / runs.length) * 100 : 0,
          recentRuns: runs
            .sort((a, b) => b.timestamp - a.timestamp)
            .slice(0, 5)
            .map(run => ({
              ...run,
              workflowName: workflows.find(w => w.id === run.workflowId)?.name || 'Unknown Workflow',
              timestamp: moment(run.timestamp).format('MMM d, yyyy HH:mm')
            }))
        });
      } catch (error) {
        console.error('Error loading metrics:', error);
      }
    };
    
    loadMetrics();
  }, []);

  return (
    <div className="max-w-6xl mx-auto p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <Body1 className="font-bold">Dashboard</Body1>
          <Caption className="text-slate-500">Workflow Analytics & Metrics</Caption>
        </div>
      </div>

      {/* Metrics Grid */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {/* Total Workflows */}
        <div className="bg-white dark:bg-slate-800 rounded-lg p-4 border border-slate-200 dark:border-slate-700">
          <div className="flex items-center gap-2 text-purple-500 mb-2">
            <BarChart3 size={20} />
            <Body2 className="font-medium">Total Workflows</Body2>
          </div>
          <div className="text-2xl font-bold">{metrics.totalWorkflows}</div>
        </div>

        {/* Total Runs */}
        <div className="bg-white dark:bg-slate-800 rounded-lg p-4 border border-slate-200 dark:border-slate-700">
          <div className="flex items-center gap-2 text-blue-500 mb-2">
            <Activity size={20} />
            <Body2 className="font-medium">Total Runs</Body2>
          </div>
          <div className="text-2xl font-bold">{metrics.totalRuns}</div>
        </div>

        {/* Success Rate */}
        <div className="bg-white dark:bg-slate-800 rounded-lg p-4 border border-slate-200 dark:border-slate-700">
          <div className="flex items-center gap-2 text-green-500 mb-2">
            <CheckCircle2 size={20} />
            <Body2 className="font-medium">Success Rate</Body2>
          </div>
          <div className="text-2xl font-bold">
            {metrics.successRate.toFixed(1)}%
          </div>
        </div>
      </div>

      {/* Recent Runs */}
      <div className="bg-white dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700">
        <div className="p-4 border-b border-slate-200 dark:border-slate-700">
          <Body2 className="font-medium">Recent Workflow Runs</Body2>
        </div>
        <div className="divide-y divide-slate-200 dark:divide-slate-700">
          {metrics.recentRuns.map((run, index) => (
            <div key={index} className="p-4 flex items-center justify-between">
              <div className="flex items-center gap-4">
                {run.success ? (
                  <CheckCircle2 size={20} className="text-green-500" />
                ) : (
                  <XCircle size={20} className="text-red-500" />
                )}
                <div>
                  <Body2 className="font-medium">{run.workflowName}</Body2>
                  <div className="flex items-center gap-2 text-sm text-slate-500">
                    <Clock size={14} />
                    {format(run.timestamp, 'MMM d, yyyy HH:mm')}
                  </div>
                </div>
              </div>
              <ArrowRight size={16} className="text-slate-400" />
            </div>
          ))}
          
          {metrics.recentRuns.length === 0 && (
            <div className="p-8 text-center text-slate-500">
              <Body2>No workflow runs yet</Body2>
              <Caption>Run a workflow to see execution history</Caption>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default Dashboard;

===========================================
<pages/Flows.jsx>
===========================================
import { useState, useCallback, useRef, useMemo, useEffect } from 'react';
import ReactFlow, { 
  Controls, 
  Background,
  ReactFlowProvider,
  useReactFlow,
  MiniMap
} from 'reactflow';
import 'reactflow/dist/style.css';
import { cn } from '../utils';
import { useTheme } from '../contexts/ThemeContext';
import DiagramPalette from '../components/diagram/DiagramPalette';
import PositionableEdge from '../components/diagram/PositionableEdge';
import { DiagramProvider, useDiagram } from '../contexts/DiagramContext';
import { LoggerProvider } from '../contexts/LoggerContext';
import UtilityDrawer from '../components/diagram/utility/UtilityDrawer';
import ContextMenu from '../components/diagram/ContextMenu';
import { paletteItems, getNodeTypes } from '../constants/nodeTypes';

function DiagramContent() {
  const reactFlowWrapper = useRef(null);
  const { screenToFlowPosition } = useReactFlow();
  const { 
    nodes, 
    setNodes, 
    edges, 
    setEdges, 
    onNodesChange, 
    onEdgesChange, 
    onConnect,
    setSelectedNode,
    updateNodeData,
    updateDiagramState,
    background,
    sidebarOpen,
  } = useDiagram();
  const { isDark } = useTheme();
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  const [contextMenu, setContextMenu] = useState(null);
  
  const nodeTypes = useMemo(() => getNodeTypes(), []);
  const edgeTypes = useMemo(() => ({
    default: PositionableEdge,
  }), []);

  const onDrop = useCallback((event) => {
    event.preventDefault();

    const itemData = event.dataTransfer.getData('application/diagram-node');
    if (!itemData || !reactFlowWrapper.current || !reactFlowInstance) return;

    const item = JSON.parse(itemData);
    const position = reactFlowInstance.screenToFlowPosition({
      x: event.clientX,
      y: event.clientY
    });

    const newNode = {
      id: item.id,
      type: item.type,
      position,
      data: {
        ...item.data,
        onChange: updateNodeData
      }
    };

    setNodes((nds) => nds.concat(newNode));
    updateDiagramState();
  }, [reactFlowInstance, setNodes, updateDiagramState, updateNodeData]);

  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  // Add node selection handler
  const onSelectionChange = useCallback(({ nodes: selectedNodes }) => {
    // We'll only show config for single node selection

    if (selectedNodes?.length === 1 && selectedNodes[0]?.id !== undefined) {
      setSelectedNode(selectedNodes[0]);
    } else {
      setSelectedNode(null);
    }
  }, [setSelectedNode]);

  // Add node click handler for single node selection
  const onNodeClick = useCallback((_, node) => {
    setSelectedNode(node);
  }, [setSelectedNode]);

  // Handle context menu
  const onContextMenu = useCallback(
    (event, element) => {
      event.preventDefault();
      const bounds = reactFlowWrapper.current.getBoundingClientRect();
      
      setContextMenu({
        id: element.id,
        type: element.type, // 'node' or 'edge'
        x: event.clientX - bounds.left,
        y: event.clientY - bounds.top,
      });
    },
    []
  );

  const onEdgeUpdate = useCallback((oldEdge, newConnection) => {
    onEdgesChange([
      { 
        type: 'remove', 
        id: oldEdge.id 
      }
    ]);
    onConnect(newConnection);
  }, [onEdgesChange, onConnect]);

  return (<div className={cn(
    "h-full absolute top-0 left-0 m-0 p-0",
    sidebarOpen ? "w-[calc(100vw-200px)]" : "w-[calc(100vw-72px)]"
  )}>
      <div className="absolute inset-0 bg-[var(--background)]">

        <UtilityDrawer/>
        <div className="absolute inset-0" ref={reactFlowWrapper}>
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onEdgeUpdate={onEdgeUpdate}
            onInit={setReactFlowInstance}
            nodeTypes={nodeTypes}
            edgeTypes={edgeTypes}
            onDragOver={onDragOver}
            onDrop={onDrop}
            onSelectionChange={onSelectionChange}
            onNodeClick={onNodeClick}
            onNodeContextMenu={(_, node) => onContextMenu(_, { ...node, type: 'node' })}
            fitView={false}
            defaultViewport={{ x: 0, y: 0, zoom: 1 }}
            minZoom={0.5}
            maxZoom={2}
            className={cn(
              "m-0 p-0",
              isDark ? 'bg-slate-800' : 'bg-[#ffffff]'
            )}
            snapToGrid={true}
            snapGrid={[10, 10]}
            deleteKeyCode="Delete"
            multiSelectionKeyCode="Control"
            selectionKeyCode="Shift"
            connectOnClick={true}
            connectionMode="strict"
            edgesUpdatable={true}
            edgesFocusable={true}
            selectNodesOnDrag={false}
          >
            {background !== 'none' && (
              <Background
                variant={background}
                gap={20}
                size={1}
                color={
                  isDark  
                  ? background === 'dots' ? "rgba(203, 213, 225, 0.5)" : "rgba(203, 213, 225, 0.1)"
                  : background === 'dots' ? "rgba(0, 0, 0, 0.8)" : "rgba(0, 0, 0, 0.2)"
                }
              />
            )}
          </ReactFlow>

          <div className={cn(
            "absolute top-0 z-10 transition-all duration-300",
            "left-0"
          )}>
            <DiagramPalette items={paletteItems} />
          </div>

          {contextMenu && (
            <ContextMenu
              x={contextMenu.x}
              y={contextMenu.y}
              type={contextMenu.type}  // Verify this is being passed
              onClose={() => setContextMenu(null)}
              onDelete={() => {
                console.log('Deleting:', contextMenu.type, contextMenu.id);  // Debug log
                if (contextMenu.type === 'edge') {
                  onEdgesChange([{ 
                    type: 'remove', 
                    id: contextMenu.id 
                  }]);
                } else {
                  onNodesChange([{ 
                    type: 'remove', 
                    id: contextMenu.id 
                  }]);
                }
                setContextMenu(null);
              }}
            />
          )}
        </div>
      </div>
    </div>
  );
}

export default function Diagrams() {
  return (
    <ReactFlowProvider>
        <DiagramContent />
    </ReactFlowProvider>
  );
} 
===========================================
<pages/NotFound.jsx>
===========================================
const NotFound = () => {
  return (
    <div>
      <h1>404 - Page Not Found</h1>
    </div>
  );
};

export default NotFound; 
===========================================
<pages/Settings.jsx>
===========================================
import { useState, useEffect } from 'react';
import { User, CreditCard, Database, Plug, ChevronRight, Bell, Moon, Sun, Globe } from 'lucide-react';
import { Body1, Body2, Caption } from '../components/common/Typography';
import Button from '../components/common/Button';
import Input from '../components/common/Input';
import Switch from '../components/common/Switch';
import DatabaseConnectionForm from '../components/settings/DatabaseConnectionForm';
import { useApi } from '../contexts/ApiContext';

const SECTIONS = {
  USER: 'user',
  INTEGRATIONS: 'integrations',
  DATA_SOURCES: 'data-sources',
  BILLING: 'billing'
};

const Settings = () => {
  const [activeSection, setActiveSection] = useState(SECTIONS.USER);
  const [darkMode, setDarkMode] = useState(false);
  const [notifications, setNotifications] = useState(true);
  const [language, setLanguage] = useState('en');
  const [plan] = useState('free');
  const [connections, setConnections] = useState([]);
  const [showForm, setShowForm] = useState(false);
  const api = useApi();

  // Load connections when component mounts
  useEffect(() => {
    const loadConnections = async () => {
      const result = await api.storage.listConnections();
      if (result.success) {
        setConnections(result.data || []);
      }
    };
    loadConnections();
  }, []);

  const renderContent = () => {
    switch (activeSection) {
      case SECTIONS.USER:
        return (
          <div className="space-y-6">
            <div>
              <Body1 className="font-bold">User Settings</Body1>
              <Caption className="text-slate-500">Manage your account preferences</Caption>
            </div>

            <div className="bg-white dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700 divide-y divide-slate-200 dark:divide-slate-700">
              {/* Dark Mode */}
              <div className="p-4 flex items-center justify-between">
                <div className="flex items-center gap-2">
                  {darkMode ? <Moon size={20} /> : <Sun size={20} />}
                  <div>
                    <Body2 className="font-medium">Dark Mode</Body2>
                    <Caption className="text-slate-500">Toggle dark mode theme</Caption>
                  </div>
                </div>
                <Switch checked={darkMode} onChange={setDarkMode} />
              </div>

              {/* Notifications */}
              <div className="p-4 flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Bell size={20} />
                  <div>
                    <Body2 className="font-medium">Notifications</Body2>
                    <Caption className="text-slate-500">Manage notification preferences</Caption>
                  </div>
                </div>
                <Switch checked={notifications} onChange={setNotifications} />
              </div>

              {/* Language */}
              <div className="p-4 flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Globe size={20} />
                  <div>
                    <Body2 className="font-medium">Language</Body2>
                    <Caption className="text-slate-500">Select your preferred language</Caption>
                  </div>
                </div>
                <select
                  value={language}
                  onChange={(e) => setLanguage(e.target.value)}
                  className="px-3 py-2 rounded-md border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800"
                >
                  <option value="en">English</option>
                  <option value="es">Español</option>
                  <option value="fr">Français</option>
                </select>
              </div>
            </div>
          </div>
        );

      case SECTIONS.INTEGRATIONS:
        return (
          <div className="space-y-6">
            <div>
              <Body1 className="font-bold">Integrations</Body1>
              <Caption className="text-slate-500">Connect your external services</Caption>
            </div>

            <div className="bg-white dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700 divide-y divide-slate-200 dark:divide-slate-700">
              {['GitHub', 'Slack', 'Google Drive'].map((integration) => (
                <div key={integration} className="p-4 flex items-center justify-between">
                  <div>
                    <Body2 className="font-medium">{integration}</Body2>
                    <Caption className="text-slate-500">
                      {`Connect your ${integration} account`}
                    </Caption>
                  </div>
                  <Button variant="light">Connect</Button>
                </div>
              ))}
            </div>
          </div>
        );

      case SECTIONS.DATA_SOURCES:
        return (
          <div className="space-y-6">
            <div className="flex items-center justify-between">
              <div>
                <Body1 className="font-bold">Data Sources</Body1>
                <Caption className="text-slate-500">Manage your database connections</Caption>
              </div>
              {!showForm && (
                <Button color="purple" onClick={() => setShowForm(true)}>
                  Add Connection
                </Button>
              )}
            </div>

            {showForm ? (
              <div className="bg-white dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700 p-4">
                <DatabaseConnectionForm 
                  onSubmit={async (connectionData) => {
                    console.log('Submitting connection data:', {
                      ...connectionData,
                      password: connectionData.password ? '[REDACTED]' : undefined
                    });
                    try {
                      const result = await api.storage.saveConnection(connectionData);
                      console.log('Save result:', result);
                      if (result.success) {
                        setShowForm(false);
                        // Refresh connections list
                        const listResult = await api.storage.listConnections();
                        if (listResult.success) {
                          setConnections(listResult.data || []);
                        }
                      }
                    } catch (error) {
                      console.error('Failed to save connection:', error);
                    }
                  }}
                  onCancel={() => setShowForm(false)}
                />
              </div>
            ) : null}

            {/* List existing connections */}
            <div className="bg-white dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700 divide-y divide-slate-200 dark:divide-slate-700">
              {connections.length === 0 ? (
                <div className="p-4 text-center text-slate-500">
                  No connections configured
                </div>
              ) : (
                connections.map((connection) => (
                  <div key={connection.id} className="p-4 flex items-center justify-between">
                    <div>
                      <Body2 className="font-medium">{connection.name}</Body2>
                      <Caption className="text-slate-500">
                        {connection.type} • {connection.host || connection.file}
                      </Caption>
                    </div>
                    <div className="flex items-center gap-2">
                      <Button variant="light" onClick={() => {
                        setShowForm(true);
                        // Set form data for editing
                      }}>
                        Edit
                      </Button>
                      <Button 
                        variant="light" 
                        color="red"
                        onClick={async () => {
                          const result = await api.storage.deleteConnection(connection.id);
                          if (result.success) {
                            setConnections(prev => prev.filter(c => c.id !== connection.id));
                          }
                        }}
                      >
                        Delete
                      </Button>
                    </div>
                  </div>
                ))
              )}
            </div>
          </div>
        );

      case SECTIONS.BILLING:
        return (
          <div className="space-y-6">
            <div>
              <Body1 className="font-bold">Billing</Body1>
              <Caption className="text-slate-500">Manage your subscription</Caption>
            </div>

            <div className="bg-white dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700 p-4 space-y-4">
              <div className="flex items-center justify-between">
                <div>
                  <Body2 className="font-medium">Current Plan</Body2>
                  <Caption className="text-slate-500">
                    {plan === 'free' ? 'Free Tier' : 'Premium Plan'}
                  </Caption>
                </div>
                {plan === 'free' && (
                  <Button color="purple">Upgrade to Premium</Button>
                )}
              </div>
            </div>
          </div>
        );
    }
  };

  return (
    <div className="flex h-full">
      {/* Sidebar */}
      <div className="w-64 border-r border-slate-200 dark:border-slate-700 p-4">
        <div className="space-y-1">
          {[
            { id: SECTIONS.USER, icon: User, label: 'User' },
            { id: SECTIONS.INTEGRATIONS, icon: Plug, label: 'Integrations' },
            { id: SECTIONS.DATA_SOURCES, icon: Database, label: 'Data Sources' },
            { id: SECTIONS.BILLING, icon: CreditCard, label: 'Billing' }
          ].map(({ id, icon: Icon, label }) => (
            <button
              key={id}
              onClick={() => setActiveSection(id)}
              className={`
                w-full px-3 py-2 rounded-md flex items-center gap-2
                ${activeSection === id 
                  ? 'bg-purple-50 dark:bg-purple-900/20 text-purple-600 dark:text-purple-400' 
                  : 'hover:bg-slate-100 dark:hover:bg-slate-800'}
              `}
            >
              <Icon size={20} />
              <span>{label}</span>
            </button>
          ))}
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 p-6 overflow-auto">
        {renderContent()}
      </div>
    </div>
  );
};

export default Settings; 
===========================================
<utils/formatter.js>
===========================================
import xml from './xml';

/**
 * Standard response format for all nodes
 * @param {boolean} success - Whether the operation was successful
 * @param {*} data - The data payload
 * @param {Error|string} [error] - Optional error message or object
 * @param {string} [sourceId] - ID of the node that generated this response
 * @returns {Object} Standardized response object
 */
const standardResponse = (success, data, error = null, sourceId = null) => {
  // If data is an object with status, headers, data structure, use it directly
  if (data && typeof data === 'object' && 'status' in data) {
    return {
      success,
      response: {
        status: data.status,
        headers: data.headers || {},
        data: data.data
      },
      error,
      source_id: sourceId
    };
  }

  // Otherwise wrap the data
  return {
    success,
    response: data,
    error,
    source_id: sourceId
  };
};

/**
 * Creates an error response
 * @param {Error|string} error - Error message or object
 * @param {string} [sourceId] - ID of the node that generated this error
 * @returns {Object} Standardized error response
 */
const errorResponse = (error, sourceId = null) => {
  return standardResponse(
    false, 
    null, 
    error instanceof Error ? error.message : error,
    sourceId
  );
};

/**
 * Processes input data into a consistent format
 * @param {*} input - Raw input data
 * @returns {Object} Standardized data object
 */
const processInput = (input) => {
  // If input is already in standard format, return it
  if (input && typeof input === 'object' && 'success' in input) {
    return input;
  }

  try {
    // Handle raw XML string
    if (typeof input === 'string' && input.trim().startsWith('<')) {
      try {
        const xmlDoc = xml.parse(input);
        const jsonData = xml.toObject(xmlDoc);
        return standardResponse(true, jsonData);
      } catch (error) {
        console.warn('XML parsing failed:', error);
        return standardResponse(true, input);
      }
    }

    // Handle regular data
    return standardResponse(true, input);

  } catch (error) {
    return errorResponse(error.message);
  }
};

/**
 * Extracts the actual data from a standardized response
 * @param {Object} input - Standardized input object
 * @returns {*} The actual data payload
 */
const extractData = (input) => {
  if (input && typeof input === 'object') {
    if ('success' in input && 'response' in input) {
      return input.response;
    }
    return input;
  }
  return input;
};

/**
 * Checks if input is in standard format
 * @param {*} input - Input to check
 * @returns {boolean} Whether input is in standard format
 */
const isStandardFormat = (input) => {
  return input && 
         typeof input === 'object' && 
         'success' in input && 
         'response' in input && 
         'error' in input;
};

export default {
  standardResponse,
  errorResponse,
  processInput,
  extractData,
  isStandardFormat
}; 
===========================================
<utils/graphUtils.js>
===========================================
export const findRootNodes = (nodes, edges) => {
  const nodesWithIncoming = new Set(edges.map(edge => edge.target));
  return nodes.filter(node => !nodesWithIncoming.has(node.id));
};

export const findNextNodes = (nodeId, edges, nodes) => {
  // Ensure edges is an array
  if (!Array.isArray(edges)) {
    console.warn('Edges is not an array:', edges);
    return [];
  }

  // Find all edges where this node is the source
  const connectedEdges = edges.filter(edge => edge.source === nodeId);
  
  // Get the target nodes for these edges
  return connectedEdges.map(edge => {
    const targetNode = nodes.find(node => node.id === edge.target);
    return targetNode;
  }).filter(Boolean); // Remove any undefined nodes
};

export const findPreviousNodes = (nodeId, edges, nodes) => {
  // Ensure edges is an array
  if (!Array.isArray(edges)) {
    console.warn('Edges is not an array:', edges);
    return [];
  }

  // Find all edges where this node is the target
  const connectedEdges = edges.filter(edge => edge.target === nodeId);
  
  // Get the source nodes for these edges
  return connectedEdges.map(edge => {
    const sourceNode = nodes.find(node => node.id === edge.source);
    return sourceNode;
  }).filter(Boolean); // Remove any undefined nodes
}; 
===========================================
<utils/index.js>
===========================================
import { clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

/**
 * Merge class names with Tailwind CSS classes
 * @param  {...string} inputs - Class names to merge
 * @returns {string} - Merged class names
 */
export function cn(...inputs) {
  return twMerge(clsx(inputs));
}

/**
 * Generate a unique ID
 * @returns {string} - Unique ID
 */
export function generateId() {
  return Math.random().toString(36).substring(2, 9);
}

/**
 * Format a date string
 * @param {string} date - Date string
 * @returns {string} - Formatted date
 */
export function formatDate(date) {
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });
} 
===========================================
<utils/jq.js>
===========================================
class JQParser {
  evaluate(path, data) {
    if (!path || !data) {
      throw new Error('Path and data are required');
    }

    // Handle empty path
    if (path.trim() === '') {
      return data;
    }

    // Split path into segments
    const segments = this.tokenizePath(path);
    let result = data;

    try {
      // Process each path segment
      for (const segment of segments) {
        result = this.evaluateSegment(segment, result);
      }

      return result;
    } catch (error) {
      throw new Error(`Error evaluating path '${path}': ${error.message}`);
    }
  }

  tokenizePath(path) {
    // Split on dots while preserving array operations
    const tokens = [];
    let currentToken = '';
    let inBrackets = 0;

    for (let i = 0; i < path.length; i++) {
      const char = path[i];
      
      if (char === '[') {
        inBrackets++;
      } else if (char === ']') {
        inBrackets--;
      }

      if (char === '.' && inBrackets === 0) {
        if (currentToken) {
          tokens.push(currentToken);
          currentToken = '';
        }
      } else {
        currentToken += char;
      }
    }

    if (currentToken) {
      tokens.push(currentToken);
    }

    return tokens;
  }

  evaluateSegment(segment, data) {
    // Handle array operations (e.g., data[].id)
    if (segment.endsWith('[]')) {
      const arrayProp = segment.slice(0, -2);
      if (!data || !(arrayProp in data)) {
        throw new Error(`Property '${arrayProp}' not found`);
      }
      if (!Array.isArray(data[arrayProp])) {
        throw new Error(`Expected array at '${arrayProp}'`);
      }
      return data[arrayProp];
    }

    // Handle array mapping (e.g., id after data[])
    if (Array.isArray(data)) {
      return data.map(item => {
        if (!(segment in item)) {
          throw new Error(`Property '${segment}' not found in array item`);
        }
        return item[segment];
      });
    }

    // Handle array index access (e.g., data[0])
    if (segment.includes('[') && segment.includes(']')) {
      const [prop, indexExpr] = segment.split('[');
      const index = parseInt(indexExpr.replace(']', ''), 10);

      if (!data || !(prop in data)) {
        throw new Error(`Property '${prop}' not found`);
      }

      if (!Array.isArray(data[prop])) {
        throw new Error(`Expected array at '${prop}'`);
      }

      if (isNaN(index) || index < 0 || index >= data[prop].length) {
        throw new Error(`Invalid array index: ${indexExpr}`);
      }

      return data[prop][index];
    }

    // Handle regular object property access
    if (!data || typeof data !== 'object') {
      throw new Error(`Cannot access property '${segment}' of ${data}`);
    }

    if (!(segment in data)) {
      throw new Error(`Property '${segment}' not found`);
    }

    return data[segment];
  }
}

export default JQParser;
===========================================
<utils/regex.js>
===========================================
/**
 * A utility for safe regex operations
 */

// Maximum time (in milliseconds) to allow a regex operation to run
const REGEX_TIMEOUT = 1000;

// Maximum input length to prevent catastrophic backtracking
const MAX_INPUT_LENGTH = 1000000; // 1MB

// Maximum pattern length
const MAX_PATTERN_LENGTH = 1000;

/**
 * Predefined safe patterns for common use cases
 */
export const PATTERNS = {
  // Text extraction
  WORDS: '\\w+',
  SENTENCES: '[^.!?]+[.!?]',
  PARAGRAPHS: '\\n\\s*\\n',
  
  // Data formats
  EMAIL: '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}',
  URL: 'https?://[\\w\\d.-]+\\.[a-zA-Z]{2,}(?:/[\\w\\d./-]*)*',
  IP_ADDRESS: '\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b',
  DATE_ISO: '\\d{4}-\\d{2}-\\d{2}',
  TIME_24H: '(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d',
  
  // Common formats
  PHONE_BASIC: '\\+?\\d{10,}',
  ZIPCODE_US: '\\d{5}(?:-\\d{4})?',
  
  // Programming
  JSON_PROPS: '"([^"]+)":',
  HTML_TAGS: '<([^>]+)>',
  COMMENTS_LINE: '\\/\\/.*$',
  COMMENTS_BLOCK: '\\/\\*[\\s\\S]*?\\*\\/',
};

/**
 * Error class for regex timeouts
 */
class RegexTimeoutError extends Error {
  constructor(message = 'Regex evaluation timed out') {
    super(message);
    this.name = 'RegexTimeoutError';
  }
}

/**
 * Validates a regex pattern for safety
 */
function validatePattern(pattern) {
  if (!pattern) {
    throw new Error('Regex pattern is required');
  }
  
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new Error(`Pattern exceeds maximum length of ${MAX_PATTERN_LENGTH} characters`);
  }
}

/**
 * Validates input text length
 */
function validateInput(input) {
  if (input.length > MAX_INPUT_LENGTH) {
    throw new Error(`Input exceeds maximum length of ${MAX_INPUT_LENGTH} characters`);
  }
}

/**
 * Executes a regex operation with a timeout
 */
function withTimeout(operation) {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      reject(new RegexTimeoutError());
    }, REGEX_TIMEOUT);

    try {
      const result = operation();
      clearTimeout(timeoutId);
      resolve(result);
    } catch (error) {
      clearTimeout(timeoutId);
      reject(error);
    }
  });
}

/**
 * Safely executes a regex match operation
 * @param {string} pattern - The regex pattern
 * @param {string} input - The input text
 * @param {string} flags - Regex flags (default: 'g')
 * @returns {Promise<Object>} Match results
 */
export async function analyze(pattern, input, flags = 'g') {
  validatePattern(pattern);
  validateInput(input);
  
  return withTimeout(() => {
    try {
      const regex = new RegExp(pattern, flags);
      const matches = [];
      let match;

      while ((match = regex.exec(input)) !== null) {
        matches.push(match[0]);  // Just store the matched text
        
        // Prevent infinite loops
        if (match.index === regex.lastIndex) {
          regex.lastIndex++;
        }
      }

      return {
        success: true,
        matches
      };
    } catch (error) {
      return {
        success: false,
        matches: []
      };
    }
  });
}

export const regex = {
  PATTERNS,
  analyze
};

export default regex; 
===========================================
<utils/storageUtils.js>
===========================================
// storageUtils.js
import { openDB } from 'idb';

const DB_NAME = 'workflow_db';
const STORE_NAME = 'workflow_store';
const DB_VERSION = 1;

export const DEFAULT_STORAGE = {
  type: 'memory',
  data: new Map()
};

export const initStorage = async () => {
  // First try IndexedDB
  try {
    const db = await openDB(DB_NAME, DB_VERSION, {
      upgrade(db) {
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME);
        }
      },
    });
    
    // Test write to verify we can actually use IndexedDB
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    await store.put({ test: 'test' }, 'test_key');
    await tx.done;
    
    return {
      type: 'indexedDB',
      db
    };
  } catch (error) {
    console.log('IndexedDB not available, falling back to localStorage:', error);
    
    // Test localStorage
    try {
      localStorage.setItem('test', 'test');
      localStorage.removeItem('test');
      return {
        type: 'localStorage'
      };
    } catch (error) {
      console.warn('Neither IndexedDB nor localStorage are available:', error);
      return DEFAULT_STORAGE;
    }
  }
};

export const loadState = async (storage = DEFAULT_STORAGE) => {
  try {
    let savedState = null;
    
    switch (storage.type) {
      case 'indexedDB':
        const tx = storage.db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        savedState = await store.get('workflow_data');
        break;
        
      case 'localStorage':
        const data = localStorage.getItem('workflow_data');
        savedState = data ? JSON.parse(data) : null;
        break;
      
      case 'memory':
        savedState = storage.data.get('workflow_data');
        break;
    }
    
    // If we have saved state, ensure all expected properties exist
    if (savedState) {
      savedState.nodes = savedState.nodes || [];
      savedState.edges = savedState.edges || [];
      savedState.nodeCounter = savedState.nodeCounter || {};
      savedState.nodeSequence = savedState.nodeSequence || {};
    }
    
    return savedState;
  } catch (error) {
    console.error('Failed to load state:', error);
    return null;
  }
};

export const saveState = async (storage = DEFAULT_STORAGE, state) => {
  if (!state) return;
  
  try {
    const cleanState = cleanStateForStorage(state);
    
    switch (storage.type) {
      case 'indexedDB':
        const tx = storage.db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        await store.put(cleanState, 'workflow_data');
        await tx.done;
        break;
        
      case 'localStorage':
        localStorage.setItem('workflow_data', JSON.stringify(cleanState));
        break;
        
      case 'memory':
        storage.data.set('workflow_data', cleanState);
        break;
    }
  } catch (error) {
    console.error('Failed to save state:', error);
  }
};

export const clearState = async (storage = DEFAULT_STORAGE) => {
  try {
    switch (storage.type) {
      case 'indexedDB':
        const tx = storage.db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        await store.delete('workflow_data');
        await tx.done;
        break;
        
      case 'localStorage':
        localStorage.removeItem('workflow_data');
        break;
        
      case 'memory':
        storage.data.delete('workflow_data');
        break;
    }
  } catch (error) {
    console.error('Failed to clear state:', error);
  }
};

// Helper functions for cleaning data
const cleanNodeData = (node) => {
  const cleanData = { ...node };
  if (cleanData.data) {
    Object.keys(cleanData.data).forEach(key => {
      if (typeof cleanData.data[key] === 'function') {
        delete cleanData.data[key];
      }
    });
  }
  delete cleanData.dragHandle;
  delete cleanData.dragging;
  delete cleanData.selected;
  return cleanData;
};

const cleanEdgeData = (edge) => {
  const cleanData = { ...edge };
  delete cleanData.selected;
  delete cleanData.updatable;
  return cleanData;
};

const cleanStateForStorage = (state) => {
  const cleanState = { ...state };
  if (cleanState.nodes) {
    cleanState.nodes = cleanState.nodes.map(cleanNodeData);
  }
  if (cleanState.edges) {
    cleanState.edges = cleanState.edges.map(cleanEdgeData);
  }
  Object.keys(cleanState).forEach(key => {
    if (typeof cleanState[key] === 'function') {
      delete cleanState[key];
    }
  });
  return cleanState;
};
===========================================
<utils/xml.js>
===========================================
import {convertXML} from 'simple-xml-to-json';
/**
 * Parse XML string into a DOM Document
 * @param {string} xmlString - The XML string to parse
 * @returns {Document} The parsed XML document
 */
export function parseXML(xmlString) {
  try {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
    
    // Check for parsing errors
    const parseError = xmlDoc.querySelector('parsererror');
    if (parseError) {
      throw new Error(parseError.textContent);
    }
    
    return xmlDoc;
  } catch (error) {
    console.log('XML parsing error:', xmlString);
    throw new Error(`XML parsing error: ${error.message}`);
  }
}

/**
 * Evaluate an XPath expression against an XML document
 * @param {string} xpath - The XPath expression
 * @param {Document|Node} xmlNode - The XML document or node to query
 * @param {string} returnType - The type of result to return ('string', 'number', 'boolean', 'nodes')
 * @returns {string|number|boolean|Node[]} The query result
 */
export function evaluateXPath(xpath, xmlNode, returnType = 'nodes') {
  try {
    const resolver = xmlNode.createNSResolver(xmlNode.documentElement);
    let result;

    switch (returnType) {
      case 'string':
        result = xmlNode.evaluate(
          xpath,
          xmlNode,
          resolver,
          XPathResult.STRING_TYPE,
          null
        );
        return result.stringValue;

      case 'number':
        result = xmlNode.evaluate(
          xpath,
          xmlNode,
          resolver,
          XPathResult.NUMBER_TYPE,
          null
        );
        return result.numberValue;

      case 'boolean':
        result = xmlNode.evaluate(
          xpath,
          xmlNode,
          resolver,
          XPathResult.BOOLEAN_TYPE,
          null
        );
        return result.booleanValue;

      case 'nodes':
        result = xmlNode.evaluate(
          xpath,
          xmlNode,
          resolver,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
          null
        );
        const nodes = [];
        for (let i = 0; i < result.snapshotLength; i++) {
          nodes.push(result.snapshotItem(i));
        }
        return nodes;

      default:
        throw new Error(`Unsupported return type: ${returnType}`);
    }
  } catch (error) {
    throw new Error(`XPath evaluation error: ${error.message}`);
  }
}

/**
 * Convert XML nodes to a JavaScript object/array
 * @param {Node|Node[]} nodes - The XML node(s) to convert
 * @returns {object|array} The converted JavaScript object/array
 */
export function xmlNodesToObject(nodes) {
  if (Array.isArray(nodes)) {
    return nodes.map(node => nodeToObject(node));
  }
  return nodeToObject(nodes);
}

/**
 * Convert a single XML node to a JavaScript object
 * @param {Node} node - The XML node to convert
 * @returns {object|string} The converted JavaScript object or string
 */
function nodeToObject(node) {
  // Handle text nodes
  if (node.nodeType === Node.TEXT_NODE) {
    const text = node.textContent.trim();
    return text || undefined;
  }

  // Handle element nodes
  if (node.nodeType === Node.ELEMENT_NODE) {
    const obj = {};
    
    // Add attributes if present
    if (node.attributes.length > 0) {
      obj['@attributes'] = {};
      for (const attr of node.attributes) {
        obj['@attributes'][attr.name] = attr.value;
      }
    }

    // Process child nodes
    for (const child of node.childNodes) {
      const childResult = nodeToObject(child);
      if (childResult !== undefined) {
        const name = child.nodeName;
        if (name === '#text') {
          // If it's just text content, assign it directly
          if (Object.keys(obj).length === 0) {
            return childResult;
          }
          obj['#text'] = childResult;
        } else {
          // Handle multiple children with same name
          if (obj[name]) {
            if (!Array.isArray(obj[name])) {
              obj[name] = [obj[name]];
            }
            obj[name].push(childResult);
          } else {
            obj[name] = childResult;
          }
        }
      }
    }

    return obj;
  }

  return undefined;
}

export function to_json(xmlString) {
  return convertXML(xmlString);
}

function simplifyXmlStructure(obj) {
  console.log('simplifyXmlStructure - obj:', obj);
  // Handle arrays of children
  if (obj && obj.children && Array.isArray(obj.children)) {
    // Convert children array to object
    const result = obj.children.reduce((acc, child) => {
      const key = Object.keys(child)[0];
      
      // If the child has its own children, recursively process them
      if (child[key].children) {
        const processedChild = simplifyXmlStructure(child[key]);
        
        // If we already have this key, make it an array
        if (acc[key]) {
          if (!Array.isArray(acc[key])) {
            acc[key] = [acc[key]];
          }
          acc[key].push(processedChild);
        } else {
          acc[key] = processedChild;
        }
      } else if (child[key].content) {
        // If it's a leaf node with content, just get the content
        acc[key] = child[key].content;
      }
      
      return acc;
    }, {});

    return result;
  }

  // If it's an object but not a children array
  if (obj && typeof obj === 'object') {
    // If it has content, return the content
    if ('content' in obj) {
      return obj.content;
    }

    // Otherwise process each property
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = simplifyXmlStructure(value);
    }
    return result;
  }

  return obj;
}

// Update the toObject function to use the new simplifier
function toObject(xmlDoc) {
  // Your existing XML to initial object conversion
  const rawObj = xmlNodesToObject(xmlDoc.documentElement.childNodes);
  
  // Simplify the structure
  const simplified = simplifyXmlStructure(rawObj);
  
  // If posts is not an array but should be, wrap it
  if (simplified.posts && simplified.posts.post && !Array.isArray(simplified.posts)) {
    simplified.posts = [simplified.posts];
  }
  
  return simplified;
}

export const xml = {
  parse: parseXML,
  evaluate: evaluateXPath,
  toObject: toObject,
  to_json: to_json
};

export default xml; 
