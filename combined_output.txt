===========================================
<main/handlers/authHandlers.js>
===========================================
import authService from '../services/authService';
import database from '../services/databaseService';

export const authHandlers = {
  'auth:check-setup': async () => {
    try {
      const result = await authService.isSetupComplete();
      console.log('Setup check result:', result);
      return result;
    } catch (error) {
      console.error('Setup check failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  },

  'auth:setup': async (event, setupData) => {
    console.log('Auth Handler - Setup data received:', JSON.stringify(setupData, null, 2));
    
    try {
      // Validate the complete data structure
      if (!setupData || typeof setupData !== 'object') {
        console.error('Auth Handler - Invalid data structure:', setupData);
        return {
          success: false,
          error: 'Invalid setup data'
        };
      }

      // Validate database configuration
      if (setupData.database) {
        if (!setupData.database.type) {
          console.error('Auth Handler - Missing database type');
          return {
            success: false,
            error: 'Database type is required'
          };
        }

        // Validate additional database fields based on type
        if (setupData.database.type !== 'sqlite') {
          const requiredFields = ['host', 'port', 'database', 'username', 'password'];
          const missingFields = requiredFields.filter(field => !setupData.database[field]);
          
          if (missingFields.length > 0) {
            console.error('Auth Handler - Missing database fields:', missingFields);
            return {
              success: false,
              error: `Missing required database fields: ${missingFields.join(', ')}`
            };
          }
        }

        // Test database connection
        try {
          const testResult = await database.testConnection(setupData.database);
          if (!testResult.success) {
            console.error('Auth Handler - Database connection test failed:', testResult.error);
            return testResult;
          }
        } catch (error) {
          console.error('Auth Handler - Database connection test error:', error);
          return {
            success: false,
            error: `Database connection failed: ${error.message}`
          };
        }
      }

      // Validate user data
      if (setupData.user) {
        if (!setupData.user.username || !setupData.user.password) {
          console.error('Auth Handler - Missing user credentials');
          return {
            success: false,
            error: 'Username and password are required'
          };
        }

        // Validate username format
        if (!/^[a-zA-Z0-9_-]{3,}$/.test(setupData.user.username)) {
          return {
            success: false,
            error: 'Username must be at least 3 characters and contain only letters, numbers, underscores, and hyphens'
          };
        }

        // Validate password strength
        if (setupData.user.password.length < 8) {
          return {
            success: false,
            error: 'Password must be at least 8 characters long'
          };
        }
      }

      // If we have both database and user data, perform the complete setup
      if (setupData.database && setupData.user) {
        console.log('Auth Handler - Performing complete setup');
        const result = await authService.setup({
          database: setupData.database,
          user: {
            username: setupData.user.username,
            password: setupData.user.password
          }
        });

        console.log('Auth Handler - Setup completed:', {
          success: result.success,
          error: result.error || null
        });

        return result;
      }

      console.error('Auth Handler - Incomplete setup data');
      return {
        success: false,
        error: 'Both database configuration and user credentials are required'
      };

    } catch (error) {
      console.error('Auth Handler - Setup failed:', error);
      return {
        success: false,
        error: error.message || 'Setup failed'
      };
    }
  },

  'auth:login': async (event, credentials) => {
    try {
      console.log('Auth Handler - Login attempt for user:', credentials?.username);

      if (!credentials?.username || !credentials?.password) {
        console.error('Auth Handler - Missing login credentials');
        return {
          success: false,
          error: 'Username and password are required'
        };
      }

      const result = await authService.login(credentials.username, credentials.password);
      
      console.log('Auth Handler - Login result:', {
        success: result.success,
        userId: result.success ? result.user?.id : null
      });

      return result;
    } catch (error) {
      console.error('Auth Handler - Login failed:', error);
      return {
        success: false,
        error: error.message || 'Login failed'
      };
    }
  }
};
===========================================
<main/handlers/connectionHandlers.js>
===========================================
import database from '../services/databaseService';

export const connectionHandlers = {
  'connection:save': async (_, connectionData) => {
    try {
      console.log('Connection handler: saving connection:', {
        ...connectionData,
        config: connectionData.config ? {
          ...connectionData.config,
          password: connectionData.config.password ? '[REDACTED]' : undefined
        } : undefined
      });

      if (!connectionData?.name || !connectionData?.type) {
        throw new Error('Connection name and type are required');
      }

      const result = await database.saveConnection(connectionData);
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to save connection');
      }

      return { success: true, data: result.id };
    } catch (error) {
      console.error('Failed to save connection:', error);
      return { success: false, error: error.message };
    }
  },

  'connection:list': async () => {
    try {
      const connections = await database.listConnections();
      return { success: true, data: connections };
    } catch (error) {
      console.error('Failed to list connections:', error);
      return { success: false, error: error.message };
    }
  },

  'connection:delete': async (_, id) => {
    try {
      await database.deleteConnection(id);
      return { success: true };
    } catch (error) {
      console.error('Failed to delete connection:', error);
      return { success: false, error: error.message };
    }
  },

  'connection:test': async (_, config) => {
    try {
      console.log('Testing connection:', {
        type: config?.type,
        ...config,
        password: config?.password ? '[REDACTED]' : undefined
      });

      if (!config?.type) {
        throw new Error(`Database type is required. Received: ${JSON.stringify(config)}`);
      }

      const result = await database.testConnection(config);
      return result;
    } catch (error) {
      console.error('Connection test failed:', error);
      return { success: false, error: error.message };
    }
  }
}; 
===========================================
<main/handlers/dashboardHandlers.js>
===========================================
// main/handlers/dashboardHandlers.js
import { app } from 'electron';
import fs from 'fs/promises';
import path from 'path';
import { sanitizePath, responder } from '../utils/helpers';

const dashboardsDir = path.join(app.getPath('userData'), 'dashboards');

const ensureDashboardsDir = async () => {
  try {
    await fs.mkdir(dashboardsDir, { recursive: true });
  } catch (error) {
    console.error('Failed to create dashboards directory:', error);
  }
};

export const dashboardHandlers = {
  'dashboard:list': async () => {
    try {
      await ensureDashboardsDir();
      const files = await fs.readdir(dashboardsDir);
      
      const dashboards = await Promise.all(
        files
          .filter(file => file.endsWith('.json'))
          .map(async (file) => {
            const filePath = path.join(dashboardsDir, file);
            if (!filePath.startsWith(dashboardsDir)) {
              throw new Error('Invalid dashboard path');
            }
            const content = await fs.readFile(filePath, 'utf-8');
            return JSON.parse(content);
          })
      );

      return responder(true, dashboards.sort((a, b) => b.updatedAt - a.updatedAt), null);
    } catch (error) {
      console.error('Failed to list dashboards:', error);
      return responder(false, null, error.message);
    }
  },

  'dashboard:save': async (_, dashboard) => {
    try {
      if (!dashboard?.id) {
        throw new Error('Dashboard ID is required');
      }

      await ensureDashboardsDir();
      const sanitizedId = sanitizePath(dashboard.id);
      const filePath = path.join(dashboardsDir, `${sanitizedId}.json`);
      
      if (!filePath.startsWith(dashboardsDir)) {
        throw new Error('Invalid dashboard path');
      }
      
      const dashboardData = {
        ...dashboard,
        updatedAt: Date.now()
      };

      await fs.writeFile(
        filePath,
        JSON.stringify(dashboardData, null, 2),
        'utf-8'
      );

      return responder(true, dashboardData, null);
    } catch (error) {
      console.error('Failed to save dashboard:', error);
      return responder(false, null, error.message);
    }
  },

  'dashboard:delete': async (_, dashboardId) => {
    try {
      if (!dashboardId) {
        throw new Error('Dashboard ID is required');
      }

      await ensureDashboardsDir();
      const filePath = path.join(dashboardsDir, `${dashboardId}.json`);
      
      await fs.unlink(filePath);
      return responder(true, null, null);
    } catch (error) {
      console.error('Failed to delete dashboard:', error);
      return responder(false, null, error.message);
    }
  },

  'dashboard:get': async (_, dashboardId) => {
    try {
      if (!dashboardId) {
        throw new Error('Dashboard ID is required');
      }

      await ensureDashboardsDir();
      const filePath = path.join(dashboardsDir, `${dashboardId}.json`);
      
      const content = await fs.readFile(filePath, 'utf-8');
      return responder(true, JSON.parse(content), null);
    } catch (error) {
      console.error('Failed to get dashboard:', error);
      return responder(false, null, error.message);
    }
  }
}; 
===========================================
<main/handlers/databaseHandlers.js>
===========================================
import database from '../services/databaseService'
import { Sequelize, QueryTypes } from 'sequelize'

// Helper to safely escape values based on their type
function escapeValue(value) {
  if (value === null || value === undefined) {
    return 'NULL';
  }
  if (typeof value === 'number') {
    return value;
  }
  if (typeof value === 'boolean') {
    return value ? 1 : 0;
  }
  // Escape strings using Sequelize's escape function
  return `'${value.toString().replace(/'/g, "''")}'`;
}

// Helper to interpolate template with escaped values
function interpolateQuery(query, input = {}) {
  return query.replace(/\{\{([^}]+)\}\}/g, (match, path) => {
    // Navigate the input object using the path
    const value = path.trim().split('.').reduce((obj, key) => obj?.[key], input);
    return escapeValue(value);
  });
}

// Helper to determine query type
function getQueryType(query) {
  const normalizedQuery = query.trim().toLowerCase();
  if (normalizedQuery.startsWith('select') || normalizedQuery === 'show tables') {
    return QueryTypes.SELECT;
  }
  if (normalizedQuery.startsWith('insert')) {
    return QueryTypes.INSERT;
  }
  if (normalizedQuery.startsWith('update')) {
    return QueryTypes.UPDATE;
  }
  if (normalizedQuery.startsWith('delete')) {
    return QueryTypes.DELETE;
  }
  return QueryTypes.RAW;
}

export const databaseHandlers = {
  'connection:test': async (_, config) => {
    console.log('Testing connection with config:', {
      ...config,
      password: config.password ? '[REDACTED]' : undefined
    });

    try {
      if (!config?.type) {
        throw new Error('Database type is required');
      }

      const sequelize = new Sequelize({
        dialect: config.type,
        host: config.host,
        port: parseInt(config.port),
        database: config.database,
        username: config.username,
        password: config.password,
        ssl: config.ssl,
        logging: false
      });

      await sequelize.authenticate();
      await sequelize.close();
      
      return { success: true };
    } catch (error) {
      console.error('Connection test failed:', error);
      return { 
        success: false, 
        error: error.message 
      };
    }
  },

  'connection:save': async (_, connectionData) => {
    try {
      await database.saveConnection(connectionData)
      return { success: true }
    } catch (error) {
      console.error('Failed to save connection:', error)
      return { 
        success: false, 
        error: error.message 
      }
    }
  },

  'connection:list': async () => {
    try {
      const connections = await database.listConnections()
      return { 
        success: true, 
        data: connections 
      }
    } catch (error) {
      return { 
        success: false, 
        error: error.message 
      }
    }
  },

  'connection:delete': async (_, connectionId) => {
    try {
      await database.deleteConnection(connectionId)
      return { success: true }
    } catch (error) {
      return { 
        success: false, 
        error: error.message 
      }
    }
  },

  'dialog.open-file': async (options) => {
    const { dialog } = require('electron')
    try {
      const result = await dialog.showOpenDialog({
        properties: ['openFile'],
        ...options
      })
      
      return { 
        success: !result.canceled, 
        filePath: result.filePaths[0] 
      }
    } catch (error) {
      return { 
        success: false, 
        error: error.message 
      }
    }
  },

  'nodes.database.query': async (params) => {
    try {
      const { connectionId, query, input = {} } = params;

      // Get the connection details
      const connection = await database.getConnection(connectionId);
      if (!connection) {
        throw new Error(`Connection not found: ${connectionId}`);
      }

      // Handle system queries and interpolation
      let finalQuery = query;
      if (query.trim().toLowerCase() === 'show tables') {
        switch (connection.type) {
          case 'sqlite':
            finalQuery = `SELECT name as table_name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'`;
            break;
          case 'postgres':
            finalQuery = `SELECT tablename as table_name FROM pg_catalog.pg_tables WHERE schemaname != 'pg_catalog' AND schemaname != 'information_schema'`;
            break;
          case 'mysql':
            finalQuery = 'SHOW TABLES';
            break;
          default:
            throw new Error(`Unsupported database type for system query: ${connection.type}`);
        }
      } else {
        finalQuery = interpolateQuery(query, input);
      }

      // Create Sequelize instance
      let sequelize;
      switch (connection.type) {
        case 'sqlite': {
          sequelize = new Sequelize({
            dialect: 'sqlite',
            storage: connection.config.file,
            logging: console.log
          });
          break;
        }
        case 'postgres': {
          sequelize = new Sequelize({
            dialect: 'postgres',
            host: connection.config.host,
            port: connection.config.port,
            database: connection.config.database,
            username: connection.config.username,
            password: connection.config.password,
            ssl: connection.config.ssl,
            logging: console.log
          });
          break;
        }
        case 'mysql': {
          sequelize = new Sequelize({
            dialect: 'mysql',
            host: connection.config.host,
            port: connection.config.port,
            database: connection.config.database,
            username: connection.config.username,
            password: connection.config.password,
            ssl: connection.config.ssl,
            logging: console.log
          });
          break;
        }
        default:
          throw new Error(`Unsupported database type: ${connection.type}`);
      }

      try {
        // Determine query type and execute
        const queryType = getQueryType(finalQuery);

        // For DDL queries (CREATE, ALTER, DROP), use RAW type
        if (finalQuery.trim().toLowerCase().startsWith('create') ||
            finalQuery.trim().toLowerCase().startsWith('alter') ||
            finalQuery.trim().toLowerCase().startsWith('drop')) {
          await sequelize.query(finalQuery, { type: QueryTypes.RAW });
          return {
            success: true,
            data: {
              rowCount: 0,
              rows: [],
              fields: [],
              message: 'Query executed successfully'
            }
          };
        }

        // For other queries
        const [results, metadata] = await sequelize.query(finalQuery, {
          type: queryType
        });

        // Handle different result types
        if (queryType === QueryTypes.SELECT) {
          return {
            success: true,
            data: {
              rowCount: Array.isArray(results) ? results.length : 1,
              rows: Array.isArray(results) ? results : [results],
              fields: metadata?.fields || []
            }
          };
        } else {
          // For INSERT, UPDATE, DELETE
          return {
            success: true,
            data: {
              rowCount: typeof metadata === 'number' ? metadata : 0,
              rows: [],
              fields: [],
              message: `Affected ${typeof metadata === 'number' ? metadata : 0} rows`
            }
          };
        }
      } finally {
        await sequelize.close();
      }
    } catch (error) {
      console.error('Database query failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

// Add this function to handle special queries
function getSystemQuery(query, dbType) {
  const normalizedQuery = query.trim().toLowerCase();
  
  if (normalizedQuery === 'show tables') {
    switch (dbType) {
      case 'sqlite':
        return `SELECT name as table_name FROM sqlite_master WHERE type='table'`;
      case 'postgres':
        return `SELECT tablename as table_name FROM pg_catalog.pg_tables WHERE schemaname != 'pg_catalog' AND schemaname != 'information_schema'`;
      case 'mysql':
        return 'SHOW TABLES';
      default:
        throw new Error(`Unsupported database type for system query: ${dbType}`);
    }
  }
  
  return query;
} 
===========================================
<main/handlers/dialogHandlers.js>
===========================================
import { dialog } from 'electron';
import { writeFile } from 'fs/promises';

export const dialogHandlers = {
  'dialog.open-file': async (event, options) => {
    try {
      const result = await dialog.showOpenDialog(options);
      return {
        success: !result.canceled,
        filePath: result.filePaths[0]
      };
    } catch (error) {
      console.error('Failed to open file dialog:', error);
      return { success: false, error: error.message };
    }
  },

  'dialog.save-file': async (event, options) => {
    try {
      const result = await dialog.showSaveDialog(options);
      
      if (result.canceled) {
        return { success: false };
      }

      // Create empty SQLite database file
      if (result.filePath.endsWith('.db') || 
          result.filePath.endsWith('.sqlite') || 
          result.filePath.endsWith('.sqlite3')) {
        await writeFile(result.filePath, ''); // Creates empty file
      }

      return {
        success: true,
        filePath: result.filePath
      };
    } catch (error) {
      console.error('Failed to save file:', error);
      return { success: false, error: error.message };
    }
  }
}; 
===========================================
<main/handlers/envHandlers.js>
===========================================
import database from '../services/databaseService';
import { responder } from '../utils/helpers';
export const envHandlers = {
  'env:save': async (_, data) => {
    try {
      const { id, ...envData } = data;
      
      let env = await database.models.Environment.findOne({
        where: { id }
      });

      if (env) {
        await env.update(envData);
      } else {
        env = await database.models.Environment.create({
          id,
          ...envData
        });
      }

      return responder(true, {
          id: env.id,
          createdAt: env.createdAt,
          updatedAt: env.updatedAt
        }, null);
    } catch (error) {
      console.error('Failed to save environment:', error);
      return responder(false, null, error.message);
    }
  },

  'env:get': async (_, id) => {
    try {
      const env = await database.models.Environment.findOne({
        where: { id }
      });

      return responder(true, env, null);
    } catch (error) {
      console.error('Failed to get environment:', error);
      return responder(false, null, error.message);
    }
  },

  'env:list': async () => {
    try {
      const environments = await database.models.Environment.findAll();

      return responder(true, environments, null);
    } catch (error) {
      console.error('Failed to list environments:', error);
      return responder(false, null, error.message);
    }
  }
}; 
===========================================
<main/handlers/executionHandlers.js>
===========================================
import { flowExecutionService } from '../services/flowExecutionService';
import { responder } from '../utils/helpers';

export const executionHandlers = {
  'execution:start': async (event, { flowId, nodes, edges, environment, scheduledTime }) => {
    try {
      const executionId = await flowExecutionService.startExecution(flowId, {
        nodes,
        edges,
        environment,
        scheduledTime,
        userId: currentUserId
      });

      return responder(true, { executionId });
    } catch (error) {
      return responder(false, null, error.message);
    }
  },

  'execution:cancel': async (event, executionId) => {
    try {
      await flowExecutionService.cancelExecution(executionId);
      return responder(true);
    } catch (error) {
      return responder(false, null, error.message);
    }
  },

  'execution:get': async (event, executionId) => {
    try {
      const execution = flowExecutionService.getExecution(executionId);
      return responder(true, execution);
    } catch (error) {
      return responder(false, null, error.message);
    }
  },

  'execution:list': async (event, filters) => {
    try {
      const executions = flowExecutionService.listExecutions({
        ...filters,
        userId: currentUserId
      });
      return responder(true, executions);
    } catch (error) {
      return responder(false, null, error.message);
    }
  }
}; 
===========================================
<main/handlers/fileHandlers.js>
===========================================
import { dialog } from 'electron';
import fs from 'fs/promises';
import path from 'path';
import { responder } from '../utils/helpers';

export const fileHandlers = {
  'file:save': async (_, { filePath, data, options = {} }) => {
    try {
      // If no filePath provided, open save dialog
      if (!filePath) {
        const { canceled, filePath: selectedPath } = await dialog.showSaveDialog({
          defaultPath: options.defaultPath,
          filters: options.filters || [
            { name: 'All Files', extensions: ['*'] }
          ]
        });

        if (canceled || !selectedPath) {
          return responder(false, null, 'Save cancelled');
        }

        filePath = selectedPath;
      }

      // Convert data to string if it's an object
      const content = typeof data === 'object' ? JSON.stringify(data, null, 2) : data;
      
      await fs.writeFile(filePath, content, 'utf8');
      
      return responder(true, { filePath });
    } catch (error) {
      console.error('Failed to save file:', error);
      return responder(false, null, error.message);
    }
  },

  'file:open': async (_, options = {}) => {
    try {
      const { canceled, filePaths } = await dialog.showOpenDialog({
        properties: ['openFile'],
        filters: options.filters || [
          { name: 'All Files', extensions: ['*'] }
        ]
      });

      if (canceled || filePaths.length === 0) {
        return responder(false, null, 'Open cancelled');
      }

      const filePath = filePaths[0];
      const content = await fs.readFile(filePath, 'utf8');
      
      // Try to parse JSON if specified
      let data = content;
      if (options.parseJson) {
        try {
          data = JSON.parse(content);
        } catch (e) {
          return responder(false, null, 'Invalid JSON file');
        }
      }

      return responder(true, { filePath, data });
    } catch (error) {
      console.error('Failed to open file:', error);
      return responder(false, null, error.message);
    }
  },

  'file:append': async (_, { filePath, data }) => {
    try {
      if (!filePath) {
        return responder(false, null, 'No file path provided');
      }

      const content = typeof data === 'object' ? JSON.stringify(data) : data;
      await fs.appendFile(filePath, content + '\n', 'utf8');
      
      return responder(true, { filePath });
    } catch (error) {
      console.error('Failed to append to file:', error);
      return responder(false, null, error.message);
    }
  },

  'file:delete': async (_, filePath) => {
    try {
      if (!filePath) {
        return responder(false, null, 'No file path provided');
      }

      await fs.unlink(filePath);
      
      return responder(true, { filePath });
    } catch (error) {
      console.error('Failed to delete file:', error);
      return responder(false, null, error.message);
    }
  },

  'file:select-directory': async (_, options = {}) => {
    try {
      const { canceled, filePaths } = await dialog.showOpenDialog({
        properties: ['openDirectory'],
        defaultPath: options.defaultPath
      });

      if (canceled || filePaths.length === 0) {
        return responder(false, null, 'Directory selection cancelled');
      }

      return responder(true, { directoryPath: filePaths[0] });
    } catch (error) {
      console.error('Failed to select directory:', error);
      return responder(false, null, error.message);
    }
  }
}; 
===========================================
<main/handlers/flowHandlers.js>
===========================================
import { app } from 'electron';
import path from 'path';
import fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';
import database from '../services/databaseService';
import { responder } from '../utils/helpers';

// Create a flows directory in the app's user data folder
const flowsDir = path.join(app.getPath('userData'), 'flows');

const ensureFlowsDir = async () => {
  try {
    await fs.mkdir(flowsDir, { recursive: true });  
    return responder(true, null, null);
  } catch (error) {
    console.error('Failed to create flows directory:', error);
    return responder(false, null, error.message);
  }
};

export const flowHandlers = {
  'flow:save': async (event, flowData) => {
    try {
      if (!flowData || typeof flowData !== 'object') {
        throw new Error('Invalid flow data');
      }

      // Get user from auth service or session
      const userId = event.user.id; // We'll need to set this in main.js

      // Generate ID for new flows
      const flowId = flowData.id || uuidv4();

      // Save flow info to database
      const [flowInfo, created] = await database.models.FlowInfo.upsert({
        id: flowId,
        name: flowData.name,
        description: flowData.description || '',
        user_id: userId
      });

      // Save flow data to file
      const filePath = path.join(flowsDir, `${flowId}.json`);
      const fileData = {
        id: flowId,
        name: flowData.name,
        description: flowData.description,
        nodes: flowData.nodes || [],
        edges: flowData.edges || []
      };

      await fs.writeFile(filePath, JSON.stringify(fileData, null, 2));

      return responder(true, {
        id: flowId,
        name: flowInfo.name,
        description: flowInfo.description,
        created_at: flowInfo.created_at,
        updatedAt: flowInfo.updatedAt
      });
    } catch (error) {
      console.error('Failed to save flow:', error);
      return responder(false, null, error.message);
    }
  },

  'flow:list': async (event) => {
    try {
      const userId = event.user.id;
      
      const flows = await database.models.FlowInfo.findAll({
        where: { user_id: userId },
        order: [['updatedAt', 'DESC']]
      });

      return responder(true, flows);
    } catch (error) {
      console.error('Failed to list flows:', error);
      return responder(false, null, error.message);
    }
  },

  'flow:get': async (event, flowId) => {
    try {
      if (!flowId || typeof flowId !== 'string') {
        return responder(false, null, `Invalid flow ID: ${flowId}`);
      }
    
      const flowInfo = await database.models.FlowInfo.findOne({
        where: { 
          id: flowId
        }
      });

      if (!flowInfo) {
        return responder(false, null, 'Flow not found');
      }

      const filePath = path.join(flowsDir, `${flowId}.json`);
      const content = await fs.readFile(filePath, 'utf-8');
      const flowData = JSON.parse(content);
      
      return responder(true, {
        ...flowData,
        createdAt: flowInfo.createdAt,
        updatedAt: flowInfo.updatedAt
      }, null);
    } catch (error) {
      console.error('Failed to get flow:', error);
      return responder(false, null, error.message);
    }
  },

  'flow:delete': async (event, flowId) => {
    try {
      const flowInfo = await database.models.FlowInfo.findOne({
        where: { 
          id: flowId
        }
      });

      if (!flowInfo) {
        return responder(false, null, 'Flow not found');
      }

      // Delete flow file
      const filePath = path.join(flowsDir, `${flowId}.json`);
      await fs.unlink(filePath);

      // Delete flow info from database
      await flowInfo.destroy();

      return responder(true, null, null);
    } catch (error) {
      console.error('Failed to delete flow:', error);
      return responder(false, null, error.message);
    }
  }
}; 
===========================================
<main/handlers/integrationHandlers.js>
===========================================
import database from '../services/databaseService';
import { responder } from '../utils/helpers';

export const integrationHandlers = {
  'integration:save': async (_, data) => {
    try {
      const { id, config } = data;
      
      // Get or create integration record
      let integration = await database.models.Integration.findOne({
        where: { id }
      });

      if (integration) {
        integration.config = config;
        await integration.save();
      } else {
        integration = await database.models.Integration.create({
          id,
          config
        });
      }

      return responder(true, {
          id: integration.id,
          createdAt: integration.createdAt,
          updatedAt: integration.updatedAt
        }, null);
    } catch (error) {
      console.error('Failed to save integration:', error);
      return responder(false, null, error.message);
    }
  },

  'integration:get': async (_, id) => {
    try {
      const integration = await database.models.Integration.findOne({
        where: { id }
      });

      return responder(true, integration, null);
    } catch (error) {
      console.error('Failed to get integration:', error);
      return responder(false, null, error.message);
    }
  },

  'integration:list': async () => {
    try {
      const integrations = await database.models.Integration.findAll();

      return responder(true, integrations, null);
    } catch (error) {
      console.error('Failed to list integrations:', error);
      return responder(false, null, error.message);
    }
  },

  'integration:delete': async (_, id) => {
    try {
      await database.models.Integration.destroy({
        where: { id }
      });
    return responder(true, null, null);
    } catch (error) {
      console.error('Failed to delete integration:', error);
      return responder(false, null, error.message);
    }
  }
}; 
===========================================
<main/handlers/nodeHandlers.js>
===========================================
import { exec } from 'child_process'
import { promisify } from 'util'
import { readFile, writeFile } from 'fs/promises'
import axios from 'axios'  // Make sure to install axios if not already installed
import { responder } from '../utils/helpers';
const execAsync = promisify(exec)

export const nodeHandlers = {
  'nodes:command:execute': async (_, command, options) => {
    try {
      const {
        workingDirectory = process.cwd(),
        timeout = 30000,
        environmentVars = []
      } = options || {}

      // Prepare environment variables
      const env = { ...process.env }
      for (const envVar of environmentVars) {
        if (envVar.key && envVar.value) {
          env[envVar.key] = envVar.value
        }
      }

      const { stdout, stderr } = await execAsync(command, {
        cwd: workingDirectory,
        env,
        timeout
      })

      return responder(true, { stdout, stderr, command, workingDirectory }, null);
    } catch (error) {
      return responder(false, null, error.message);
    }
  },

  'nodes:file:save': async (_, path, content) => {
    try {
      await writeFile(path, content)
      return responder(true, null, null);
    } catch (error) {
      return responder(false, null, error.message);
    }
  },

  'nodes:file:open': async (_, path) => {
    try {
      const content = await readFile(path, 'utf-8')
      return responder(true, content, null);
    } catch (error) {
      return responder(false, null, error.message);
    }
  },

  'nodes:http:request': async (_, config) => {
    try {
        const {
          method = 'GET',
          url,
          headers = {},
          params = {},
          data = null,
          timeout = 30000,
          validateStatus = null
        } = config

        console.log('HTTP Request structure:', config);
  
        const response = await axios({
          method,
          url,
          headers,
          params,
          data,
          timeout,
          validateStatus
        })
  
        return responder(true, {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers,
            data: response.data
        }, null)
      } catch (error) {
        if (error.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          return responder(false, null, {
              status: error.response.status,
              statusText: error.response.statusText,
              headers: error.response.headers,
              data: error.response.data
          }, null)
        } else if (error.request) {
          // The request was made but no response was received
          return {
            success: false,
            error: {
              message: 'No response received',
              request: error.request
            }
          }
        } else {
          // Something happened in setting up the request
          return responder(false, null, {
              message: error.message
          }, null)
        }
    }
  },

  'nodes:database:query': async (_, connectionId, query, parameters) => {
    try {
      // ... existing database query logic ...
      return responder(true, result, null);
    } catch (error) {
      return responder(false, null, error.message);
    }
  }
} 
===========================================
<main/handlers/nodeTemplateHandlers.js>
===========================================
import { app } from 'electron';
import path from 'path';
import fs from 'fs/promises';

const nodeTemplatesDir = path.join(app.getPath('userData'), 'nodeTemplates');

const ensureNodeTemplatesDir = async () => {
  try {
    await fs.mkdir(nodeTemplatesDir, { recursive: true });
  } catch (error) {
    console.error('Failed to create node templates directory:', error);
  }
};

export const nodeTemplateHandlers = {
  'node-template:save': async (_, template) => {
    try {
      await ensureNodeTemplatesDir();
      
      const templateWithId = {
        ...template,
        id: template.id || Date.now().toString(),
        timestamp: Date.now()
      };
      
      const filePath = path.join(nodeTemplatesDir, `${templateWithId.id}.json`);
      await fs.writeFile(filePath, JSON.stringify(templateWithId, null, 2));
      
      return { success: true, templateId: templateWithId.id };
    } catch (error) {
      console.error('Failed to save node template:', error);
      return { success: false, error: error.message };
    }
  },

  'node-template:list': async () => {
    try {
      await ensureNodeTemplatesDir();
      
      const files = await fs.readdir(nodeTemplatesDir);
      console.log('Template files found:', files);
      
      const templates = [];
      
      for (const file of files) {
        if (file.endsWith('.json')) {
          const filePath = path.join(nodeTemplatesDir, file);
          console.log('Reading template file:', filePath);
          const content = await fs.readFile(filePath, 'utf-8');
          console.log('Template content:', content);
          templates.push(JSON.parse(content));
        }
      }
      
      const sortedTemplates = templates.sort((a, b) => b.timestamp - a.timestamp);
      console.log('Returning templates:', sortedTemplates);
      
      return { 
        success: true, 
        data: sortedTemplates
      };
    } catch (error) {
      console.error('Failed to list node templates:', error);
      return { success: false, error: error.message };
    }
  },

  'node-template:delete': async (_, templateId) => {
    try {
      const filePath = path.join(nodeTemplatesDir, `${templateId}.json`);
      await fs.unlink(filePath);
      return { success: true };
    } catch (error) {
      console.error('Failed to delete node template:', error);
      return { success: false, error: error.message };
    }
  }
}; 
===========================================
<main/handlers/storageHandlers.js>
===========================================
import database from '../services/databaseService'
import { v4 as uuidv4 } from 'uuid'
import { randomUUID } from 'crypto'
import { Client } from 'pg'
import mysql from 'mysql2/promise'
import { open } from 'sqlite'
import sqlite3 from 'sqlite3'
import { readFile, writeFile, mkdir, readdir, unlink } from 'fs/promises'
import path from 'path'
import { app, ipcMain } from 'electron'
import fs from 'fs/promises'
import { setupDashboardHandlers } from './dashboardHandlers'

// Create a flows directory in the app's user data folder
const flowsDir = path.join(app.getPath('userData'), 'flows')
const ensureFlowsDir = async () => {
  try {
    await fs.mkdir(flowsDir, { recursive: true })
  } catch (error) {
    console.error('Failed to create flows directory:', error)
  }
}

// Add to existing storageHandlers object
const nodeTemplatesDir = path.join(app.getPath('userData'), 'nodeTemplates');

const ensureNodeTemplatesDir = async () => {
  try {
    await fs.mkdir(nodeTemplatesDir, { recursive: true });
  } catch (error) {
    console.error('Failed to create node templates directory:', error);
  }
};

export const storageHandlers = {
  'storage.save-flow': async (event, flowData) => {
    try {
      console.log('Main process received flow data:', flowData); // Debug log
      
      await ensureFlowsDir();
      
      // Ensure flowData is an object
      if (!flowData || typeof flowData !== 'object') {
        console.error('Invalid flow data:', flowData); // Debug log
        throw new Error(`Invalid flow data received: ${JSON.stringify(flowData)}`);
      }
      
      // Create a new object with the data
      const flow = {
        id: flowData.id || Date.now().toString(),
        name: flowData.name || 'Untitled Flow',
        description: flowData.description || '',
        nodes: flowData.nodes || [],
        edges: flowData.edges || [],
        timestamp: Date.now()
      };
      
      console.log('Saving flow:', flow); // Debug log
      
      // Save to a JSON file
      const filePath = path.join(flowsDir, `${flow.id}.json`);
      await writeFile(filePath, JSON.stringify(flow, null, 2));
      
      return { success: true, flowId: flow.id };
    } catch (error) {
      console.error('Failed to save flow:', error);
      throw error;
    }
  },

  'storage.list-flows': async (_) => {
    try {
      await ensureFlowsDir()
      
      // Read all JSON files in the flows directory
      const files = await fs.readdir(flowsDir)
      const flows = []
      
      for (const file of files) {
        if (file.endsWith('.json')) {
          const filePath = path.join(flowsDir, file)
          const content = await readFile(filePath, 'utf-8')
          const flowData = JSON.parse(content)
          flows.push({
            id: flowData.id,
            name: flowData.name,
            description: flowData.description,
            timestamp: flowData.timestamp,
            nodes: flowData.nodes,
            edges: flowData.edges
          })
        }
      }
      
      // Sort by timestamp, newest first
      return flows.sort((a, b) => b.timestamp - a.timestamp)
    } catch (error) {
      console.error('Failed to list flows:', error)
      throw error
    }
  },

  'storage.open-flow': async (event, flowId) => {
    try {
      if (!flowId || typeof flowId !== 'string') {
        throw new Error(`Invalid flow ID: ${flowId}`);
      }

      const filePath = path.join(flowsDir, `${flowId}.json`);
      const content = await readFile(filePath, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      console.error('Failed to open flow:', error);
      throw error;
    }
  },

  'storage.delete-flow': async (_, flowId) => {
    try {
      const filePath = path.join(flowsDir, `${flowId}.json`)
      await fs.unlink(filePath)
      return { success: true }
    } catch (error) {
      console.error('Failed to delete flow:', error)
      throw error
    }
  },

  'storage.save-env': async (envData) => {
    try {
      const id = envData.id || uuidv4()
      await database.saveEnv({ ...envData, id })
      return { success: true, data: { id } }
    } catch (error) {
      return { success: false, error: error.message }
    }
  },

  'storage.open-env': async (envId) => {
    try {
      const env = await database.getEnv(envId)
      if (!env) {
        throw new Error('Environment not found')
      }
      return { success: true, data: env }
    } catch (error) {
      return { success: false, error: error.message }
    }
  },

  'storage.list-env': async () => {
    try {
      const envs = await database.listEnv()
      return { success: true, data: envs }
    } catch (error) {
      return { success: false, error: error.message }
    }
  },

  'storage.test-connection': async (event, config) => {
    try {
      // Log the raw input
      console.log('Raw input in main process:', { event, config });
      
      // Log the actual config object
      console.log('Config in main process:', {
        type: config?.type,
        ...config,
        password: config?.password ? '[REDACTED]' : undefined
      });

      // Ensure config is properly structured
      const testConfig = typeof config === 'string' ? JSON.parse(config) : config;

      if (!testConfig?.type) {
        console.error('Missing database type:', testConfig);
        throw new Error(`Database type is required. Received: ${JSON.stringify(testConfig)}`);
      }

      switch (testConfig.type) {
        case 'sqlite': {
          if (!testConfig.file) {
            throw new Error('SQLite database file path is required');
          }

          console.log('Testing SQLite connection:', testConfig.file);
          const db = await open({
            filename: testConfig.file,
            driver: sqlite3.Database
          });
          
          await db.get('SELECT 1');
          await db.close();
          console.log('SQLite connection test successful');
          return { success: true };
        }

        case 'postgres': {
          const client = new Client({
            host: testConfig.host,
            port: parseInt(testConfig.port),
            database: testConfig.database,
            user: testConfig.username,
            password: testConfig.password,
            ssl: testConfig.ssl
          });
          
          await client.connect();
          await client.query('SELECT 1');
          await client.end();
          return { success: true };
        }

        case 'mysql': {
          const connection = await mysql.createConnection({
            host: testConfig.host,
            port: parseInt(testConfig.port),
            database: testConfig.database,
            user: testConfig.username,
            password: testConfig.password,
            ssl: testConfig.ssl
          });
          
          await connection.execute('SELECT 1');
          await connection.end();
          return { success: true };
        }

        default:
          throw new Error(`Unsupported database type: ${testConfig.type}`);
      }
    } catch (error) {
      console.error('Connection test failed in main process:', error);
      return { success: false, error: error.message };
    }
  },

  'storage.save-connection': async (connectionData) => {
    try {
      // Validate input
      if (!connectionData || typeof connectionData !== 'object') {
        console.error('Invalid connection data:', connectionData);
        throw new Error('Invalid connection data format');
      }

      console.log('Storage handler: received connection data:', {
        ...connectionData,
        config: connectionData.config ? {
          ...connectionData.config,
          password: connectionData.config.password ? '[REDACTED]' : undefined
        } : undefined
      });

      // Save to database
      const result = await database.saveConnection(connectionData);
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to save connection');
      }

      return { success: true, data: result.id };
    } catch (error) {
      console.error('Failed to save connection:', error);
      return { success: false, error: error.message };
    }
  },

  'storage.list-connections': async () => {
    try {
      const connections = await database.listConnections();
      return { success: true, data: connections };
    } catch (error) {
      console.error('Failed to list connections:', error);
      return { success: false, error: error.message };
    }
  },

  'storage.delete-connection': async (event, id) => {
    try {
      await database.deleteConnection(id);
      return { success: true };
    } catch (error) {
      console.error('Failed to delete connection:', error);
      return { success: false, error: error.message };
    }
  },

  'storage.save-node-template': async (event, template) => {
    try {
      await ensureNodeTemplatesDir();
      
      const templateWithId = {
        ...template,
        id: template.id || Date.now().toString(),
        timestamp: Date.now()
      };
      
      const filePath = path.join(nodeTemplatesDir, `${templateWithId.id}.json`);
      await fs.writeFile(filePath, JSON.stringify(templateWithId, null, 2));
      
      return { success: true, templateId: templateWithId.id };
    } catch (error) {
      console.error('Failed to save node template:', error);
      return { success: false, error: error.message };
    }
  },

  'storage.list-node-templates': async () => {
    try {
      await ensureNodeTemplatesDir();
      
      const files = await fs.readdir(nodeTemplatesDir);
      console.log('Template files found:', files);
      
      const templates = [];
      
      for (const file of files) {
        if (file.endsWith('.json')) {
          const filePath = path.join(nodeTemplatesDir, file);
          console.log('Reading template file:', filePath);
          const content = await fs.readFile(filePath, 'utf-8');
          console.log('Template content:', content);
          templates.push(JSON.parse(content));
        }
      }
      
      const sortedTemplates = templates.sort((a, b) => b.timestamp - a.timestamp);
      console.log('Returning templates:', sortedTemplates);
      
      return { 
        success: true, 
        data: sortedTemplates
      };
    } catch (error) {
      console.error('Failed to list node templates:', error);
      return { success: false, error: error.message };
    }
  },

  'storage.delete-node-template': async (event, templateId) => {
    try {
      const filePath = path.join(nodeTemplatesDir, `${templateId}.json`);
      await fs.unlink(filePath);
      return { success: true };
    } catch (error) {
      console.error('Failed to delete node template:', error);
      return { success: false, error: error.message };
    }
  },

  'storage.save-integration': async (_, data) => {
    try {
      const { id, config } = data;
      
      // Get or create integration record
      let integration = await database.models.Integration.findOne({
        where: { id }
      });

      if (integration) {
        integration.config = config; // Config is already encrypted from renderer
        await integration.save();
      } else {
        integration = await database.models.Integration.create({
          id,
          config // Config is already encrypted from renderer
        });
      }

      return {
        success: true,
        data: {
          id: integration.id,
          createdAt: integration.createdAt,
          updatedAt: integration.updatedAt
        }
      };
    } catch (error) {
      console.error('Failed to save integration:', error);
      return {
        success: false,
        error: error.message
      };
    }
  },

  'storage.get-integration': async (_, id) => {
    try {
      const integration = await database.models.Integration.findOne({
        where: { id }
      });

      return {
        success: true,
        data: integration
      };
    } catch (error) {
      console.error('Failed to get integration:', error);
      return {
        success: false,
        error: error.message
      };
    }
  },

  'storage.list-integrations': async () => {
    try {
      const integrations = await database.models.Integration.findAll();

      return {
        success: true,
        data: integrations
      };
    } catch (error) {
      console.error('Failed to list integrations:', error);
      return {
        success: false,
        error: error.message
      };
    }
  },

  'storage.delete-integration': async (_, id) => {
    try {
      await database.deleteIntegration(id);
      return { success: true };
    } catch (error) {
      console.error('Failed to delete integration:', error);
      return { success: false, error: error.message };
    }
  }
}

// Register flow storage handlers
export function registerStorageHandlers(ipcMain, db) {
  // ... existing handlers ...

  // List all saved flows
  ipcMain.handle('storage.list-flows', async () => {
    try {
      const flows = await db.models.Flow.findAll({
        order: [['updatedAt', 'DESC']]
      });
      return flows.map(flow => ({
        id: flow.id,
        name: flow.name,
        description: flow.description,
        timestamp: flow.updatedAt,
        data: flow.data
      }));
    } catch (error) {
      console.error('Failed to list flows:', error);
      throw error;
    }
  });

  // Delete a flow
  ipcMain.handle('storage.delete-flow', async (event, flowId) => {
    try {
      const result = await db.models.Flow.destroy({
        where: { id: flowId }
      });
      return { success: true, deletedCount: result };
    } catch (error) {
      console.error('Failed to delete flow:', error);
      throw error;
    }
  });

  ipcMain.handle('storage.save-integration', async (_, data) => {
    try {
      const { id, config } = data;
      
      // Get or create integration record
      let integration = await db.models.Integration.findOne({
        where: { id }
      });

      if (integration) {
        integration.config = config; // Config is already encrypted from renderer
        await integration.save();
      } else {
        integration = await db.models.Integration.create({
          id,
          config // Config is already encrypted from renderer
        });
      }

      return {
        success: true,
        data: {
          id: integration.id,
          createdAt: integration.createdAt,
          updatedAt: integration.updatedAt
        }
      };
    } catch (error) {
      console.error('Failed to save integration:', error);
      return {
        success: false,
        error: error.message
      };
    }
  });

  ipcMain.handle('storage.get-integration', async (_, id) => {
    try {
      const integration = await db.models.Integration.findOne({
        where: { id }
      });

      return {
        success: true,
        data: integration
      };
    } catch (error) {
      console.error('Failed to get integration:', error);
      return {
        success: false,
        error: error.message
      };
    }
  });

  ipcMain.handle('storage.list-integrations', async () => {
    try {
      const integrations = await db.models.Integration.findAll();

      return {
        success: true,
        data: integrations
      };
    } catch (error) {
      console.error('Failed to list integrations:', error);
      return {
        success: false,
        error: error.message
      };
    }
  });
}

// Add initialization function
export async function initializeStorage() {
  await ensureNodeTemplatesDir();
}

// Ensure storage directories exist
const ensureStorageDirs = async () => {
  const flowsPath = path.join(app.getPath('userData'), 'flows');
  await fs.mkdir(flowsPath, { recursive: true });
  return flowsPath;
};

export const setupStorageHandlers = () => {
  // Set up flow storage handlers
  ipcMain.handle('storage:loadFlow', async (_, flowId) => {
    try {
      const flowsPath = await ensureStorageDirs();
      const filePath = path.join(flowsPath, `${flowId}.json`);
      const content = await fs.readFile(filePath, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      console.error('Failed to load flow:', error);
      throw error;
    }
  });

  ipcMain.handle('storage:saveFlow', async (_, flow) => {
    try {
      const flowsPath = await ensureStorageDirs();
      const filePath = path.join(flowsPath, `${flow.id}.json`);
      await fs.writeFile(filePath, JSON.stringify(flow, null, 2), 'utf-8');
      return flow;
    } catch (error) {
      console.error('Failed to save flow:', error);
      throw error;
    }
  });

  ipcMain.handle('storage:listFlows', async () => {
    try {
      const flowsPath = await ensureStorageDirs();
      const files = await fs.readdir(flowsPath);
      const flows = await Promise.all(
        files
          .filter(file => file.endsWith('.json'))
          .map(async (file) => {
            const filePath = path.join(flowsPath, file);
            const content = await fs.readFile(filePath, 'utf-8');
            return JSON.parse(content);
          })
      );
      return flows;
    } catch (error) {
      console.error('Failed to list flows:', error);
      throw error;
    }
  });

  ipcMain.handle('storage:deleteFlow', async (_, flowId) => {
    try {
      const flowsPath = await ensureStorageDirs();
      const filePath = path.join(flowsPath, `${flowId}.json`);
      await fs.unlink(filePath);
      return true;
    } catch (error) {
      console.error('Failed to delete flow:', error);
      throw error;
    }
  });

  // Set up dashboard handlers
  setupDashboardHandlers();
};

module.exports = {
  registerStorageHandlers
}; 
===========================================
<main/handlers/userHandlers.js>
===========================================
import database from '../services/databaseService';
import authService from '../services/authService';

export const userHandlers = {
  'user:get-info': async (event) => {
    try {
      const user = await database.models.User.findOne({
        where: { id: currentUserId },
        attributes: ['id', 'username', 'firstName', 'lastName', 'avatar', 'createdAt', 'updatedAt']
      });

      return {
        success: true,
        data: user,
        error: null
      };
    } catch (error) {
      console.error('Failed to get user info:', error);
      return {
        success: false,
        data: null,
        error: error.message
      };
    }
  },

  'user:update-info': async (event, data) => {
    try {
      const { firstName, lastName, avatar } = data;
      
      const user = await database.models.User.findOne({
        where: { id: currentUserId }
      });

      if (!user) {
        throw new Error('User not found');
      }

      await user.update({
        firstName,
        lastName,
        avatar
      });

      return {
        success: true,
        data: {
          id: user.id,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          avatar: user.avatar,
          createdAt: user.createdAt,
          updatedAt: user.updatedAt
        },
        error: null
      };
    } catch (error) {
      console.error('Failed to update user info:', error);
      return {
        success: false,
        data: null,
        error: error.message
      };
    }
  },

  'user:change-password': async (event, data) => {
    try {
      const { currentPassword, newPassword } = data;

      // Verify current password
      const user = await database.models.User.findOne({
        where: { id: currentUserId }
      });

      if (!user) {
        throw new Error('User not found');
      }

      const isValid = await authService.verifyPassword(currentPassword, user.digest);
      if (!isValid) {
        throw new Error('Current password is incorrect');
      }

      // Update password
      const newDigest = await authService.hashPassword(newPassword);
      await user.update({ digest: newDigest });

      return {
        success: true,
        data: null,
        error: null
      };
    } catch (error) {
      console.error('Failed to change password:', error);
      return {
        success: false,
        data: null,
        error: error.message
      };
    }
  },

  'user:get-settings': async (event) => {
    try {
      let settings = await database.models.UserSettings.findOne({
        where: { userId: currentUserId }
      });

      if (!settings) {
        settings = await database.models.UserSettings.create({
          userId: currentUserId,
          config: {}
        });
      }

      return {
        success: true,
        data: settings.config,
        error: null
      };
    } catch (error) {
      console.error('Failed to get user settings:', error);
      return {
        success: false,
        data: null,
        error: error.message
      };
    }
  },

  'user:update-settings': async (event, config) => {
    try {
      let settings = await database.models.UserSettings.findOne({
        where: { userId: currentUserId }
      });

      if (settings) {
        await settings.update({ config });
      } else {
        settings = await database.models.UserSettings.create({
          userId: currentUserId,
          config
        });
      }

      return {
        success: true,
        data: settings.config,
        error: null
      };
    } catch (error) {
      console.error('Failed to update user settings:', error);
      return {
        success: false,
        data: null,
        error: error.message
      };
    }
  }
}; 
===========================================
<main/index.js>
===========================================
// main/index.js
import { app, shell, BrowserWindow, ipcMain } from 'electron'
import { join } from 'path'
import { electronApp, optimizer, is } from '@electron-toolkit/utils'
import icon from '../../resources/icon.png?asset'
import fs from 'fs/promises'
import path from 'path'
import database from './services/databaseService'
import { createTray } from './tray'
import { flowHandlers } from './handlers/flowHandlers'
import { connectionHandlers } from './handlers/connectionHandlers'
import { integrationHandlers } from './handlers/integrationHandlers'
import { nodeTemplateHandlers } from './handlers/nodeTemplateHandlers'
import { dashboardHandlers } from './handlers/dashboardHandlers'
import { authHandlers } from './handlers/authHandlers'
import { databaseHandlers } from './handlers/databaseHandlers'
import { dialogHandlers } from './handlers/dialogHandlers'
import { nodeHandlers } from './handlers/nodeHandlers'
import { envHandlers } from './handlers/envHandlers'
import { userHandlers } from './handlers/userHandlers'
import { executionHandlers } from './handlers/executionHandlers'

let mainWindow = null
let tray = null

// Store the current user ID
let currentUserId = null

const handlers = {
  ...flowHandlers,
  ...connectionHandlers,
  ...integrationHandlers,
  ...nodeTemplateHandlers,
  ...dashboardHandlers,
  ...databaseHandlers,
  ...dialogHandlers,
  ...nodeHandlers,
  ...envHandlers,
  ...userHandlers,
  ...executionHandlers
};
// Set up IPC handlers with user context
const registerHandler = (channel, handler) => {
  ipcMain.handle(channel, async (event, ...args) => {
    // Attach user ID to event.sender
    event.user.id = currentUserId
    return handler(event, ...args)
  })
}

const setupIPC = () => {
  // Register auth handlers separately since they manage currentUserId
  ipcMain.handle('auth:login', async (event, credentials) => {
    const response = await authHandlers['auth:login'](event, credentials)
    if (response.success) {
      currentUserId = response.response.id
    }
    return response
  })

  ipcMain.handle('auth:check-setup', async () => {
    const response = await authHandlers['auth:check-setup']()
    return response
  })

  ipcMain.handle('auth:setup', async (event, setupData) => {
    const response = await authHandlers['auth:setup'](event, setupData)
    return response
  })



  // Register other handlers with user context
  Object.entries(handlers).forEach(([channel, handler]) => {
    registerHandler(channel, handler)
  })
  
  // ... register other handlers ...
}

// Initialize storage directories
async function initializeStorage() {
  const userDataPath = app.getPath('userData')
  const dirs = ['flows', 'integrations', 'nodeTemplates', 'dashboards', 'environments']
  
  for (const dir of dirs) {
    try {
      await fs.mkdir(path.join(userDataPath, dir), { recursive: true })
    } catch (error) {
      console.error(`Failed to create ${dir} directory:`, error)
    }
  }
}

function createWindow() {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    show: true,
    frame: true,
    // dev tools 
    devTools: true,
    autoHideMenuBar: false,
    ...(process.platform === 'linux' ? { icon } : {}),
    webPreferences: {
      preload: join(__dirname, '../preload/index.js'),
      sandbox: false,
      contextIsolation: true,
      nodeIntegration: false,
      webSecurity: true,
      allowRunningInsecureContent: false
    }
  })

  mainWindow.on('ready-to-show', () => {
    mainWindow.show()
  })

  // Restrict navigation to prevent phishing
  mainWindow.webContents.on('will-navigate', (event, url) => {
    const allowedOrigins = ['http://localhost:5173']; // Add your allowed origins
    const parsedUrl = new URL(url);
    if (!allowedOrigins.includes(parsedUrl.origin)) {
      event.preventDefault();
    }
  });

  // Safe external link handling
  mainWindow.webContents.setWindowOpenHandler(({ url }) => {
    if (url.startsWith('https:') || url.startsWith('http:')) {
      shell.openExternal(url);
    }
    return { action: 'deny' };
  });

  // HMR for renderer base on electron-vite cli.
  // Load the remote URL for development or the local html file for production.
  if (is.dev && process.env['ELECTRON_RENDERER_URL']) {
    mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL'])
  } else {
    mainWindow.loadFile(join(__dirname, '../renderer/index.html'))
  }

  // Handle window close to minimize to tray instead
  mainWindow.on('close', (event) => {
    if (!app.isQuitting) {
      event.preventDefault()
      mainWindow.hide()
    }
    return false
  })

  // Create tray icon
  tray = createTray(mainWindow)
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(async () => {
  try {
    // Initialize database
    await database.initialize()
    console.log('Database initialized successfully')

    // Initialize storage directories
    await initializeStorage()
    console.log('Storage directories initialized successfully')

    // Register IPC handlers
    setupIPC()
    console.log('IPC handlers registered successfully')

    // Set app user model id for windows
    electronApp.setAppUserModelId('com.electron')

    // Default open or close DevTools by F12 in development
    // and ignore CommandOrControl + R in production.
    // see https://github.com/alex8088/electron-toolkit/tree/master/packages/utils
    app.on('browser-window-created', (_, window) => {
      optimizer.watchWindowShortcuts(window)
    })

    // IPC test
    ipcMain.on('ping', () => console.log('pong'))

    // Add window control handlers
    ipcMain.on('minimize-window', () => {
      BrowserWindow.getFocusedWindow()?.minimize()
    })

    ipcMain.on('maximize-window', () => {
      const win = BrowserWindow.getFocusedWindow()
      if (win?.isMaximized()) {
        win.unmaximize()
      } else {
        win?.maximize()
      }
    })

    ipcMain.on('close-window', () => {
      BrowserWindow.getFocusedWindow()?.close()
    })

    createWindow()

    // Handle quit through dock icon (macOS)
    app.on('before-quit', () => {
      app.isQuitting = true
    })

    // Handle window activation
    app.on('activate', () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        createWindow()
      } else {
        mainWindow.show()
      }
    })
  } catch (error) {
    console.error('Failed to initialize application:', error)
    app.quit()
  }
})

// Don't quit when all windows are closed (stay in tray)
app.on('window-all-closed', (e) => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

// In this file you can include the rest of your app"s specific main process
// code. You can also put them in separate files and require them here.

===========================================
<main/services/authService.js>
===========================================
import bcrypt from 'bcrypt';
import database from './databaseService';

const SALT_ROUNDS = 10;

export class AuthService {
  async hashPassword(password) {
    console.log('AuthService - Hashing password, length:', password?.length);
    return await bcrypt.hash(password, SALT_ROUNDS);
  }

  async verifyPassword(password, digest) {
    return bcrypt.compare(password, digest);
  }

  async setup({ user, database: dbConfig }) {
    console.log('AuthService setup - Received data structure:', {
      hasUser: !!user,
      hasDatabase: !!dbConfig,
      userData: {
        username: user?.username,
        hasPassword: !!user?.password
      }
    });
    
    try {
      // Check if any users exist
      const users = await database.models.User.count();
      if (users > 0) {
        throw new Error('Setup has already been completed');
      }

      if (!user?.username || !user?.password) {
        console.error('AuthService setup - Invalid user data:', {
          hasUsername: !!user?.username,
          hasPassword: !!user?.password
        });
        throw new Error('Username and password are required');
      }

      // Initialize database with configuration
      console.log('AuthService setup - Initializing database');
      await database.firstRun(dbConfig);

      // Create first user
      console.log('AuthService setup - Creating user:', {
        username: user.username,
        passwordLength: user.password?.length
      });
      
      const digest = await this.hashPassword(user.password);
      const result = await database.createUser({
        username: user.username,
        digest
      });

      console.log('AuthService setup - User creation result:', result);

      if (!result.success) {
        throw new Error(result.error);
      }

      return {
        success: true,
        user: {
          id: result.user.id,
          username: result.user.username
        }
      };
    } catch (error) {
      console.error('AuthService setup - Failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async login(username, password) {
    try {
      const user = await database.getUserByUsername(username);
      if (!user) {
        return {
          success: false,
          error: 'Invalid username or password'
        };
      }

      const isValid = await this.verifyPassword(password, user.digest);
      if (!isValid) {
        return {
          success: false,
          error: 'Invalid username or password'
        };
      }

      return {
        success: true,
        user: {
          id: user.id,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          avatar: user.avatar
        }
      };
    } catch (error) {
      console.error('Login failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async isSetupComplete() {
    try {
      const users = await database.models.User.count();
      return {
        success: true,
        isComplete: users > 0
      };
    } catch (error) {
      console.error('Failed to check setup status:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

export default new AuthService(); 
===========================================
<main/services/connectionService.js>
===========================================
import { Sequelize } from 'sequelize'

class ConnectionService {
  createSequelizeInstance(connection) {
    const baseConfig = {
      logging: console.log,
      dialect: connection.type
    }

    switch (connection.type) {
      case 'sqlite':
        return new Sequelize({
          ...baseConfig,
          storage: connection.config.file
        })

      case 'postgres':
      case 'mysql':
        return new Sequelize({
          ...baseConfig,
          host: connection.config.host,
          port: connection.config.port,
          database: connection.config.database,
          username: connection.config.username,
          password: connection.config.password,
          ssl: connection.config.ssl
        })

      default:
        throw new Error(`Unsupported database type: ${connection.type}`)
    }
  }

  async testConnection(config) {
    if (!config?.type) {
      throw new Error('Database type is required')
    }

    const sequelize = new Sequelize({
      dialect: config.type,
      host: config.host,
      port: parseInt(config.port),
      database: config.database,
      username: config.username,
      password: config.password,
      ssl: config.ssl,
      logging: false
    })

    try {
      await sequelize.authenticate()
      return true
    } finally {
      await sequelize.close()
    }
  }

  async executeQuery(params, database) {
    const { connectionId, query, input = {} } = params

    // Get connection
    const connection = await database.getConnection(connectionId)
    if (!connection) {
      throw new Error(`Connection not found: ${connectionId}`)
    }

    // Process query
    const systemQuery = getSystemQuery(query, connection.type)
    const finalQuery = interpolateQuery(systemQuery, input)
    const queryType = getQueryType(finalQuery)

    // Create and use connection
    const sequelize = this.createSequelizeInstance(connection)
    try {
      const [results, metadata] = await sequelize.query(finalQuery, {
        type: queryType
      })

      return this.formatResults(results, metadata, queryType)
    } finally {
      await sequelize.close()
    }
  }

  formatResults(results, metadata, queryType) {
    if (queryType === QueryTypes.SELECT) {
      return {
        success: true,
        data: {
          rowCount: Array.isArray(results) ? results.length : 1,
          rows: Array.isArray(results) ? results : [results],
          fields: metadata?.fields || []
        }
      }
    }

    return {
      success: true,
      data: {
        rowCount: typeof metadata === 'number' ? metadata : 0,
        rows: [],
        fields: [],
        message: `Affected ${typeof metadata === 'number' ? metadata : 0} rows`
      }
    }
  }
}

export const connectionService = new ConnectionService()
===========================================
<main/services/databaseService.js>
===========================================
import { Sequelize, DataTypes } from 'sequelize'
import { app } from 'electron'
import path from 'path'
import { randomUUID } from 'crypto'
import fs from 'fs/promises'
import { encrypt, decrypt } from '../utils/crypto'

class Database {
  constructor() {
    this.sequelize = null
    this.models = {}
    this.dbPath = null
    this.mainDbConfig = null
  }

  async initialize() {
    try {
      // Store the database path for SQLite
      const userDataPath = app.getPath('userData')
      this.dbPath = path.join(userDataPath, 'flowdog.db')
      
      console.log('Local database location:', this.dbPath)

      // Ensure the directory exists
      await fs.mkdir(path.dirname(this.dbPath), { recursive: true })

      // Check if we have a stored database configuration
      const storedConfig = await this.getStoredDatabaseConfig()
      
      if (storedConfig) {
        // Initialize with the stored database configuration
        console.log('Using stored database configuration:', {
          type: storedConfig.type,
          database: storedConfig.database
        })
        
        this.sequelize = new Sequelize({
          dialect: storedConfig.type,
          host: storedConfig.host,
          port: storedConfig.port,
          database: storedConfig.database,
          username: storedConfig.username,
          password: storedConfig.password,
          logging: false
        })
      } else {
        // Initialize with SQLite as default
        console.log('Using default SQLite configuration')
        this.sequelize = new Sequelize({
          dialect: 'sqlite',
          storage: this.dbPath,
          logging: false
        })
      }

      // Define all models
      await this.defineAllModels()

      // Sync models with database
      await this.sequelize.sync({ force: false })
      console.log('Database schema synchronized')

      // Test the connection
      await this.sequelize.authenticate()
      console.log('Database connection established successfully')

    } catch (error) {
      console.error('Failed to initialize database:', error)
      throw error
    }
  }

  async getStoredDatabaseConfig() {
    try {
      // Create a temporary SQLite connection to get the stored config
      const tempDb = new Sequelize({
        dialect: 'sqlite',
        storage: this.dbPath,
        logging: false
      });

      // Define the DatabaseConfig model temporarily
      const DatabaseConfig = tempDb.define('DatabaseConfig', {
        id: {
          type: DataTypes.UUID,
          defaultValue: DataTypes.UUIDV4,
          primaryKey: true
        },
        type: {
          type: DataTypes.STRING,
          allowNull: false
        },
        host: {
          type: DataTypes.STRING,
          allowNull: true
        },
        port: {
          type: DataTypes.INTEGER,
          allowNull: true
        },
        database: {
          type: DataTypes.STRING,
          allowNull: true
        },
        username: {
          type: DataTypes.STRING,
          allowNull: true
        },
        password: {
          type: DataTypes.STRING,
          allowNull: true
        },
        encrypted: {
          type: DataTypes.BOOLEAN,
          defaultValue: false
        }
      });

      await tempDb.sync();
      const config = await DatabaseConfig.findOne();
      await tempDb.close();

      if (!config) {
        console.log('No stored database configuration found');
        return null;
      }

      // Handle decryption more gracefully
      let decryptedPassword = config.password;
      if (config.encrypted && config.password) {
        try {
          decryptedPassword = await decrypt(config.password);
          if (decryptedPassword === null) {
            console.warn('Failed to decrypt database password, treating as unencrypted');
            decryptedPassword = config.password;
          }
        } catch (error) {
          console.warn('Error decrypting database password:', error);
          decryptedPassword = config.password;
        }
      }

      return {
        type: config.type,
        host: config.host,
        port: config.port,
        database: config.database,
        username: config.username,
        password: decryptedPassword
      };
    } catch (error) {
      console.error('Failed to get stored database config:', error);
      return null;
    }
  }

  async defineAllModels() {
    console.log('Defining database models...');
    
    // Define DatabaseConfig model
    this.models.DatabaseConfig = this.sequelize.define('DatabaseConfig', {
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      type: {
        type: DataTypes.STRING,
        allowNull: false
      },
      host: {
        type: DataTypes.STRING,
        allowNull: true
      },
      port: {
        type: DataTypes.INTEGER,
        allowNull: true
      },
      database: {
        type: DataTypes.STRING,
        allowNull: true
      },
      username: {
        type: DataTypes.STRING,
        allowNull: true
      },
      password: {
        type: DataTypes.STRING,
        allowNull: true
      },
      encrypted: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
      }
    });

    // Define Connection model
    this.models.Connection = this.sequelize.define('Connection', {
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      name: {
        type: DataTypes.STRING,
        allowNull: false
      },
      type: {
        type: DataTypes.STRING,
        allowNull: false
      },
      config: {
        type: DataTypes.JSON,
        allowNull: false
      }
    });

    // Define User model
    this.models.User = this.sequelize.define('User', {
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      username: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
        validate: {
          notEmpty: true
        }
      },
      digest: {
        type: DataTypes.STRING,
        allowNull: false,
        validate: {
          notEmpty: true
        }
      },
      first_name: {
        type: DataTypes.STRING,
        allowNull: true
      },
      last_name: {
        type: DataTypes.STRING,
        allowNull: true
      },
      avatar: {
        type: DataTypes.STRING,
        allowNull: true
      }
    }, {
      tableName: 'Users',
      timestamps: true,
      indexes: [
        {
          unique: true,
          fields: ['username']
        }
      ]
    });

    this.models.UserSetting = this.sequelize.define('UserSetting', {
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      user_id: {
        type: DataTypes.UUID,
        allowNull: false
      },
      config: {
        type: DataTypes.TEXT,
        allowNull: false,
        get() {
          const rawValue = this.getDataValue('config');
          return rawValue ? JSON.parse(rawValue) : {};
        },
        set(value) {
          this.setDataValue('config', JSON.stringify(value));
        }
      }
    });

    // Define Integration model
    this.models.Integration = this.sequelize.define('Integration', {
      id: {
        type: DataTypes.STRING,
        primaryKey: true
      },
      config: {
        type: DataTypes.JSON,
        allowNull: false
      }
    }, {
      timestamps: true
    });

    this.models.Environment = this.sequelize.define('Environment', {
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      name: {
        type: DataTypes.STRING,
        allowNull: false
      },
      description: {
        type: DataTypes.STRING,
        allowNull: true
      },
      variables: {
        type: DataTypes.TEXT,
        allowNull: false,
        get() {
          const rawValue = this.getDataValue('variables');
          try {
            return JSON.parse(rawValue);
          } catch (error) {
            console.error('Failed to parse variables JSON:', error);
            return {};
          }
        },
        set(value) {
          try {
            this.setDataValue('variables', JSON.stringify(value));
          } catch (error) {
            console.error('Failed to stringify variables:', error);
            this.setDataValue('variables', '{}');
          }
        }
      }
    }, {
      hooks: {
        beforeValidate: (environment) => {
          // Ensure variables is always a string
          if (typeof environment.variables === 'object') {
            environment.variables = JSON.stringify(environment.variables);
          }
        }
      }
    });

    this.models.Execution = this.sequelize.define('Execution', {
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      flow_id: {
        type: DataTypes.UUID,
        allowNull: false
      },
      user_id: {
        type: DataTypes.UUID,
        allowNull: false
      },
      status: {
        type: DataTypes.STRING,
        allowNull: false
      },
      scheduled_time: DataTypes.DATE,
      start_time: DataTypes.DATE,
      end_time: DataTypes.DATE,
      environment_id: DataTypes.UUID,
      error: DataTypes.TEXT,
      trigger_type: DataTypes.STRING
    });

    // FlowInfo is metadata about a flow, used for api.flow.list() and other flow related queries
    // makes it easier to query for flows by name, environment, etc.
    this.models.FlowInfo = this.sequelize.define('FlowInfo', {
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      flow_id: {
        type: DataTypes.UUID,
        allowNull: false
      },
      name: {
        type: DataTypes.STRING,
        allowNull: false
      },
      environment_id: {
        type: DataTypes.UUID,
        allowNull: true
      }
    });

    console.log('Models defined successfully');
  }


  async firstRun(dbConfig) {
    console.log('Database firstRun - Starting with config:', {
      type: dbConfig.type,
      host: dbConfig.host,
      database: dbConfig.database,
      username: dbConfig.username
    });

    try {
      if (dbConfig.type !== 'sqlite') {
        // Store encrypted database credentials in SQLite
        const tempDb = new Sequelize({
          dialect: 'sqlite',
          storage: this.dbPath,
          logging: false
        })

        // Define and sync the DatabaseConfig model
        const DatabaseConfig = tempDb.define('DatabaseConfig', {
          id: {
            type: DataTypes.UUID,
            defaultValue: DataTypes.UUIDV4,
            primaryKey: true
          },
          type: {
            type: DataTypes.STRING,
            allowNull: false
          },
          host: {
            type: DataTypes.STRING,
            allowNull: true
          },
          port: {
            type: DataTypes.INTEGER,
            allowNull: true
          },
          database: {
            type: DataTypes.STRING,
            allowNull: true
          },
          username: {
            type: DataTypes.STRING,
            allowNull: true
          },
          password: {
            type: DataTypes.STRING,
            allowNull: true
          },
          encrypted: {
            type: DataTypes.BOOLEAN,
            defaultValue: false
          }
        })

        await tempDb.sync()

        // Store the configuration
        await DatabaseConfig.create({
          id: randomUUID(),
          type: dbConfig.type,
          host: dbConfig.host,
          port: parseInt(dbConfig.port),
          database: dbConfig.database,
          username: dbConfig.username,
          password: await encrypt(dbConfig.password),
          encrypted: true
        })

        await tempDb.close()

        // Switch the main connection to the new database
        this.sequelize = new Sequelize({
          dialect: dbConfig.type,
          host: dbConfig.host,
          port: parseInt(dbConfig.port),
          database: dbConfig.database,
          username: dbConfig.username,
          password: dbConfig.password,
          logging: false
        })

        // Re-define models on the new connection
        await this.defineAllModels()
      }

      // Sync models with the database
      console.log('Syncing database models...')
      await this.sequelize.sync({ alter: true })

      console.log('Database firstRun - Completed successfully')
      return true
    } catch (error) {
      console.error('Database firstRun - Failed:', error)
      throw error
    }
  }

  // Flow methods
  async saveFlow(flowData) {
    const { id, name, data } = flowData
    return await this.sequelize.query(
      `INSERT OR REPLACE INTO flows (id, name, data, updatedAt) 
       VALUES (?, ?, ?, CURRENT_TIMESTAMP)`,
      {
        replacements: [id, name, JSON.stringify(data)],
        type: this.sequelize.QueryTypes.INSERT
      }
    )
  }

  async getFlow(id) {
    const flow = await this.sequelize.query(
      'SELECT * FROM flows WHERE id = ?',
      {
        replacements: [id],
        type: this.sequelize.QueryTypes.SELECT
      }
    )
    if (flow.length > 0) {
      flow[0].data = JSON.parse(flow[0].data)
    }
    return flow[0]
  }

  // Environment methods
  async saveEnv(envData) {
    const { id, name, variables } = envData
    return await this.sequelize.query(
      `INSERT OR REPLACE INTO environments (id, name, variables, updatedAt) 
       VALUES (?, ?, ?, CURRENT_TIMESTAMP)`,
      {
        replacements: [id, name, JSON.stringify(variables)],
        type: this.sequelize.QueryTypes.INSERT
      }
    )
  }

  async getEnv(id) {
    const env = await this.sequelize.query(
      'SELECT * FROM environments WHERE id = ?',
      {
        replacements: [id],
        type: this.sequelize.QueryTypes.SELECT
      }
    )
    if (env.length > 0) {
      env[0].variables = JSON.parse(env[0].variables)
    }
    return env[0]
  }

  async listEnv() {
    const envs = await this.sequelize.query(
      'SELECT id, name, created_at, updatedAt FROM environments',
      {
        type: this.sequelize.QueryTypes.SELECT
      }
    )
    return envs
  }

  async saveConnection(connection) {
    try {
      console.log('Database service: saving connection:', {
        ...connection,
        config: connection.config ? {
          ...connection.config,
          password: connection.config.password ? '[REDACTED]' : undefined
        } : undefined
      })

      // Validate required fields
      if (!connection?.name || !connection?.type) {
        throw new Error('Connection name and type are required')
      }

      // Create or update the connection
      const [record, created] = await this.models.Connection.upsert({
        id: connection.id, // Will be generated if not provided
        name: connection.name.trim(),
        type: connection.type,
        config: connection.config || {}
      })

      console.log(`Connection ${created ? 'created' : 'updated'} with ID:`, record.id)
      return { success: true, id: record.id }
    } catch (error) {
      console.error('Failed to save connection:', error)
      return { success: false, error: error.message }
    }
  }

  async getConnection(id) {
    try {
      const connection = await this.models.Connection.findByPk(id)
      if (!connection) {
        return null
      }
      
      const data = connection.toJSON()
      console.log('Retrieved connection:', {
        ...data,
        config: {
          ...data.config,
          password: data.config?.password ? '[REDACTED]' : undefined
        }
      })
      
      return data
    } catch (error) {
      console.error('Failed to get connection:', error)
      throw error
    }
  }

  async listConnections() {
    try {
      const connections = await this.models.Connection.findAll()
      const data = connections.map(conn => conn.toJSON())
      
      console.log('Retrieved connections:', data.map(conn => ({
        ...conn,
        config: {
          ...conn.config,
          password: conn.config?.password ? '[REDACTED]' : undefined
        }
      })))
      
      return data
    } catch (error) {
      console.error('Failed to list connections:', error)
      throw error
    }
  }

  async deleteConnection(id) {
    try {
      const deleted = await this.models.Connection.destroy({
        where: { id }
      })
      
      console.log('Deleted connection:', { id, success: deleted > 0 })
      return { success: deleted > 0 }
    } catch (error) {
      console.error('Failed to delete connection:', error)
      return { success: false, error: error.message }
    }
  }

  // Method to create a new Sequelize instance for a connection
  async createConnectionInstance(config) {
    try {
      const sequelize = new Sequelize({
        ...config,
        logging: console.log // Set to false in production
      })

      await sequelize.authenticate()
      return sequelize
    } catch (error) {
      console.error('Failed to create connection instance:', error)
      throw error
    }
  }

  // User management methods
  async createUser(userData) {
    console.log('Database createUser - Received data:', userData);
    
    try {
      if (!userData.username || !userData.digest) {
        console.error('Database createUser - Missing required fields:', { 
          hasUsername: !!userData.username, 
          hasDigest: !!userData.digest 
        });
        return {
          success: false,
          error: 'Username and password are required'
        };
      }

      const user = await this.models.User.create({
        username: userData.username,
        digest: userData.digest
      });

      console.log('Database createUser - User created:', user.toJSON());

      return {
        success: true,
        user: {
          id: user.id,
          username: user.username
        }
      };
    } catch (error) {
      console.error('Database createUser - Error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async getUser(id) {
    try {
      const user = await this.models.User.findByPk(id);
      return user ? user.toJSON() : null;
    } catch (error) {
      console.error('Failed to get user:', error);
      throw error;
    }
  }

  async getUserByUsername(username) {
    try {
      const user = await this.models.User.findOne({
        where: { username }
      });
      return user ? user.toJSON() : null;
    } catch (error) {
      console.error('Failed to get user by username:', error);
      throw error;
    }
  }

  async updateUser(id, userData) {
    try {
      const [updated] = await this.models.User.update(userData, {
        where: { id }
      });
      if (updated) {
        const user = await this.getUser(id);
        return {
          success: true,
          user
        };
      }
      return {
        success: false,
        error: 'User not found'
      };
    } catch (error) {
      console.error('Failed to update user:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async deleteUser(id) {
    try {
      const deleted = await this.models.User.destroy({
        where: { id }
      });
      return {
        success: deleted > 0
      };
    } catch (error) {
      console.error('Failed to delete user:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Integration methods
  async saveIntegration(data) {
    return await this.models.Integration.create(data);
  }

  async getIntegration(id) {
    return await this.models.Integration.findByPk(id);
  }

  async listIntegrations() {
    return await this.models.Integration.findAll();
  }

  async deleteIntegration(id) {
    return await this.models.Integration.destroy({ where: { id } });
  }

  async testConnection(config) {
    try {
      let testConfig;

      switch (config.type) {
        case 'mysql':
          testConfig = {
            dialect: 'mysql',
            host: config.host,
            port: parseInt(config.port),
            database: config.database,
            username: config.username,
            password: config.password,
            dialectOptions: config.ssl.enabled ? {
              ssl: {
                rejectUnauthorized: config.ssl.rejectUnauthorized,
                // Add these options for self-signed certificates
                require: true,
                requestCert: true,
                ca: null // Allow any CA
              }
            } : {},
            logging: false
          };
          break;

        case 'postgres':
          testConfig = {
            dialect: 'postgres',
            host: config.host,
            port: parseInt(config.port),
            database: config.database,
            username: config.username,
            password: config.password,
            dialectOptions: config.ssl.enabled ? {
              ssl: {
                rejectUnauthorized: config.ssl.rejectUnauthorized,
                // Add these options for self-signed certificates
                require: true,
                requestCert: true,
                ca: null // Allow any CA
              }
            } : {},
            logging: false
          };
          break;

        case 'sqlite':
          testConfig = {
            dialect: 'sqlite',
            storage: this.dbPath,
            logging: false
          };
          break;

        default:
          throw new Error(`Unsupported database type: ${config.type}`);
      }

      const testConnection = new Sequelize(testConfig);
      await testConnection.authenticate();
      await testConnection.close();
      
      return { success: true };
    } catch (error) {
      console.error('Connection test failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

const database = new Database()
export default database 
===========================================
<main/services/flowExecutionService.js>
===========================================
import { EventEmitter } from 'events';
import FlowExecutor from '../../renderer/src/executor/FlowExecutor';

class FlowExecutionService extends EventEmitter {
  constructor() {
    super();
    this.activeExecutions = new Map(); // executionId -> execution info
    this.executionQueue = [];
  }

  async startExecution(flowId, {
    nodes,
    edges,
    environment,
    scheduledTime = null,
    triggerType = 'manual',
    userId
  }) {
    const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const executionInfo = {
      id: executionId,
      flowId,
      userId,
      status: 'pending',
      startTime: null,
      endTime: null,
      error: null,
      triggerType,
      scheduledTime,
      progress: 0,
      executingNodeIds: new Set()
    };

    this.activeExecutions.set(executionId, executionInfo);
    this.emit('executionCreated', executionInfo);

    // If scheduled, add to queue
    if (scheduledTime && scheduledTime > Date.now()) {
      this.queueExecution(executionId, scheduledTime);
      return executionId;
    }

    // Execute immediately
    this.executeFlow(executionId, {
      nodes,
      edges,
      environment,
      userId
    });

    return executionId;
  }

  queueExecution(executionId, scheduledTime) {
    const timeout = setTimeout(() => {
      this.executeFlow(executionId);
    }, scheduledTime - Date.now());

    this.executionQueue.push({ executionId, timeout });
  }

  async executeFlow(executionId, {
    nodes,
    edges,
    environment,
    userId
  }) {
    const executionInfo = this.activeExecutions.get(executionId);
    if (!executionInfo) return;

    try {
      executionInfo.status = 'running';
      executionInfo.startTime = Date.now();
      this.emit('executionStarted', executionInfo);

      const executor = new FlowExecutor(
        nodes,
        edges,
        this.addToHistory.bind(this),
        this.addLog.bind(this),
        (nodeIds) => {
          executionInfo.executingNodeIds = nodeIds;
          this.emit('executionProgress', executionInfo);
        },
        this.updateNodeData.bind(this),
        environment
      );

      const result = await executor.execute();
      
      executionInfo.status = 'completed';
      executionInfo.endTime = Date.now();
      this.emit('executionCompleted', executionInfo);

    } catch (error) {
      executionInfo.status = 'failed';
      executionInfo.error = error.message;
      executionInfo.endTime = Date.now();
      this.emit('executionFailed', executionInfo);
    }
  }

  cancelExecution(executionId) {
    const executionInfo = this.activeExecutions.get(executionId);
    if (!executionInfo) return;

    // Remove from queue if scheduled
    const queuedExecution = this.executionQueue.find(q => q.executionId === executionId);
    if (queuedExecution) {
      clearTimeout(queuedExecution.timeout);
      this.executionQueue = this.executionQueue.filter(q => q.executionId !== executionId);
    }

    executionInfo.status = 'cancelled';
    executionInfo.endTime = Date.now();
    this.emit('executionCancelled', executionInfo);
  }

  getExecution(executionId) {
    return this.activeExecutions.get(executionId);
  }

  listExecutions(filters = {}) {
    return Array.from(this.activeExecutions.values())
      .filter(exec => {
        if (filters.flowId && exec.flowId !== filters.flowId) return false;
        if (filters.status && exec.status !== filters.status) return false;
        if (filters.userId && exec.userId !== filters.userId) return false;
        return true;
      });
  }
}

export const flowExecutionService = new FlowExecutionService(); 
===========================================
<main/tray.js>
===========================================
import { Tray, Menu, app, nativeImage } from 'electron';
import path from 'path';

let tray = null;

export function createTray(mainWindow) {
  try {
    // Get the correct path based on whether we're in dev or production
    const iconPath = app.isPackaged
      ? path.join(process.resourcesPath, 'assets', 'tray.png')
      : path.join(app.getAppPath(), 'src', 'renderer', 'assets', 'tray.png');

    // Create tray with icon
    tray = new Tray(iconPath);

    // Create context menu
    const contextMenu = Menu.buildFromTemplate([
      {
        label: 'Show FlowDog',
        click: () => {
          mainWindow.show();
        }
      },
      {
        label: 'New Workflow',
        click: () => {
          mainWindow.show();
          mainWindow.webContents.send('menu-new-workflow');
        }
      },
      { type: 'separator' },
      {
        label: 'Recent Flows',
        submenu: [] // We can populate this dynamically
      },
      { type: 'separator' },
      {
        label: 'Quit',
        click: () => {
          app.quit();
        }
      }
    ]);

    // Set tooltip and context menu
    tray.setToolTip('FlowDog');
    tray.setContextMenu(contextMenu);

    // Handle click (show/hide window)
    tray.on('click', () => {
      if (mainWindow.isVisible()) {
        mainWindow.hide();
      } else {
        mainWindow.show();
      }
    });

    return tray;
  } catch (error) {
    console.error('Failed to create tray:', error);
    throw error;
  }
}

export function updateTrayMenu(recentFlows = []) {
  if (!tray) return;

  const contextMenu = Menu.buildFromTemplate([
    {
      label: 'Show FlowDog',
      click: () => {
        mainWindow.show();
      }
    },
    {
      label: 'New Workflow',
      click: () => {
        mainWindow.show();
        mainWindow.webContents.send('menu-new-workflow');
      }
    },
    { type: 'separator' },
    {
      label: 'Recent Flows',
      submenu: recentFlows.map(flow => ({
        label: flow.name,
        click: () => {
          mainWindow.show();
          mainWindow.webContents.send('menu-open-flow', flow.id);
        }
      }))
    },
    { type: 'separator' },
    {
      label: 'Quit',
      click: () => {
        app.quit();
      }
    }
  ]);

  tray.setContextMenu(contextMenu);
} 
===========================================
<main/utils/crypto.js>
===========================================
import crypto from 'crypto';
import { app } from 'electron';
import path from 'path';
import fs from 'fs/promises';

const ALGORITHM = 'aes-256-gcm';
const KEY_LENGTH = 32; // 256 bits
const IV_LENGTH = 16; // 128 bits
const AUTH_TAG_LENGTH = 16;

async function getOrCreateKey() {
  const keyPath = path.join(app.getPath('userData'), '.key');
  
  try {
    // Try to read existing key
    const keyBuffer = await fs.readFile(keyPath);
    return keyBuffer;
  } catch (error) {
    // If key doesn't exist, create a new one
    const key = crypto.randomBytes(KEY_LENGTH);
    await fs.writeFile(keyPath, key);
    return key;
  }
}

export async function encrypt(text) {
  if (!text) return text;
  
  try {
    const key = await getOrCreateKey();
    const iv = crypto.randomBytes(IV_LENGTH);
    const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    const authTag = cipher.getAuthTag();

    // Combine IV, encrypted data, and auth tag
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  } catch (error) {
    console.error('Encryption error:', error);
    throw new Error('Failed to encrypt data');
  }
}

export async function decrypt(text) {
  if (!text) return text;
  
  try {
    const [ivHex, authTagHex, encryptedHex] = text.split(':');
    if (!ivHex || !authTagHex || !encryptedHex) {
      throw new Error('Invalid encrypted data format');
    }

    const key = await getOrCreateKey();
    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');
    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
    
    decipher.setAuthTag(authTag);
    let decrypted = decipher.update(encryptedHex, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  } catch (error) {
    console.error('Decryption error:', error);
    if (error.code === 'ERR_OSSL_BAD_DECRYPT') {
      // Return null if decryption fails due to invalid data
      return null;
    }
    throw error;
  }
} 
===========================================
<main/utils/database.js>
===========================================
// utils/database.js
import { QueryTypes } from 'sequelize'

export function escapeValue(value) {
  if (value === null || value === undefined) {
    return 'NULL'
  }
  if (typeof value === 'number') {
    return value
  }
  if (typeof value === 'boolean') {
    return value ? 1 : 0
  }
  return `'${value.toString().replace(/'/g, "''")}'`
}

export function interpolateQuery(query, input = {}) {
  return query.replace(/\{\{([^}]+)\}\}/g, (match, path) => {
    const value = path.trim().split('.').reduce((obj, key) => obj?.[key], input)
    return escapeValue(value)
  })
}

export function getQueryType(query) {
  const normalizedQuery = query.trim().toLowerCase()
  if (normalizedQuery.startsWith('select') || normalizedQuery === 'show tables') {
    return QueryTypes.SELECT
  }
  if (normalizedQuery.startsWith('insert')) {
    return QueryTypes.INSERT
  }
  if (normalizedQuery.startsWith('update')) {
    return QueryTypes.UPDATE
  }
  if (normalizedQuery.startsWith('delete')) {
    return QueryTypes.DELETE
  }
  if (normalizedQuery.startsWith('create') || 
      normalizedQuery.startsWith('alter') || 
      normalizedQuery.startsWith('drop')) {
    return QueryTypes.RAW
  }
  return QueryTypes.RAW
}

export function getSystemQuery(query, dbType) {
  const normalizedQuery = query.trim().toLowerCase()
  
  if (normalizedQuery === 'show tables') {
    switch (dbType) {
      case 'sqlite':
        return `SELECT name as table_name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'`
      case 'postgres':
        return `SELECT tablename as table_name FROM pg_catalog.pg_tables WHERE schemaname != 'pg_catalog' AND schemaname != 'information_schema'`
      case 'mysql':
        return 'SHOW TABLES'
      default:
        throw new Error(`Unsupported database type for system query: ${dbType}`)
    }
  }
  
  return query
}

===========================================
<main/utils/helpers.js>
===========================================
// these are helper functions that are used in the handlers and other parts of the app

export const responder = (success, data, error = null, sourceId = null) => {
    // If data is an object with status, headers, data structure, use it directly
    if (data && typeof data === 'object' && 'status' in data) {
      return {
        success,
        response: {
          status: data.status,
          headers: data.headers || {},
          data: data.data
        },
        error,
        source_id: sourceId
      };
    }
  
    // Otherwise wrap the data
    return {
      success,
      response: data,
      error,
      source_id: sourceId
    };
  };
  

export const sanitizePath = (str) => {
    return str.replace(/[^a-zA-Z0-9-_]/g, '');
}

===========================================
<main/utils/validation.js>
===========================================
import { z } from 'zod';

// Panel configuration schemas based on type
const textPanelConfig = z.object({
  format: z.string().optional(),
  template: z.string().optional()
});

const seriesChartConfig = z.object({
  chartType: z.enum(['line', 'bar', 'area']),
  xAxis: z.string(),
  yAxis: z.array(z.string()),
  aggregation: z.enum(['sum', 'avg', 'min', 'max']).optional()
});

const pieChartConfig = z.object({
  valueField: z.string(),
  labelField: z.string(),
  colors: z.array(z.string()).optional()
});

// Panel schema
const panelSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(100),
  size: z.tuple([
    z.number().int().positive().max(4), // x units
    z.number().int().positive().max(4)  // y units
  ]),
  flow_id: z.string().uuid(),
  type: z.enum(['text', 'series_chart', 'pie_chart']),
  config: z.discriminatedUnion('type', [
    z.object({ type: z.literal('text'), ...textPanelConfig.shape }),
    z.object({ type: z.literal('series_chart'), ...seriesChartConfig.shape }),
    z.object({ type: z.literal('pie_chart'), ...pieChartConfig.shape })
  ]),
  last_data: z.object({
    timestamp: z.number(),
    data: z.record(z.unknown())
  }).optional(),
  schedule: z.string().regex(/^(\*|([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])) (\*|([0-9]|1[0-9]|2[0-3])) (\*|([1-9]|1[0-9]|2[0-9]|3[0-1])) (\*|([1-9]|1[0-2])) (\*|([0-6]))$/)
});

// Dashboard schema validation
const dashboardSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(100),
  description: z.string().optional(),
  panels: z.array(panelSchema).default([]),
  created_at: z.number(),
  updatedAt: z.number()
});

export const validateDashboard = (data) => {
  return dashboardSchema.parse(data);
};

export const validatePanel = (data) => {
  return panelSchema.parse(data);
};

export const sanitizePath = (str) => {
  return str.replace(/[^a-zA-Z0-9-_]/g, '');
}; 
===========================================
<preload/index.js>
===========================================
import { contextBridge, ipcRenderer } from 'electron'
import { electronAPI } from '@electron-toolkit/preload'

// Whitelist of valid channels for security
const validChannels = [
  // Auth endpoints
  'auth:check-setup',
  'auth:setup',
  'auth:login',

  // Flow endpoints
  'flow:save',
  'flow:get',
  'flow:list',
  'flow:delete',

  // Connection endpoints
  'connection:test',
  'connection:save',
  'connection:list',
  'connection:delete',

  // Environment endpoints
  'env:save',
  'env:get',
  'env:list',

  // Integration endpoints
  'integration:save',
  'integration:get',
  'integration:list',
  'integration:delete',

  // Node template endpoints
  'node-template:save',
  'node-template:list',
  'node-template:delete',

  // Dialog endpoints
  'dialog:open',
  'dialog:save',

  // Database endpoints
  'database:execute',

  // Dashboard endpoints
  'dashboard:save',
  'dashboard:list',
  'dashboard:delete',
  'dashboard:get',

  // Node operation endpoints
  'nodes:database:query',
  'nodes:http:request'
];

// Validation utilities
const validateId = (id) => {
  if (typeof id !== 'string' || !/^[a-zA-Z0-9-_]+$/.test(id)) {
    throw new Error('Invalid ID format');
  }
  return id;
};

const validateObject = (obj) => {
  if (!obj || typeof obj !== 'object') {
    throw new Error('Invalid data format');
  }
  return obj;
};

// Main API definition
const api = {
  invoke: async (channel, ...args) => {
    if (!validChannels.includes(channel)) {
      throw new Error(`Invalid channel: ${channel}`);
    }
    return await ipcRenderer.invoke(channel, ...args);
  },

  // Event handling
  on: (channel, func) => {
    if (validChannels.includes(channel)) {
      ipcRenderer.on(channel, (_, ...args) => func(...args));
    }
  },
  
  off: (channel, func) => {
    if (validChannels.includes(channel)) {
      ipcRenderer.removeListener(channel, func);
    }
  },

  // Grouped API endpoints
  connection: {
    test: async (config) => {
      console.log('Testing connection:', { ...config, password: '[REDACTED]' });
      return await api.invoke('connection:test', validateObject(config));
    },
    save: (data) => api.invoke('connection:save', validateObject(data)),
    list: () => api.invoke('connection:list'),
    delete: (id) => api.invoke('connection:delete', validateId(id))
  },

  flow: {
    save: (data) => api.invoke('flow:save', validateObject(data)),
    get: (id) => api.invoke('flow:get', validateId(id)),
    list: () => api.invoke('flow:list'),
    delete: (id) => api.invoke('flow:delete', validateId(id))
  },

  env: {
    save: (data) => api.invoke('env:save', validateObject(data)),
    get: (id) => api.invoke('env:get', validateId(id)),
    list: () => api.invoke('env:list')
  },

  integration: {
    save: (data) => api.invoke('integration:save', validateObject(data)),
    get: (id) => api.invoke('integration:get', validateId(id)),
    list: () => api.invoke('integration:list'),
    delete: (id) => api.invoke('integration:delete', validateId(id))
  },

  nodeTemplate: {
    save: async (template) => {
      console.log('Saving node template:', template);
      return await api.invoke('node-template:save', validateObject(template));
    },
    list: () => api.invoke('node-template:list'),
    delete: (id) => api.invoke('node-template:delete', validateId(id))
  },

  dialog: {
    openFile: (options) => api.invoke('dialog:open', options),
    saveFile: (options) => api.invoke('dialog:save', options)
  },

  database: {
    executeQuery: (connectionId, query, parameters) => 
      api.invoke('database:execute', validateId(connectionId), query, parameters)
  },

  dashboard: {
    save: (data) => api.invoke('dashboard:save', validateObject(data)),
    list: () => api.invoke('dashboard:list'),
    delete: (id) => api.invoke('dashboard:delete', validateId(id)),
    get: (id) => api.invoke('dashboard:get', validateId(id))
  },

  nodes: {
    database: {
      query: (connectionId, query, parameters) => 
        api.invoke('nodes:database:query', validateId(connectionId), query, parameters)
    },
    http: {
      request: (config) => api.invoke('nodes:http:request', validateObject(config))
    }
  },

  auth: {
    checkSetup: () => api.invoke('auth:check-setup'),
    setup: async (setupData) => {
      console.log('Setup:', setupData);
      return await api.invoke('auth:setup', validateObject(setupData));
    },
    login: (credentials) => api.invoke('auth:login', validateObject(credentials))
  }
};

// Expose APIs based on context isolation
if (process.contextIsolated) {
  try {
    contextBridge.exposeInMainWorld('electron', electronAPI);
    contextBridge.exposeInMainWorld('api', api);
  } catch (error) {
    console.error(error);
  }
} else {
  window.electron = electronAPI;
  window.api = api;
}
===========================================
<renderer/src/actions/formatAction.js>
===========================================
import Handlebars from 'handlebars';

export const executeFormatAction = async (config, inputData) => {
  const { template } = config;

  if (!template || !inputData) {
    return {
      success: false,
      error: { message: 'Template or input data is missing' }
    };
  }

  try {
    // Compile the template
    const compiledTemplate = Handlebars.compile(template);
    
    // Execute the template with the input data
    const result = compiledTemplate(inputData);
    
    // Try to parse the result as JSON if it looks like JSON
    let parsedResult = result;
    try {
      if (result.trim().startsWith('{') || result.trim().startsWith('[')) {
        parsedResult = JSON.parse(result);
      }
    } catch (e) {
      console.log('Result is not valid JSON, returning as string');
    }
    
    return {
      success: true,
      data: parsedResult
    };
  } catch (error) {
    return {
      success: false,
      error: { message: error.message }
    };
  }
};

export const validateFormatConfig = (config) => {
  const errors = [];

  if (!config.template) {
    errors.push('Template is required');
  }

  try {
    if (config.template) {
      Handlebars.compile(config.template);
    }
  } catch (error) {
    errors.push(`Invalid template: ${error.message}`);
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}; 
===========================================
<renderer/src/actions/httpAction.js>
===========================================
import axios from 'axios';
import Handlebars from 'handlebars';

/**
 * Templates a string using Handlebars
 * @param {string} template - The template string
 * @param {object} data - The data to use for templating
 * @returns {string} The templated string
 */
const templateString = (template, data) => {
  if (!template || !data) return template;

  console.log('Templating string:', template, data);
  try {
    const compiled = Handlebars.compile(template);
    return compiled(data);
  } catch (error) {
    console.error('Template error:', error);
    return template;
  }
};

/**
 * Templates an object's values using Handlebars
 * @param {Array} items - Array of key-value objects
 * @param {object} data - The data to use for templating
 * @returns {Array} Array with templated values
 */
const templateItems = (items = [], data) => {
  return items.map(item => ({
    ...item,
    key: templateString(item.key, data),
    value: templateString(item.value, data)
  }));
};

/**
 * Builds the final URL with query parameters
 * @param {string} baseUrl - The base URL
 * @param {Array} params - Array of parameter objects
 * @returns {string} The complete URL with query parameters
 */
const buildUrl = (baseUrl, params = []) => {
  if (!params.length) return baseUrl;
  
  const queryString = params
    .filter(param => param.key && param.value) // Only include params with both key and value
    .map(param => `${encodeURIComponent(param.key)}=${encodeURIComponent(param.value)}`)
    .join('&');
    
  return queryString ? `${baseUrl}${baseUrl.includes('?') ? '&' : '?'}${queryString}` : baseUrl;
};

/**
 * Parse body string into JSON if needed
 * @param {string|object} body - The request body
 * @returns {object} Parsed body
 */
const parseBody = (body) => {
  if (!body) return null;
  if (typeof body === 'object') return body;
  
  try {
    // Remove any extra whitespace and newlines
    const cleanBody = body.trim();
    return JSON.parse(cleanBody);
  } catch (error) {
    console.error('Failed to parse body:', error);
    return body; // Return original if parsing fails
  }
};

/**
 * Executes an HTTP request
 * @param {Object} config - The request configuration
 * @param {string} config.url - The URL to send the request to
 * @param {string} config.method - The HTTP method to use
 * @param {Array} config.headers - Array of header objects
 * @param {Array} config.params - Array of parameter objects
 * @param {string} config.body - The request body (for POST/PUT/PATCH)
 * @returns {Promise} The response data
 */
export const executeHttpAction = async (config, inputData = null) => {
  const { url, method, headers = [], params = [], body } = config;

  try {
    // Template the URL
    const templatedUrl = templateString(url, inputData);
    if (!templatedUrl) {
      throw new Error('URL is required');
    }

    // Create URL object and template query parameters
    const urlObj = new URL(templatedUrl);
    const templatedParams = templateItems(params, inputData);
    templatedParams.forEach(p => {
      if (p.key && p.value) {
        urlObj.searchParams.append(p.key, p.value);
      }
    });

    // Template headers
    const headerObj = {};
    const templatedHeaders = templateItems(headers, inputData);
    templatedHeaders.forEach(h => {
      if (h.key && h.value) {
        headerObj[h.key] = h.value;
      }
    });

    // Prepare request options
    const requestOptions = {
      method,
      headers: headerObj
    };

    // Handle body based on content type
    if (['POST', 'PUT', 'PATCH'].includes(method)) {
      if (body?.file) {
        // Handle file upload
        const formData = new FormData();
        formData.append('file', body.file, body.filename);
        requestOptions.body = formData;
        // Let the browser set the correct Content-Type for FormData
        delete requestOptions.headers['Content-Type'];
      } else if (body) {
        // Handle JSON/text body
        try {
          const templatedBody = templateString(body, inputData);
          requestOptions.body = JSON.stringify(JSON.parse(templatedBody));
          requestOptions.headers['Content-Type'] = 'application/json';
        } catch (error) {
          // If JSON parsing fails, send as plain text
          requestOptions.body = templateString(body, inputData);
          requestOptions.headers['Content-Type'] = 'text/plain';
        }
      } else if (inputData) {
        // Use inputData as body if no body specified
        requestOptions.body = JSON.stringify(inputData);
        requestOptions.headers['Content-Type'] = 'application/json';
      }
    }

    console.log('Making templated request:', {
      url: urlObj.toString(),
      method,
      headers: requestOptions.headers,
      body: requestOptions.body
    });

    const response = await fetch(urlObj.toString(), requestOptions);
    
    // Handle different response types
    let responseData;
    const contentType = response.headers.get('content-type');
    if (contentType?.includes('application/json')) {
      responseData = await response.json();
    } else {
      responseData = await response.text();
    }

    return {
      success: response.ok,
      response: {
        status: response.status,
        headers: Object.fromEntries(response.headers.entries()),
        data: responseData
      },
      error: response.ok ? null : { 
        message: typeof responseData === 'object' ? responseData.message : 'Request failed' 
      }
    };
  } catch (error) {
    console.error('HTTP request failed:', error);
    return {
      success: false,
      response: null,
      error: { message: error.message }
    };
  }
};

/**
 * Validates HTTP request configuration
 * @param {Object} config - The request configuration
 * @returns {Object} Validation result
 */
export const validateHttpConfig = (config) => {
  const errors = [];

  if (!config.url) {
    errors.push('URL is required');
  } else {
    try {
      new URL(config.url);
    } catch (e) {
      errors.push('Invalid URL format');
    }
  }

  if (!config.method) {
    errors.push('Method is required');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}; 
===========================================
<renderer/src/actions/index.js>
===========================================
import { executeHttpAction, validateHttpConfig } from './httpAction';
import { executeFormatAction, validateFormatConfig } from './formatAction';
import { executeParserAction, validateParserConfig } from './parserAction';

export * from './httpAction';
export * from './formatAction';
export * from './parserAction';
// We'll add more exports here as we create other actions 

// This will be used by the executor
export const nodeExecutors = {
  http: executeHttpAction,
  format: executeFormatAction,
  parser: executeParserAction,
  // ... other executors
};

export const nodeValidators = {
  http: validateHttpConfig,
  format: validateFormatConfig,
  parser: validateParserConfig,
  // ... other validators
}; 
===========================================
<renderer/src/actions/parserAction.js>
===========================================
import get from 'lodash/get';

const parseJQPath = (path) => {
  // Remove leading dot if present
  path = path.startsWith('.') ? path.slice(1) : path;
  
  // Handle array operations
  path = path.replace(/\[\](?=\.|$)/g, '[*]');
  
  return path;
};

const evaluateJQExpression = (data, query) => {
  try {
    if (!query) return data;
    
    const path = parseJQPath(query);
    
    // Handle array wildcards
    if (path.includes('[*]')) {
      const basePath = path.split('[*]')[0];
      const remainingPath = path.split('[*]').slice(1).join('');
      const array = get(data, basePath);
      
      if (Array.isArray(array)) {
        if (!remainingPath) return array;
        return array.map(item => get({ item }, `item${remainingPath}`));
      }
    }
    
    return get(data, path);
  } catch (error) {
    throw new Error(`Invalid query: ${error.message}`);
  }
};

export const executeParserAction = async (config, inputData) => {
  const { mode, query, inputExpression } = config;

  try {
    // Get the input data using the expression
    const targetData = inputExpression ? get(inputData, inputExpression) : inputData;
    
    if (targetData === undefined) {
      throw new Error(`Input data not found at path: ${inputExpression}`);
    }

    switch (mode) {
      case 'json':
        const result = evaluateJQExpression(targetData, query);
        return {
          success: true,
          data: result,
          error: null
        };

      case 'xml':
      case 'text':
        return {
          success: false,
          data: null,
          error: 'Parser mode not yet implemented'
        };

      default:
        return {
          success: false,
          data: null,
          error: 'Invalid parser mode'
        };
    }
  } catch (error) {
    return {
      success: false,
      data: null,
      error: error.message
    };
  }
};

export const validateParserConfig = (config) => {
  const errors = [];

  if (!config.mode) {
    errors.push('Parser mode is required');
  }

  if (!config.inputExpression) {
    errors.push('Input expression is required');
  }

  if (config.mode === 'json' && !config.query) {
    errors.push('JSON query is required');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}; 
===========================================
<renderer/src/components/diagram/nodes/index.js>
===========================================
import PromptNode from './PromptNode';
import ParserNode from './ParserNode';
import ConditionalNode from './ConditionalNode';
import FileOpNode from './FileOpNode';
import HTTPNode from './HTTPNode';
import FormatNode from './FormatNode';
import LoggerNode from './LoggerNode';

export const nodeTypes = {
  prompt: PromptNode,
  parser: ParserNode,
  conditional: ConditionalNode,
  fileop: FileOpNode,
  http: HTTPNode,
  format: FormatNode,
  logger: LoggerNode,
};

export {
  PromptNode,
  ParserNode,
  ConditionalNode,
  FileOpNode,
  HTTPNode,
  FormatNode,
}; 
===========================================
<renderer/src/components/diagram/utility/nodeConfigs/index.js>
===========================================
import HttpNodeConfig from './HttpNodeConfig';
import FormatNodeConfig from './FormatNodeConfig';
import FileOpNodeConfig from './FileOpNodeConfig';
import ParserNodeConfig from './ParserNodeConfig';
import ConditionalNodeConfig from './ConditionalNodeConfig';
import PromptNodeConfig from './PromptNodeConfig';
import DatabaseNodeConfig from './DatabaseNodeConfig';

export const NODE_CONFIGS = {
  http: HttpNodeConfig,
  format: FormatNodeConfig,
  fileop: FileOpNodeConfig,
  parser: ParserNodeConfig,
  conditional: ConditionalNodeConfig,
  prompt: PromptNodeConfig,
  database: DatabaseNodeConfig,
};

export const getNodeConfig = (type) => {
  return NODE_CONFIGS[type] || null;
}; 
===========================================
<renderer/src/components/logical/TreeSuggest.js>
===========================================
const generatePathSuggestions = (data) => {
  const paths = [];
  
  const traverse = (obj, path = '') => {
    if (!obj || typeof obj !== 'object') return;
    
    Object.entries(obj).forEach(([key, value]) => {
      const currentPath = path ? `${path}.${key}` : key;
      paths.push(currentPath);
      
      // Handle arrays
      if (Array.isArray(value)) {
        // Add array notation
        paths.push(`${currentPath}[]`);
        
        // Sample first item for array structure
        if (value.length > 0 && typeof value[0] === 'object') {
          traverse(value[0], `${currentPath}[]`);
        }
        
        // Add direct index access for small arrays
        if (value.length <= 5) {
          value.forEach((_, index) => {
            paths.push(`${currentPath}[${index}]`);
          });
        }
      }
      // Recurse into nested objects
      else if (value && typeof value === 'object') {
        traverse(value, currentPath);
      }
    });
  };
  
  traverse(data);
  return paths;
};

export default generatePathSuggestions; 
===========================================
<renderer/src/constants/integrations.js>
===========================================
import { 
  GithubIcon, 
  GitlabIcon, 
  ShieldCheckIcon, 
  BarChart2Icon, 
  SparklesIcon,
  CloudIcon,
  ServerIcon,
  BrainCircuitIcon
} from 'lucide-react';

export const INTEGRATION_CATEGORIES = {
  SOURCE_CONTROL: 'Source Control',
  SECURITY: 'Security',
  AI: 'Artificial Intelligence',
  CLOUD: 'Cloud Services',
  MONITORING: 'Monitoring'
};

export const integrations = [
  {
    id: 'github',
    name: 'GitHub',
    description: 'GitHub API integration for repository management and code analysis',
    icon: GithubIcon,
    image: 'github.png',
    category: INTEGRATION_CATEGORIES.SOURCE_CONTROL,
    config: {
      token: {
        type: 'password',
        label: 'Personal Access Token',
        required: true,
        validation: /^ghp_[a-zA-Z0-9]{36}$/,
        placeholder: 'ghp_...',
        helpText: 'Generate a token with repo and workflow permissions'
      }
    }
  },
  {
    id: 'gitlab',
    name: 'GitLab',
    description: 'GitLab API integration for repository and CI/CD management',
    icon: GitlabIcon,
    image: 'gitlab.jpg',
    category: INTEGRATION_CATEGORIES.SOURCE_CONTROL,
    config: {
      token: {
        type: 'password',
        label: 'Personal Access Token',
        required: true,
        validation: /^glpat-[a-zA-Z0-9]{20}$/,
        placeholder: 'glpat-...',
        helpText: 'Generate a token with api scope'
      },
      url: {
        type: 'text',
        label: 'GitLab URL',
        required: false,
        placeholder: 'https://gitlab.com',
        helpText: 'Leave empty for gitlab.com, specify for self-hosted'
      }
    }
  },
  {
    id: 'snyk',
    name: 'Snyk',
    description: 'Security vulnerability scanning and dependency analysis',
    icon: ShieldCheckIcon,
    image: 'snyk.png',
    category: INTEGRATION_CATEGORIES.SECURITY,
    config: {
      token: {
        type: 'password',
        label: 'API Token',
        required: true,
        validation: /^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/,
        placeholder: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',
        helpText: 'Find in Account Settings > API Token'
      }
    }
  },
  {
    id: 'sonarqube',
    name: 'SonarQube',
    description: 'Code quality and security analysis',
    icon: BarChart2Icon,
    image: 'sonar.png',
    category: INTEGRATION_CATEGORIES.SECURITY,
    config: {
      token: {
        type: 'password',
        label: 'Authentication Token',
        required: true,
        validation: /^[a-zA-Z0-9]+$/,
        placeholder: 'Enter your token',
        helpText: 'Generate in User > Security > Generate Token'
      },
      url: {
        type: 'text',
        label: 'SonarQube URL',
        required: true,
        placeholder: 'https://sonarqube.yourdomain.com',
        helpText: 'Your SonarQube instance URL'
      }
    }
  },
  {
    id: 'anthropic',
    name: 'Anthropic',
    description: 'Claude AI integration for code analysis and generation',
    icon: BrainCircuitIcon,
    image: 'anthropic.jpg',
    category: INTEGRATION_CATEGORIES.AI,
    config: {
      apiKey: {
        type: 'password',
        label: 'API Key',
        required: true,
        validation: /^sk-ant-[a-zA-Z0-9]{48}$/,
        placeholder: 'sk-ant-...',
        helpText: 'Get your API key from Anthropic Console'
      }
    }
  },
  {
    id: 'openai',
    name: 'OpenAI',
    description: 'GPT integration for code analysis and generation',
    icon: SparklesIcon,
    image: 'openai.png',
    category: INTEGRATION_CATEGORIES.AI,
    config: {
      apiKey: {
        type: 'password',
        label: 'API Key',
        required: true,
        validation: /^sk-[a-zA-Z0-9]{48}$/,
        placeholder: 'sk-...',
        helpText: 'Get your API key from OpenAI Dashboard'
      }
    }
  },
  {
    id: 'aws',
    name: 'AWS',
    description: 'Amazon Web Services integration for cloud resources',
    icon: CloudIcon,
    image: 'aws.jpg',
    category: INTEGRATION_CATEGORIES.CLOUD,
    config: {
      accessKeyId: {
        type: 'text',
        label: 'Access Key ID',
        required: true,
        validation: /^[A-Z0-9]{20}$/,
        placeholder: 'AKIA...',
        helpText: 'AWS IAM Access Key ID'
      },
      secretAccessKey: {
        type: 'password',
        label: 'Secret Access Key',
        required: true,
        validation: /^[A-Za-z0-9/+=]{40}$/,
        placeholder: 'Enter your secret key',
        helpText: 'AWS IAM Secret Access Key'
      },
      region: {
        type: 'text',
        label: 'Region',
        required: true,
        placeholder: 'us-east-1',
        helpText: 'AWS Region'
      }
    }
  },
  {
    id: 'datadog',
    name: 'Datadog',
    description: 'Infrastructure and application monitoring',
    icon: ServerIcon,
    image: 'datadog.png',
    category: INTEGRATION_CATEGORIES.MONITORING,
    config: {
      apiKey: {
        type: 'password',
        label: 'API Key',
        required: true,
        validation: /^[a-zA-Z0-9]{32}$/,
        placeholder: 'Enter your API key',
        helpText: 'Find in Organization Settings > API Keys'
      },
      appKey: {
        type: 'password',
        label: 'Application Key',
        required: true,
        validation: /^[a-zA-Z0-9]{40}$/,
        placeholder: 'Enter your application key',
        helpText: 'Find in Organization Settings > Application Keys'
      }
    }
  }
]; 
===========================================
<renderer/src/constants/nodeTypes.js>
===========================================
import { 
  ArrowUpDown, 
  Code, 
  FileCog, 
  FileJson, 
  GitBranch, 
  RefreshCw, 
  MessageSquare, 
  TestTube,
  Database,
  Terminal,
  Rss,
  Hash,
  FileText,
  ListPlus
} from 'lucide-react';

// First import all node configs
import HTTPNodeConfig from '../components/diagram/utility/nodeConfigs/HTTPNodeConfig';
import FormatNodeConfig from '../components/diagram/utility/nodeConfigs/FormatNodeConfig';
import FileOpNodeConfig from '../components/diagram/utility/nodeConfigs/FileOpNodeConfig';
import ParserNodeConfig from '../components/diagram/utility/nodeConfigs/ParserNodeConfig';
import ConditionalNodeConfig from '../components/diagram/utility/nodeConfigs/ConditionalNodeConfig';
import IteratorNodeConfig from '../components/diagram/utility/nodeConfigs/IteratorNodeConfig';
import TestNodeConfig from '../components/diagram/utility/nodeConfigs/TestNodeConfig';
import DatabaseQueryNodeConfig from '../components/diagram/utility/nodeConfigs/DatabaseQueryNodeConfig';
import CommandNodeConfig from '../components/diagram/utility/nodeConfigs/CommandNodeConfig';
import PromptNodeConfig from '../components/diagram/utility/nodeConfigs/PromptNodeConfig';
import RSSNodeConfig from '../components/diagram/utility/nodeConfigs/RSSNodeConfig';
import CounterNodeConfig from '../components/diagram/utility/nodeConfigs/CounterNodeConfig';
import TextDisplayNodeConfig from '../components/diagram/utility/nodeConfigs/TextDisplayNodeConfig';
import CollectorNodeConfig from '../components/diagram/utility/nodeConfigs/CollectorNodeConfig';

// Then import all node components
import HTTPNode from '../components/diagram/nodes/HTTPNode';
import FormatNode from '../components/diagram/nodes/FormatNode';
import FileOpNode from '../components/diagram/nodes/FileOpNode';
import ParserNode from '../components/diagram/nodes/ParserNode';
import ConditionalNode from '../components/diagram/nodes/ConditionalNode';
import IteratorNode from '../components/diagram/nodes/IteratorNode';
import PromptNode from '../components/diagram/nodes/PromptNode';
import TestNode from '../components/diagram/nodes/TestNode';
import DatabaseQueryNode from '../components/diagram/nodes/DatabaseQueryNode';
import CommandNode from '../components/diagram/nodes/CommandNode';
import RSSNode from '../components/diagram/nodes/RSSNode';
import CounterNode from '../components/diagram/nodes/CounterNode';
import TextDisplayNode from '../components/diagram/nodes/TextDisplayNode';
import CollectorNode from '../components/diagram/nodes/CollectorNode';

export const NODE_CATEGORIES = {
  input: {
    label: 'Input/Output',
    color: 'orange'
  },
  transform: {
    label: 'Transform',
    color: 'purple'
  },
  flow: {
    label: 'Flow Control',
    color: 'yellow'
  },
  ai: {
    label: 'AI',
    color: 'red'
  },
  utility: {
    label: 'Utility',
    color: 'blue'
  },
  testing: {
    label: 'Testing',
    color: 'green'
  }
};

export const NODE_TYPES = {
  test: {
    type: 'test',
    label: 'Test Case',
    description: 'Validate response data against test conditions',
    category: 'testing',
    icon: TestTube,
    component: TestNode,
    config: TestNodeConfig,
    defaultData: {
      name: 'Test Case',
      tests: [],
      requireAll: true,
      continueOnFailure: false,
      timeout: 5000
    },
  },
  http: {
    type: 'http',
    label: 'HTTP Request',
    description: 'Make HTTP requests to external APIs',
    category: 'input',
    icon: ArrowUpDown,
    component: HTTPNode,
    config: HTTPNodeConfig,
    defaultData: {
      name: 'HTTP Request',
      method: 'GET',
      url: '',
      headers: [
        { id: 'default-content-type', key: 'Content-Type', value: 'application/json' }
      ],
      contentType: 'json',
      body: null
    },
  },
  format: {
    type: 'format',
    label: 'Format',
    description: 'Format and transform data using templates',
    category: 'transform',
    icon: Code,
    component: FormatNode,
    config: FormatNodeConfig,
    defaultData: {
      name: 'Format',
      template: '',
    },
  },
  fileop: {
    type: 'fileop',
    label: 'File Operation',
    description: 'Read from or write to files',
    category: 'input',
    icon: FileCog,
    component: FileOpNode,
    config: FileOpNodeConfig,
    defaultData: {
      name: 'File Operation',
      operation: 'read',
      path: '',
    },
  },
  parser: {
    type: 'parser',
    label: 'Parser',
    description: 'Parse data using JQ expressions (currently JSON only)',
    category: 'transform',
    icon: FileJson,
    component: ParserNode,
    config: ParserNodeConfig,
    defaultData: {
      name: 'Parser',
      format: 'json',
    },
  },
  conditional: {
    type: 'conditional',
    label: 'Conditional',
    description: 'Branch flow based on conditions',
    category: 'flow',
    icon: GitBranch,
    component: ConditionalNode,
    config: ConditionalNodeConfig,
    defaultData: {
      name: 'Conditional',
      conditions: [],
    },
  },
  iterator: {
    type: 'iterator',
    label: 'Iterator',
    description: 'Iterate through array or list items',
    category: 'flow',
    icon: RefreshCw,
    component: IteratorNode,
    config: IteratorNodeConfig,
    defaultData: {
      name: 'Iterator',
      inputType: 'json',
      testInput: '',
    },
  },
  prompt: {
    type: 'prompt',
    label: 'Prompt',
    description: 'Use an AI prompt to generate text',
    category: 'ai',
    icon: MessageSquare,
    component: PromptNode,
    config: PromptNodeConfig,
    defaultData: {
      name: 'Prompt',
      prompt: '',
      integration: 'anthropic',
    },
  },
  databaseQuery: {
    type: 'databaseQuery',
    label: 'Database Query',
    description: 'Execute SQL queries against a database',
    category: 'input',
    icon: Database,
    component: DatabaseQueryNode,
    config: DatabaseQueryNodeConfig,
    defaultData: {
      name: 'Database Query',
      query: 'SELECT * FROM table_name',
      parameters: [],
      timeout: 30000,
    },
  },
  command: {
    type: 'command',
    label: 'Command',
    description: 'Execute system commands',
    icon: Terminal,
    component: CommandNode,
    config: CommandNodeConfig,
    defaultData: {
      name: 'Command',
      command: '',
    },
    category: 'input'
  },
  rss: {
    type: 'rss',
    label: 'RSS Feed',
    description: 'Fetch and parse RSS/ATOM feeds',
    category: 'input',
    icon: Rss,
    component: RSSNode,
    config: RSSNodeConfig,
    defaultData: {
      name: 'RSS Feed',
      url: '',
      timeout: 30000,
      maxItems: 10,
      sortBy: 'published',
      sortDirection: 'desc'
    },
  },
  counter: {
    type: 'counter',
    label: 'Counter',
    description: 'Count the number of times input is received',
    category: 'utility',
    icon: Hash,
    component: CounterNode,
    config: CounterNodeConfig,
    defaultData: {
      name: 'Counter',
      incrementor: 0,
      limit: 0
    },
  },
  textDisplay: {
    type: 'textDisplay',
    label: 'Text Display',
    description: 'Display text with template support',
    category: 'utility',
    icon: FileText,
    component: TextDisplayNode,
    config: TextDisplayNodeConfig,
    defaultData: {
      name: 'Text Display',
      inputText: '',
      outputText: '',
      maxHeight: 400,
      maxWidth: 600,
    },
  },
  collector: {
    type: 'collector',
    label: 'Collector',
    category: 'utility',
    description: 'Collects values into a persistent array',
    color: 'blue',
    component: CollectorNode,
    config: CollectorNodeConfig,
    icon: ListPlus,
    defaultData: {
      path: '',
      description: '',
      collection: [],
      makeUnique: true
    }
  },
};

// Helper functions at the end
export const getNodeTypes = () => {
  return Object.fromEntries(
    Object.entries(NODE_TYPES).map(([key, value]) => [key, value.component])
  );
};

export const paletteItems = Object.values(NODE_TYPES)
  .sort((a, b) => a.type.localeCompare(b.type))
  .map(node => ({
    type: node.type,
    label: node.label,
    description: node.description,
    color: node.color,
    icon: node.icon,
  }));

export const getDefaultData = (type) => {
  return NODE_TYPES[type]?.defaultData || {};
};

export const getNodeColor = (type) => {
  const category = NODE_TYPES[type]?.category;
  return NODE_CATEGORIES[category]?.color || 'gray';
};

// Update generateNodeId in FlowContext
const typeToPrefix = {
  http: 'HTTP',
  parser: 'PRSR',
  conditional: 'COND',
  iterator: 'ITER',
  fileop: 'FILE',
  prompt: 'PRMT',
  test: 'TEST',
  databaseQuery: 'DBQ',
  format: 'FRMT',
  command: 'CMD',
  rss: 'RSS',
  counter: 'CNTR',
  textDisplay: 'TEXT',
  collector: 'COLL'
};
===========================================
<renderer/src/executor/FlowExecutor.js>
===========================================
import { findNextNodes } from '../utils/graphUtils';
import xml from '../utils/xml';
import regex from '../utils/regex';
import Handlebars from 'handlebars';
import formatter from '../utils/formatter';
import JQParser from '../utils/jq';
import HttpNode from './basic/HttpNode';
import FormatNode from './basic/FormatNode';
import FileNode from './basic/FileNode';
import ParserNode from './basic/ParserNode';
import ConditionalNode from './basic/ConditionalNode';
import IteratorNode from './basic/IteratorNode';
import TestNode from './basic/TestNode';
import CommandNode from './basic/CommandNode';
import DatabaseQueryNode from './basic/DatabaseQueryNode';
import RSSNode from './basic/RSSNode';
import PromptNode from './basic/PromptNode';
import CounterNode from './basic/CounterNode';
import TextDisplayNode from './basic/TextDisplayNode';
import CollectorNode from './basic/CollectorNode';
const jq = new JQParser();

export default class FlowExecutor {
  constructor(nodes, edges, addToHistory, addLog, setExecutingNodeIds, updateNodeData, setLastOutput, setLastInput, setEnvironmentVariable, environment, httpRequest, decrypt) {
    this.nodes = nodes;
    this.edges = edges;
    this.addAction = addToHistory;
    this.addLog = addLog;
    this.setExecutingNodeIds = setExecutingNodeIds;
    this.updateNodeData = updateNodeData;
    this.setLastOutput = setLastOutput;
    this.setLastInput = setLastInput;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.nodeOutputs = new Map();
    this.executionSequence = 1;
    this.loggedNodes = new Set();
    this.lastInput = null;
    this.stepDelay = 300;
    this.window = window;
    this.decrypt = decrypt;
    // Iterator state
    this.iteratorState = new Map(); // Map of nodeId -> { currentIndex, items }
    // Initialize executingNodes Set
    this.executingNodes = new Set();
    this.environment = environment;
    this.localEnvironment = { ...environment }; // Add local copy of environment
    this.httpNode = new HttpNode(
      this.getEnvVar.bind(this),
      this.setEnvironmentVariable,
      this.localEnvironment,
      (config) => httpRequest(config)
    );
    this.formatNode = new FormatNode(this.updateNodeData);
    this.fileNode = new FileNode(this.window);
    this.parserNode = new ParserNode();
    this.conditionalNode = new ConditionalNode(
      this.getEnvVar.bind(this),
      this.setEnvironmentVariable,
      this.localEnvironment
    );
    this.iteratorNode = new IteratorNode(this.updateNodeData, this.getEnvVar.bind(this));
    this.testNode = new TestNode();
    this.commandNode = new CommandNode();
    this.databaseQueryNode = new DatabaseQueryNode();
    this.counterNode = new CounterNode(this.updateNodeData);
    this.rssNode = new RSSNode(
      this.getEnvVar.bind(this),
      this.setEnvironmentVariable,
      this.localEnvironment,
      (config) => httpRequest(config)
    );
    this.promptNode = new PromptNode(
      this.getEnvVar.bind(this),
      this.setEnvironmentVariable,
      this.localEnvironment,
      (config) => httpRequest(config),
      this.updateNodeData,
      (apiKey) => decrypt(apiKey)
    );
    this.textDisplayNode = new TextDisplayNode(
      this.getEnvVar.bind(this),
      this.setEnvironmentVariable,
      this.localEnvironment,
      this.updateNodeData
    );
    this.collectorNode = new CollectorNode(
      this.getEnvVar.bind(this),
      this.setEnvironmentVariable,
      this.localEnvironment,
      this.updateNodeData
    );

    // Node executor mapping
    this.executors = {
      http: this.httpNode,
      format: this.formatNode,
      file: this.fileNode,
      parser: this.parserNode,
      conditional: this.conditionalNode,
      iterator: this.iteratorNode,
      test: this.testNode,
      command: this.commandNode,
      databaseQuery: this.databaseQueryNode,
      rss: this.rssNode,
      prompt: this.promptNode,
      counter: this.counterNode,
      textDisplay: this.textDisplayNode,
      collector: this.collectorNode
    };
  }

  // Update getEnvVar to use local environment
  getEnvVar(varName) {
    const name = varName.startsWith('$') ? varName.slice(1) : varName;
    return this.localEnvironment?.variables?.[name];
  }

  logAction(nodeType, status, message, details = null) {
    if (this.addAction) {
      const action = {
        type: nodeType.toUpperCase(),
        status,
        message,
        data: details,
        timestamp: new Date().toISOString()
      };
      this.addAction(action);
    }
  }

  async delay() {
    return new Promise(resolve => setTimeout(resolve, this.stepDelay));
  }

  async execute(updateNodeSequence, incrementSequence) {
    this.nodeOutputs.clear();
    this.resetIteratorState();
    
    try {
      // Get all nodes by levels
      const nodeLevels = this.getNodesByLevel();
      
      // Execute nodes level by level
      for (const level of nodeLevels) {
        
        // First, execute non-iterator nodes in this level
        const nonIteratorNodes = level.filter(nodeId => {
          const node = this.nodes.find(n => n.id === nodeId);
          return node.type !== 'iterator';
        });
  
        if (nonIteratorNodes.length > 0) {
          await Promise.all(nonIteratorNodes.map(nodeId => 
            this.executeNodeAtLevel(nodeId, updateNodeSequence, incrementSequence)
          ));
        }
  
        // Then handle iterator nodes sequentially
        const iteratorNodes = level.filter(nodeId => {
          const node = this.nodes.find(n => n.id === nodeId);
          return node.type === 'iterator';
        });
  
        for (const iteratorNodeId of iteratorNodes) {
          await this.executeIteratorAndDescendants(
            iteratorNodeId,
            updateNodeSequence,
            incrementSequence
          );
        }
      }
      
      return this.lastInput;
    } catch (error) {
      console.error('Workflow execution failed:', error);
      throw error;
    }
  }

  getNodesByLevel() {
    const levels = [];
    const visited = new Set();
    
    // Find start nodes (nodes with no incoming edges)
    const startNodes = this.nodes
      .filter(node => !this.edges.some(edge => edge.target === node.id))
      .map(node => node.id);
    
    if (startNodes.length > 0) {
      levels.push(startNodes);
      startNodes.forEach(nodeId => visited.add(nodeId));
    }

    // Build subsequent levels
    while (true) {
      const currentLevel = [];
      
      // Find nodes whose dependencies are all in previous levels
      this.nodes.forEach(node => {
        if (visited.has(node.id)) return;
        
        const dependencies = this.edges
          .filter(edge => edge.target === node.id)
          .map(edge => edge.source);
        
        if (dependencies.every(depId => visited.has(depId))) {
          currentLevel.push(node.id);
        }
      });
      
      if (currentLevel.length === 0) break;
      
      levels.push(currentLevel);
      currentLevel.forEach(nodeId => visited.add(nodeId));
    }
    
    return levels;
  }

  validateConditionalEdges(nodeId, sourceNodes) {
    // get edge name(s) connected to this node (edges where target is this node)
    const conditionalEdges = this.edges
      .filter(edge => edge.target === nodeId)
      .filter(edge => edge.source.includes('COND_'));

    // get input that comes from a conditional node
    let inputs = this.lastInput[nodeId]
    let conditionalInputNodes = Object.keys(inputs).filter(key => key.includes('COND_'));

    conditionalEdges.forEach(edge => {
      let srcHandle = edge.sourceHandle;
      let condInput = sourceNodes.find(node => node.id === edge.source);
      if(condInput && condInput.data.response.outputPath !== srcHandle) {
        let lastInput = this.lastInput
        lastInput[nodeId][edge.source] = null;
        this.setLastInput(lastInput);
        console.log("New Last Input: ", this.lastInput);
      } else {
        console.log("Cond Input is VALID ", condInput);
      }
    });
  }

  async executeNodeAtLevel(nodeId, updateNodeSequence, incrementSequence) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return;

    try {
      // Update executing nodes set
      this.executingNodes.add(nodeId);
      this.setExecutingNodeIds(new Set(this.executingNodes));
      await this.delay();
      
      // Update sequence
      updateNodeSequence(nodeId, this.executionSequence);
      this.executionSequence = incrementSequence();

      // Get input data from previous nodes
      const sourceNodeIds = this.edges
        .filter(edge => edge.target === nodeId)
        .map(edge => edge.source);
      
      const sourceNodes = this.nodes
        .filter(n => sourceNodeIds.includes(n.id))
        .map(n => ({
          id: n.id,
          type: n.type,
          data: this.nodeOutputs.get(n.id)
        }));

      // Create input context
      this.lastInput = {
        [nodeId]: sourceNodes.reduce((acc, source) => ({
          ...acc,
          [source.id]: source.data
        }), {})
      };
      
      // Update context if available
      if (this.setLastInput) {
        this.setLastInput(this.lastInput);
      }

      // Validate conditional edges before execution
      this.validateConditionalEdges(nodeId, sourceNodes);

      // Execute node using the appropriate executor
      const executor = this.executors[node.type];
      if (!executor) {
        throw new Error(`No executor found for node type: ${node.type}`);
      }

      const output = await executor.execute(node.data, this.lastInput[nodeId], sourceNodes, nodeId);
      this.nodeOutputs.set(nodeId, output);
      // Log output for visualization/debugging
      if (this.setLastOutput) {
        this.setLastOutput({
          nodeId: node.id,
          type: node.type,
          data: output,
          timestamp: new Date().toISOString(),
          iteration: output?.iteration || this.lastInput[nodeId]?.iteration,
          workflowContext: {
            iterationId: output?.iteration?.current ? `iteration_${output.iteration.current}` : undefined,
            parentNodeId: sourceNodes[0]?.id,
            sequence: node.type === 'iterator' ? 'start' : 
                     this.lastInput[nodeId]?.iteration ? `step_${this.lastInput[nodeId].iteration.current}` : undefined
          }
        });
      }

      // Get iteration info from input or result
      const iterationInfo = output?.iteration || this.lastInput[nodeId]?.iteration;
      
      // Create unique log key based on current node and iteration
      const logKey = `${node.type.toUpperCase()}_${node.id}${
        iterationInfo ? `_iter_${iterationInfo.current}` : ''
      }`;

      // Log the execution result
      const logEntry = {
        name: node.data.name || node.id,
        source: logKey,
        sourceNodes: sourceNodes.map(n => n.id).join(', '),
        data: output,
        timestamp: new Date().toISOString(),
        iteration: iterationInfo
      };

      this.addLog(logEntry);
      this.loggedNodes.add(logKey);

      // Handle iterator nodes
      if (output?.isIterator) {
        // For now, we'll handle iterators sequentially within their level
        // This might need to be revisited for more complex iterator scenarios
        const iterationOutput = await this.handleIteratorNode(
          node,
          output,
          updateNodeSequence,
          incrementSequence
        );
        this.nodeOutputs.set(nodeId, iterationOutput);
      }

      // Clear this node from executing set
      this.executingNodes.delete(nodeId);
      this.setExecutingNodeIds(new Set(this.executingNodes));

      return output;
    } catch (error) {
      console.error(`Error executing node ${nodeId}:`, error);
      // Clear executing state on error
      this.executingNodes.delete(nodeId);
      this.setExecutingNodeIds(new Set(this.executingNodes));
      throw error;
    }
  }

  // Helper method for handling iterator nodes
  async handleIteratorNode(node, output, updateNodeSequence, incrementSequence) {
    if (!output?.iteration?.hasMore) {
      return output;
    }
  
    return output; // Return the current iteration output
  }


  async executeIteratorAndDescendants(nodeId, updateNodeSequence, incrementSequence) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return;
  
    try {
      // Get all downstream nodes
      const downstreamNodes = this.getDownstreamNodes(nodeId);
      
      // Get initial iterator output
      let currentOutput = await this.executeNodeAtLevel(nodeId, updateNodeSequence, incrementSequence);
      
      // If not an iterator or no output, return
      if (!currentOutput?.isIterator) return currentOutput;
  
      // Continue while the iterator has more items
      while (currentOutput?.shouldContinue) {
        // Store the current item's output
        const iterationOutput = currentOutput;
        
        // Process all downstream nodes for this iteration
        for (const downstreamId of downstreamNodes) {
          const downstreamNode = this.nodes.find(n => n.id === downstreamId);
          if (!downstreamNode) continue;
  
          // If downstream node is an iterator, handle nested iteration
          if (downstreamNode.type === 'iterator') {
            let innerOutput = await this.executeNodeAtLevel(
              downstreamId,
              updateNodeSequence,
              incrementSequence
            );
            
            // Process all items in the inner iterator
            while (innerOutput?.shouldContinue) {
              innerOutput = await this.executeNodeAtLevel(
                downstreamId,
                updateNodeSequence,
                incrementSequence
              );
            }
          } else {
            // For non-iterator nodes, execute once with current iteration data
            await this.executeNodeAtLevel(
              downstreamId,
              updateNodeSequence,
              incrementSequence
            );
          }
        }
  
        // Get next item from iterator
        currentOutput = await this.executeNodeAtLevel(
          nodeId,
          updateNodeSequence,
          incrementSequence
        );
      }
  
      return currentOutput;
    } catch (error) {
      console.error(`Error executing iterator node ${nodeId}:`, error);
      throw error;
    }
  }
  // Update resetIteratorState to use the iterator node's method
  resetIteratorState(nodeId) {
    if (nodeId) {
      this.iteratorNode.resetState(nodeId);
    } else {
      for (const [type, executor] of Object.entries(this.executors)) {
        if (executor.resetState) {
          executor.resetState();
        }
      }
    }
  }

  // Helper functions
  getDownstreamNodes(nodeId, visited = new Set()) {
    visited.add(nodeId);
    
    const directDownstream = this.edges
      .filter(edge => edge.source === nodeId)
      .map(edge => edge.target);
      
    directDownstream.forEach(id => {
      if (!visited.has(id)) {
        const furtherDownstream = this.getDownstreamNodes(id, visited);
        directDownstream.push(...furtherDownstream);
      }
    });
    
    return Array.from(new Set(directDownstream));
  }

  decodeHTMLEntities(text) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
  }

  simplifyXmlObject(obj) {
    // Base case: if we have a content property, return its value
    if (obj && typeof obj === 'object' && 'content' in obj) {
      return obj.content;
    }

    // If we have children array, process each child
    if (obj && obj.children && Array.isArray(obj.children)) {
      const result = {};
      
      // Process each child
      obj.children.forEach(child => {
        // Get the first (and should be only) key of the child object
        const key = Object.keys(child)[0];
        
        // If we already have this key and it's not an array, convert to array
        if (key in result) {
          if (!Array.isArray(result[key])) {
            result[key] = [result[key]];
          }
          result[key].push(this.simplifyXmlObject(child[key]));
        } else {
          // Otherwise just process the child
          result[key] = this.simplifyXmlObject(child[key]);
        }
      });
      
      return result;
    }

    // If it's an object but not one of the above cases, process each property
    if (obj && typeof obj === 'object') {
      const result = {};
      for (const [key, value] of Object.entries(obj)) {
        result[key] = this.simplifyXmlObject(value);
      }
      return result;
    }

    // Default case: return the value as is
    return obj;
  }
}
===========================================
<renderer/src/executor/basic/CollectorNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class CollectorNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment, updateNodeData) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
    this.updateNodeData = updateNodeData;
  }

  // Helper function for evaluating templates with environment variables
  evaluateEnvTemplate(template, context) {
    if (!template.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined) {
            console.warn(`Environment variable ${path} not found`);
            value = '';
          }
        } else {
          value = jq.evaluate(path, context);
        }
        
        result = result.replace(match, value);
      }
    }
    return result;
  }

  async execute(data, inputData = null, sourceNodes = [], nodeId) {
    let collection = data.collection || [];
    console.log('Collector node executing with data:', data);
    console.log('Collector Node ID:', nodeId);

    try {
      const { path } = data;

      if (!path) {
        return formatter.errorResponse('Collection path is required but was not specified');
      }

      // Build context from source nodes
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      // Extract value using the specified path
      let valueToCollect;
      try {
        // Check for templates first
        if (path.includes('{{')) {
          valueToCollect = this.evaluateEnvTemplate(path, context);
        } 
        // If no template or template evaluation returned undefined, try JQ
        else if (path.includes('.')) {
          valueToCollect = jq.evaluate(path, context);
        } 
        // If neither, use the raw path value
        else {
          valueToCollect = path;
        }

        console.log('Collecting value:', { path, value: valueToCollect });
      } catch (error) {
        console.error('Value extraction failed:', error, { path, context });
        return formatter.errorResponse(`Value extraction failed: ${error.message}`);
      }

      // Add the value to the collection
      collection.push(valueToCollect);

      if (data.makeUnique) {
        collection = [...new Set(collection)];
      }

      // Update the node data with the new collection
      let temp_collection = [];
      if(data.batch && data.batch_size === collection.length){
        temp_collection = collection;
        console.log(`Batch size met for node ${nodeId} (${data.batch_size}). Emptying collection.`);
        collection = [];
      }

      this.updateNodeData(nodeId, 'collection', collection);


      if(data.batch){
        if(data.batch_size == collection.length){
          return formatter.standardResponse(true, temp_collection);
        }else{
          return formatter.standardResponse(true, null);
        }
      }

      return formatter.standardResponse(true, collection);

    } catch (error) {
      console.error('Collector node execution failed:', error);
      return formatter.errorResponse(error.message);
    }
  }
} 
===========================================
<renderer/src/executor/basic/CommandNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class CommandNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
  }

  evaluateTemplate(template, context) {
    if (!template || !template.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined) {
            console.warn(`Environment variable ${path} not found`);
            value = '';
          }
        } else {
          value = jq.evaluate(path, context);
        }
        
        result = result.replace(match, String(value));
      }
    }
    return result;
  }

  async execute(data, inputData = null, sourceNodes = []) {
    try {
      const { 
        command = '', 
        workingDirectory,
        timeout = 30000,
        environmentVars = []
      } = data;

      // Evaluate command template
      const evaluatedCommand = this.evaluateTemplate(command, inputData);
      
      // Execute command through IPC
      const result = await window.api.executeCommand(evaluatedCommand, {
        workingDirectory,
        timeout,
        environmentVars
      });

      if (!result.success) {
        throw new Error(result.error);
      }

      return formatter.standardResponse(true, result.data);
      
    } catch (error) {
      return formatter.errorResponse(error.message);
    }
  }
}
===========================================
<renderer/src/executor/basic/ConditionalNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

// Define supported operators and their validation rules
const OPERATORS = {
  '===': { label: 'equals (strict)', requiresValue: true },
  '==': { label: 'equals', requiresValue: true },
  '!==': { label: 'not equals (strict)', requiresValue: true },
  '!=': { label: 'not equals', requiresValue: true },
  '>': { label: 'greater than', requiresValue: true, numeric: true },
  '>=': { label: 'greater than or equal', requiresValue: true, numeric: true },
  '<': { label: 'less than', requiresValue: true, numeric: true },
  '<=': { label: 'less than or equal', requiresValue: true, numeric: true },
  'contains': { label: 'contains', requiresValue: true, string: true },
  '!contains': { label: 'does not contain', requiresValue: true, string: true },
  'startsWith': { label: 'starts with', requiresValue: true, string: true },
  'endsWith': { label: 'ends with', requiresValue: true, string: true },
  'matches': { label: 'matches regex', requiresValue: true, string: true },
  'isNull': { label: 'is null', requiresValue: false },
  'notNull': { label: 'is not null', requiresValue: false },
  'isEmpty': { label: 'is empty', requiresValue: false },
  'notEmpty': { label: 'is not empty', requiresValue: false }
};

export default class ConditionalNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment;
    this.evaluationCache = new Map();
  }

  resetCache() {
    this.evaluationCache.clear();
  }

  evaluateEnvTemplate(template, context) {
    if (!template.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined) {
            console.warn(`Environment variable ${path} not found`);
            value = '';
          }
        } else {
          value = jq.evaluate(path, context);
        }
        
        result = result.replace(match, value);
      }
    }
    return result;
  }

  validateCondition(condition) {
    const { field, operator, value } = condition;
    
    if (!field) {
      throw new Error('Field is required for condition');
    }
    if (!operator) {
      throw new Error('Operator is required for condition');
    }
    if (!OPERATORS[operator]) {
      throw new Error(`Unsupported operator: ${operator}`);
    }
    
    const operatorRules = OPERATORS[operator];
    if (operatorRules.requiresValue && value === undefined) {
      throw new Error(`Value is required for operator: ${operator}`);
    }
  }

  evaluateExpression(expression, context) {
    if (!expression) return null;
    
    const cacheKey = `${expression}-${JSON.stringify(context)}`;
    if (this.evaluationCache.has(cacheKey)) {
      return this.evaluationCache.get(cacheKey);
    }

    try {
      const result = this.evaluateEnvTemplate(expression, context);
      this.evaluationCache.set(cacheKey, result);
      return result;
    } catch (error) {
      console.warn(`Expression evaluation failed: ${error.message}`);
      return expression;
    }
  }

  compareValues(field, operator, value) {
    // Handle null/undefined cases
    if (field === null || field === undefined) {
      switch (operator) {
        case 'isNull': return true;
        case 'notNull': return false;
        case '==': return value === null;
        case '===': return value === null;
        default: return false;
      }
    }

    // Handle empty checks
    if (operator === 'isEmpty') {
      return field === '' || 
             field === null || 
             field === undefined ||
             (Array.isArray(field) && field.length === 0) ||
             (typeof field === 'object' && Object.keys(field).length === 0);
    }
    if (operator === 'notEmpty') {
      return !this.compareValues(field, 'isEmpty', null);
    }

    // Handle numeric comparisons
    if (OPERATORS[operator]?.numeric) {
      const numField = Number(field);
      const numValue = Number(value);
      if (isNaN(numField) || isNaN(numValue)) {
        throw new Error('Numeric comparison requires valid numbers');
      }
      switch (operator) {
        case '>': return numField > numValue;
        case '>=': return numField >= numValue;
        case '<': return numField < numValue;
        case '<=': return numField <= numValue;
        default: return false;
      }
    }

    // Handle string operations
    if (OPERATORS[operator]?.string) {
      const strField = String(field);
      const strValue = String(value);
      switch (operator) {
        case 'contains': return strField.includes(strValue);
        case '!contains': return !strField.includes(strValue);
        case 'startsWith': return strField.startsWith(strValue);
        case 'endsWith': return strField.endsWith(strValue);
        case 'matches': 
          try {
            return new RegExp(strValue).test(strField);
          } catch (e) {
            throw new Error(`Invalid regex pattern: ${e.message}`);
          }
        default: return false;
      }
    }

    // Handle equality
    switch (operator) {
      case '===': return field === value;
      case '==': return field == value;
      case '!==': return field !== value;
      case '!=': return field != value;
      default: return false;
    }
  }

  async execute(data, inputData, sourceNodes) {
    try {
      const { conditions = [], ignoreEmptyInput = true } = data;
      this.resetCache();

      // If ignoreEmptyInput is true and inputData is empty/null, skip evaluation
      if (ignoreEmptyInput && (!inputData || Object.keys(inputData).length === 0)) {
        console.log('Skipping conditional evaluation - empty input data');
        return formatter.standardResponse(true, {
          success: true,
          outputPath: 'output-false',
          data: inputData,
          evaluation: {
            result: false,
            skipped: true,
            reason: 'empty_input'
          }
        });
      }

      // Build context from source nodes
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      // Log the evaluation context
      console.log('Executing Conditional node with context:', {
        conditions,
        context,
        localEnvironment: this.localEnvironment,
        ignoreEmptyInput
      });

      if (!conditions.length) {
        return formatter.standardResponse(true, {
          success: true,
          outputPath: 'output-false',
          data: inputData
        });
      }

      for (const condition of conditions) {
        try {
          this.validateCondition(condition);
          
          const evaluatedField = this.evaluateExpression(condition.field, context);
          const evaluatedValue = condition.value ? 
            this.evaluateExpression(condition.value, context) : 
            null;
          

          const result = this.compareValues(
            evaluatedField, 
            condition.operator, 
            evaluatedValue
          );
          
          if (result) {
            return formatter.standardResponse(true, {
              success: true,
              outputPath: 'output-true',
              data: inputData,
              evaluation: {
                field: condition.field,
                operator: condition.operator,
                value: condition.value,
                evaluatedField,
                evaluatedValue,
                result: true
              }
            });
          }
        } catch (error) {
          console.error('Condition evaluation failed:', error, {
            condition,
            context
          });
        }
      }

      return formatter.standardResponse(true, {
        success: true,
        outputPath: 'output-false',
        data: inputData,
        evaluation: {
          result: false,
          evaluatedConditions: conditions.length
        }
      });

    } catch (error) {
      console.error('Conditional node execution failed:', error);
      return formatter.errorResponse(error.message);
    }
  }
}
===========================================
<renderer/src/executor/basic/CounterNode.js>
===========================================
import formatter from '../../utils/formatter';

export default class CounterNode {
    constructor(updateNodeData) {
      this.updateNodeData = updateNodeData;
      this.lastIterationContext = null;
      this.counterCache = new Map(); // Cache for counter values
    }
  
    async execute(data, inputData = null, sourceNodes, nodeId) {
      try {
        // Get the current incrementor value from cache or node data
        let incrementor = this.counterCache.get(nodeId) ?? parseInt(data.incrementor || 0, 10);
        
        // Get iteration context from source nodes
        const iteratorNode = sourceNodes?.find(node => 
          node.data?.iteration && 
          typeof node.data.iteration.current === 'number'
        );
        
        const currentIteration = iteratorNode?.data?.iteration?.current;

        // Debug logging
        console.log('Counter execution:', {
          currentIteration,
          lastContext: this.lastIterationContext,
          incrementor,
          nodeId,
          cached: this.counterCache.get(nodeId),
          inputData: inputData
        });

        // Only increment if we're in a new iteration or not in an iteration
        if (currentIteration === undefined || 
            this.lastIterationContext !== currentIteration) {
          
          // Store the current iteration
          this.lastIterationContext = currentIteration;
          
          // Count non-null inputs
          let validInputs = 0;
          if (inputData) {
            Object.values(inputData).forEach(input => {
              if (input !== null && input !== undefined) {
                validInputs++;
              }
            });
          }
          
          // Check if limit is reached before incrementing
          if (data.limit && incrementor >= data.limit) {
            return formatter.errorResponse('Counter limit reached');
          }

          // Increment the counter by the number of valid inputs
          const newValue = incrementor + validInputs;
          
          // Update both cache and node data
          this.counterCache.set(nodeId, newValue);
          await this.updateNodeData(nodeId, 'incrementor', newValue);

          // Verify the update
          console.log('Counter updated:', {
            oldValue: incrementor,
            newValue,
            nodeId,
            cached: this.counterCache.get(nodeId),
            validInputs
          });

          return formatter.standardResponse({
            incrementor: newValue,
            limit: data.limit,
            id: nodeId
          });
        }

        // If we're in the same iteration, return the current value without incrementing
        return formatter.standardResponse({
          incrementor: incrementor,
          limit: data.limit,
          id: nodeId
        });
      } catch (error) {
        console.error('Counter node error:', error);
        return formatter.errorResponse(error.message);
      }
    }
  
    resetCounter(data) {
      if (data) {
        this.lastIterationContext = null;
        this.counterCache.delete(data.id);
        this.updateNodeData(data.id, 'incrementor', 0);
      }
    }
  }
===========================================
<renderer/src/executor/basic/DatabaseQueryNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class DatabaseQueryNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
  }

  async execute(data, inputData) {
    try {
      console.log('DatabaseQueryNode executing with data:', {
        ...data,
        password: data.password ? '[REDACTED]' : undefined
      });

      const { connectionId, query = '', parameters = [] } = data;
      
      if (!connectionId) {
        return formatter.errorResponse('No database connection selected');
      }

      if (!query || !query.trim()) {
        console.log('Query is empty or undefined:', { query, dataType: typeof query });
        return formatter.errorResponse('Query cannot be empty');
      }

      // Process any template variables in the query
      let processedQuery = query;
      let processedParams = [];

      try {
        // Replace {{variable}} templates in query
        // Replace {{variable}} templates in query
        processedQuery = query.replace(/\{\{(.*?)\}\}/g, (match, path) => {
          try {
            const value = jq.evaluate(path.trim(), inputData);
            // Handle different value types
            if (value === null || value === undefined) {
              return 'NULL';
            }
            if (typeof value === 'number') {
              return value;
            }
            if (typeof value === 'boolean') {
              return value ? 1 : 0;
            }
            if (Array.isArray(value) || typeof value === 'object') {
              return `'${JSON.stringify(value)}'`; // Single quotes for JSON
            }
            // Escape single quotes and wrap in single quotes
            return `'${value.toString().replace(/'/g, "''")}'`; // Use single quotes, escape internal single quotes
          } catch (error) {
            throw new Error(`Failed to process template ${match}: ${error.message}`);
          }
        });

        // Process parameter values
        parameters.forEach(param => {
          if (!param.value) {
            throw new Error(`Parameter "${param.name}" has no value`);
          }
          const value = jq.evaluate(param.value, inputData);
          processedParams.push(value);
        });

        console.log('Executing query:', {
          connectionId,
          processedQuery,
          processedParams,
          originalQuery: query
        });

      } catch (error) {
        return formatter.errorResponse(`Query template processing failed: ${error.message}`);
      }

      try {
        // Execute query through IPC
        const result = await window.api.invoke('nodes.database.query', {
          connectionId,
          query: processedQuery,
          parameters: processedParams
        });

        if (!result.success) {
          throw new Error(result.error);
        }

        return formatter.standardResponse(true, {
          success: true,
          rowCount: result.data.rowCount,
          rows: result.data.rows,
          fields: result.data.fields
        });
      } catch (error) {
        return formatter.errorResponse(`Database query failed: ${error.message}`);
      }
    } catch (error) {
      return formatter.errorResponse(error.message);
    }
  }
} 
===========================================
<renderer/src/executor/basic/FileNode.js>
===========================================
import formatter from '../../utils/formatter';

export default class FileNode {
  async execute(data, inputData) {
    try {
      const { operation, fileName, content } = data;

      switch (operation) {
        case 'read':
          return {
            success: true,
            operation: 'read',
            fileName,
            content,
            timestamp: new Date().toISOString()
          };

        case 'write':
          // Create a blob from the input data
          let contentToWrite = inputData;
          
          // Convert to string if it's an object
          if (typeof inputData === 'object') {
            contentToWrite = JSON.stringify(inputData, null, 2);
          }

          const blob = new Blob([contentToWrite], { type: 'text/plain' });
          const url = window.URL.createObjectURL(blob);
          
          // Create a temporary link and trigger download
          const link = document.createElement('a');
          link.href = url;
          link.download = fileName || 'output.txt';
          document.body.appendChild(link);
          link.click();
          
          // Cleanup
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);

          return {
            success: true,
            operation: 'write',
            fileName,
            timestamp: new Date().toISOString()
          };

        default:
          throw new Error(`Unsupported file operation: ${operation}`);
      }
    } catch (error) {
      return formatter.errorResponse(`File operation failed: ${error.message}`);
    }
  }
} 
===========================================
<renderer/src/executor/basic/FormatNode.js>
===========================================
import Handlebars from 'handlebars';
import formatter from '../../utils/formatter';
import xml from '../../utils/xml';

export default class FormatNode {
  constructor(updateNodeData) {
    this.updateNodeData = updateNodeData;
  }

  decodeHTMLEntities(text) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
  }

  async execute(data, inputData, sourceNodes) {
    try {
      // Ensure node has an ID
      const nodeId = data.id || 'FORMAT_01';
      
      const { template, formatType } = data;
      if (!template) {
        return formatter.errorResponse('Template is missing', nodeId);
      }
  
      // Process source data
      const sourceData = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};
  
      // Get the most recent source node's data
      const mostRecentSource = sourceNodes?.[sourceNodes.length - 1];
      const primaryData = mostRecentSource?.data?.response || inputData;
  
      // Create template context with multiple ways to access data
      const templateContext = {
        sourceData,
        inputData: primaryData,
        data: primaryData,
        raw: sourceData
      };
  
      console.log('Format node template context:', templateContext); // Debug log
  
      // Execute template
      const compiled = Handlebars.compile(template);
      let result = compiled(templateContext);
      result = this.decodeHTMLEntities(result);
  
      // Parse based on formatType
      let parsedResult;
      switch (formatType?.toLowerCase()) {
        case 'json':
          try {
            parsedResult = JSON.parse(result);
          } catch (e) {
            console.error('JSON parsing failed:', e);
            parsedResult = result;
          }
          break;
        
        case 'xml':
          try {
            parsedResult = xml.parse(result);
          } catch (e) {
            console.error('XML parsing failed:', e);
            parsedResult = result;
          }
          break;
        
        default:
          parsedResult = result;
      }
  
      // Update node data if available
      if (this.updateNodeData) {
        await this.updateNodeData(nodeId, 'lastOutput', {
          sourceData,
          output: parsedResult,
          timestamp: new Date().toISOString()
        });
      }
  
      return formatter.standardResponse(true, parsedResult, null, nodeId);
  
    } catch (error) {
      console.error('Format node error:', error);
      return formatter.errorResponse(error.message, data.id || 'FORMAT_01');
    }
  }
} 
===========================================
<renderer/src/executor/basic/HttpNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class HttpNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment, httpRequest) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
    this.httpRequest = httpRequest;
  }

  // Helper function for evaluating templates with environment variables
  evaluateEnvTemplate(template, context) {
    if (!template.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined) {
            console.warn(`Environment variable ${path} not found`);
            value = '';
          }
        } else {
          value = jq.evaluate(path, context);
        }
        
        result = result.replace(match, value);
      }
    }
    return result;
  }

  async execute(data, inputData = null, sourceNodes = []) {
    try {
      const { method = 'GET', url, headers = [], params = [], body, environmentVars = [] } = data;
      
      // Log the environment state at execution time
      console.log('Executing HTTP node with environment:', {
        localEnvironment: this.localEnvironment,
        environmentVars
      });

      if (!url) {
        return formatter.errorResponse('URL is required but was not specified');
      }

      // Build context from source nodes
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      // Template the URL
      let templatedUrl = url;
      try {
        templatedUrl = this.evaluateEnvTemplate(url, context);
        console.log('Templated URL:', { original: url, templated: templatedUrl });
      } catch (error) {
        console.error('URL templating failed:', error, { url, context });
        return formatter.errorResponse(`URL templating failed: ${error.message}`);
      }

      // Template and convert headers array to object
      const headerObj = headers.reduce((acc, { key, value }) => {
        if (key && value) {
          try {
            const templatedKey = this.evaluateEnvTemplate(key, context);
            const templatedValue = this.evaluateEnvTemplate(value, context);
            acc[templatedKey] = templatedValue;
          } catch (error) {
            console.error('Header templating failed:', error);
            acc[key] = value;
          }
        }
        return acc;
      }, {});

      // Template and convert params array to URLSearchParams
      const templatedParams = params
        .filter(({ key, value }) => key && value)
        .map(({ key, value }) => {
          try {
            const templatedKey = this.evaluateEnvTemplate(key, context);
            const templatedValue = this.evaluateEnvTemplate(value, context);
            return [templatedKey, templatedValue];
          } catch (error) {
            console.error('Param templating failed:', error);
            return [key, value];
          }
        });

      const searchParams = new URLSearchParams(templatedParams);
      const fullUrl = `${templatedUrl}${searchParams.toString() ? '?' + searchParams.toString() : ''}`;

      // Prepare request config for API call
      const requestConfig = {
        method,
        url: fullUrl,
        headers: {
          'Content-Type': 'application/json',
          ...headerObj
        },
      };

      // Only add body for POST, PUT, PATCH
      if (['POST', 'PUT', 'PATCH'].includes(method) && body) {
        try {
          const templatedBody = this.evaluateEnvTemplate(body, context);
          requestConfig.data = templatedBody;
        } catch (error) {
          console.error('Body templating failed:', error);
          requestConfig.data = body;
        }
      }

      console.log('Making request with:', requestConfig);

      // Use the instance's httpRequest method
      const response = await this.httpRequest(requestConfig);
      
      if (!response.success) {
        throw new Error(response.error?.message || 'Request failed');
      }

      const result = {
        status: response.data.status,
        headers: response.data.headers,
        data: response.data.data
      };

      const formattedResult = formatter.standardResponse(true, result);

      // Handle environment variable setting
      if (environmentVars?.length > 0) {
        for (const envVar of environmentVars) {
          const variableName = envVar.variable === 'CREATE_NEW' ? envVar.newVariableName : envVar.variable;
          
          if (variableName && envVar.value) {
            try {
              const envContext = {
                response: result,
                ...context
              };

              const templatedValue = this.evaluateEnvTemplate(envVar.value, envContext);
              console.log('Setting environment variable:', {
                name: variableName,
                value: templatedValue,
                template: envVar.value,
                context: envContext
              });
              
              // Update both global and local environment
              if (this.setEnvironmentVariable) {
                this.setEnvironmentVariable(variableName, templatedValue);
                
                // Update local environment immediately
                if (!this.localEnvironment.variables) {
                  this.localEnvironment.variables = {};
                }
                this.localEnvironment.variables[variableName] = templatedValue;
              }
            } catch (error) {
              console.error('Environment variable setting failed:', error, {
                variable: envVar,
                context: context
              });
            }
          }
        }
      }

      return formattedResult;

    } catch (error) {
      console.error('HTTP node execution failed:', error);
      return formatter.errorResponse(error.message);
    }
  }
}
===========================================
<renderer/src/executor/basic/IteratorNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class IteratorNode {
  constructor(updateNodeData, getEnvVar) {
    this.updateNodeData = updateNodeData;
    this.getEnvVar = getEnvVar;
    this.iteratorState = new Map();
  }

  resetState(nodeId) {
    if (nodeId) {
      this.iteratorState.delete(nodeId);
    } else {
      this.iteratorState.clear();
    }
  }

  evaluateEnvTemplate(template, context) {
    if (!template?.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined) {
            console.warn(`Environment variable ${path} not found`);
            value = '';
          }
        } else {
          value = jq.evaluate(path, context);
        }
        
        result = result.replace(match, value);
      }
    }
    return result;
  }

  async execute(data, inputData) {
    try {
      const nodeId = data.id;
      const mode = data.mode || 'input';
      
      let itemsToIterate;
      if (mode === 'custom') {
        itemsToIterate = data.outputList;
      } else if (mode === 'input' && inputData) {
        // Handle both direct array input and RSS feed items
        itemsToIterate = inputData?.response?.items || data.outputList || [];
        
        // If array path is specified, try to extract array using it
        if (data.arrayPath) {
          try {
            itemsToIterate = jq.evaluate(data.arrayPath, inputData);
            if (!Array.isArray(itemsToIterate)) {
              throw new Error(`Path ${data.arrayPath} did not resolve to an array`);
            }
          } catch (error) {
            console.error('Array path evaluation failed:', error);
            return formatter.errorResponse(`Failed to get array from path: ${error.message}`);
          }
        }
      } else {
        itemsToIterate = [];
      }
  
      if (!Array.isArray(itemsToIterate)) {
        return formatter.errorResponse('Items to iterate must be an array');
      }
  
      let state = this.iteratorState.get(nodeId);
      const isInnerIterator = Boolean(inputData?.isIterator);
      const parentIteration = inputData?.isIterator ? inputData.iteration.current : 1;
  
      // Initialize state for new iteration cycle
      if (!state || 
          (!isInnerIterator && state.currentIndex >= state.items.length) ||
          (isInnerIterator && (state.parentIteration !== parentIteration || !inputData.shouldContinue))) {
        
        state = {
          currentIndex: 0,
          parentIteration,
          items: itemsToIterate.slice(),
          totalItems: itemsToIterate.length,
          isInnerIterator,
          completed: false
        };
        this.iteratorState.set(nodeId, state);
        
        if (mode === 'custom') {
          await this.updateNodeData(nodeId, 'outputList', itemsToIterate);
        }
      }
  
      // Check for completion
      if (state.currentIndex >= state.items.length) {
        if (!state.isInnerIterator || !inputData?.shouldContinue) {
          this.iteratorState.delete(nodeId);
          await this.updateNodeData(nodeId, 'result', null);
          await this.updateNodeData(nodeId, 'progress', {
            current: state.totalItems,
            total: state.totalItems,
            percentage: 100
          });
          return formatter.standardResponse(true, {
            complete: true,
            processedItems: state.totalItems
          });
        }
        
        // Reset inner iterator for next parent item
        state.currentIndex = 0;
        state.parentIteration = parentIteration;
        this.iteratorState.set(nodeId, state);
      }
  
      const currentItem = state.items[state.currentIndex];
      
      // Apply any template transformations to the current item
      let processedItem = currentItem;
      if (data.itemTemplate) {
        try {
          const context = { ...inputData, item: currentItem };
          processedItem = this.evaluateEnvTemplate(data.itemTemplate, context);
        } catch (error) {
          console.error('Item templating failed:', error);
        }
      }
      
      await this.updateNodeData(nodeId, 'result', processedItem);
      await this.updateNodeData(nodeId, 'progress', {
        current: state.currentIndex + 1,
        total: state.totalItems,
        percentage: Math.round(((state.currentIndex + 1) / state.totalItems) * 100)
      });
  
      state.currentIndex++;
      this.iteratorState.set(nodeId, state);
  
      const hasMore = state.currentIndex < state.items.length;
      
      return {
        ...formatter.standardResponse(true, processedItem),
        isIterator: true,
        shouldContinue: hasMore || (state.isInnerIterator && inputData?.shouldContinue),
        iteration: {
          current: state.currentIndex,
          total: state.totalItems,
          hasMore: hasMore || (state.isInnerIterator && inputData?.shouldContinue)
        },
        progress: {
          current: state.currentIndex,
          total: state.totalItems,
          percentage: Math.round((state.currentIndex / state.totalItems) * 100)
        }
      };
  
    } catch (error) {
      console.error('Iterator node execution failed:', error);
      return formatter.errorResponse(error.message);
    }
  }
}
===========================================
<renderer/src/executor/basic/ParserNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class ParserNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
  }

  async execute(data, inputData) {
    try {
      console.log('Parser executing with data:', data);
      console.log('Input data:', inputData);

      const { template = '' } = data;

      if (!template.trim()) {
        return formatter.errorResponse('Template expression cannot be empty');
      }

      // Split the template path
      const pathParts = template.split('.');
      
      // Get the source node ID
      const sourceNodeId = pathParts[0];
      
      // Get the source data by traversing the path
      let sourceData = inputData;
      for (const part of pathParts) {
        if (sourceData === undefined) break;
        sourceData = sourceData[part];
      }

      console.log('Source data for parsing:', sourceData);

      if (!sourceData) {
        return formatter.errorResponse('No valid source data found');
      }

      try {
        // No need to adjust template since we've already traversed the path
        const result = sourceData;
        console.log('Parser result:', result);
        return formatter.standardResponse(true, result);
      } catch (error) {
        console.error('Parser error:', error);
        return formatter.errorResponse(`Parser error: ${error.message}`);
      }
    } catch (error) {
      console.error('Parser execution error:', error);
      return formatter.errorResponse(error.message);
    }
  }
} 
===========================================
<renderer/src/executor/basic/PromptNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class PromptNode {
  constructor(getEnvVar, setEnvVar, localEnvironment, httpRequest, updateNodeData, decrypt) {
    this.getEnvVar = getEnvVar;
    this.setEnvVar = setEnvVar;
    this.localEnvironment = localEnvironment || { variables: {} };
    this.httpRequest = httpRequest;
    this.updateNodeData = updateNodeData;
    this.decrypt = decrypt;
    this.queryBuilders = {
      anthropic: {
        buildRequest: (prompt, apiKey) => ({
          method: 'POST',
          url: 'https://api.anthropic.com/v1/messages',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01'
          },
          data: {
            model: 'claude-3-opus-20240229',
            max_tokens: 4096,
            messages: [{
              role: 'user',
              content: prompt
            }],
            system: "You are a helpful AI assistant. Provide clear, concise responses."
          }
        }),
        parseResponse: (response) => {
          if (response?.data?.error) {
            throw new Error(response.data.error.message || 'API Error');
          }
          if (!response?.data?.data?.content?.[0]?.text) {
            throw new Error('Invalid response format from Anthropic API');
          }
          return response.data.data.content[0].text;
        }
      },
      openai: {
        buildRequest: (prompt, apiKey) => ({
          method: 'POST',
          url: 'https://api.openai.com/v1/chat/completions',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          data: {
            model: 'gpt-4-turbo-preview',
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ],
            max_tokens: 4096
          }
        }),
        parseResponse: (response) => {
          if (!response?.data?.choices?.[0]?.message?.content) {
            throw new Error('Invalid response format from OpenAI API');
          }
          return response.data.choices[0].message.content;
        }
      }
    };
  }

  evaluateEnvTemplate(template, context) {
    if (!template.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined) {
            console.warn(`Environment variable ${path} not found`);
            value = '';
          }
        } else {
          try {
            // Extract the node ID and path
            const [nodeId, ...pathParts] = path.split('.');
            const nodePath = pathParts.join('.');
            
            // Get the node's data from context
            const nodeData = context[nodeId];
            if (!nodeData) {
              console.warn(`Node data not found for ${nodeId}`);
              value = '';
            } else {
              // Evaluate the path within the node's data
              value = jq.evaluate(nodePath, nodeData);
              
              // Handle objects and arrays
              if (typeof value === 'object') {
                value = JSON.stringify(value, null, 2);
              }
            }
          } catch (error) {
            console.error('Path evaluation failed:', error);
            value = '';
          }
        }
        
        result = result.replace(match, value || '');
      }
    }
    return result;
  }

  async execute(data, inputData = null, sourceNodes = []) {
    try {
      const { prompt, integration, apiKey: encryptedKey } = data;
      
      // Build context from source nodes - use the data directly as it's already properly structured
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      if (inputData) {
        context.input = inputData;
      }

      console.log('Prompt templating context:', {
        contextKeys: Object.keys(context),
        sourceNodeIds: sourceNodes.map(n => n.id),
        sampleSourceData: sourceNodes[0]?.data,
        sampleContext: context[sourceNodes[0]?.id]
      });

      if (!integration || !prompt || !encryptedKey) {
        return formatter.errorResponse('Missing integration, prompt, or API key configuration');
      }

      // Decrypt the API key
      let decryptedApiKey;
      try {
        console.log('Decrypting API key:', encryptedKey);
        decryptedApiKey = await this.decrypt(encryptedKey);
        console.log('API key decrypted successfully')
        console.log('API key:', decryptedApiKey);
      } catch (error) {
        console.error('Failed to decrypt API key:', error);
        return formatter.errorResponse('Failed to decrypt API key');
      }

      const queryBuilder = this.queryBuilders[integration];
      if (!queryBuilder) {
        return formatter.errorResponse(`Unsupported integration: ${integration}`);
      }

      let templatedPrompt;
      try {
        templatedPrompt = this.evaluateEnvTemplate(prompt, context);
      } catch (error) {
        console.error('Prompt templating failed:', error);
        return formatter.errorResponse(`Prompt templating failed: ${error.message}`);
      }

      console.log('Templated Prompt:', templatedPrompt);
      const requestConfig = queryBuilder.buildRequest(templatedPrompt, decryptedApiKey);
      const response = await this.httpRequest(requestConfig);

      if (!response.success || response.data?.error) {
        throw new Error(response.data?.error?.message || 'Request failed');
      }

      let result;
      try {
        result = queryBuilder.parseResponse(response);
      } catch (error) {
        console.error('Response parsing failed:', error);
        return formatter.errorResponse(`Failed to parse API response: ${error.message}`);
      }

      return formatter.standardResponse(true, {
        data: result,
      });

    } catch (error) {
      console.error('Prompt node execution failed:', error);
      return formatter.errorResponse(error.message);
    }
  }
}
===========================================
<renderer/src/executor/basic/RSSNode.js>
===========================================
import Parser from 'rss-parser';
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();
const parser = new Parser({
  customFields: {
    feed: ['subtitle', 'image'],
    item: ['content', 'content:encoded', 'description']
  }
});

export default class RSSNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment, httpRequest) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
    this.httpRequest = httpRequest;
  }

  // Helper function for evaluating templates with environment variables
  evaluateEnvTemplate(template, context) {
    if (!template.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined || value === null || value === '') {
            const varName = path.startsWith('$') ? path.slice(1) : path;
            throw new Error(`Environment variable "${varName}" is not set. Please configure this variable in your environment settings.`);
          }
        } else {
          value = jq.evaluate(path, context);
        }
        
        result = result.replace(match, value);
      }
    }
    return result;
  }

  async execute(data, inputData, sourceNodes = []) {
    try {
      console.log('RSS executing with data:', data);
      console.log('Input data:', inputData);

      const { url, maxItems = 10, sortBy = 'published', sortDirection = 'desc' } = data;
      
      if (!url) {
        return formatter.errorResponse('RSS Feed URL is required');
      }

      // Build context from source nodes
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      // Template the URL with better error handling
      let templatedUrl;
      try {
        templatedUrl = this.evaluateEnvTemplate(url, context);
      } catch (error) {
        console.error('URL templating failed:', error);
        return formatter.errorResponse(error.message);
      }

      try {
        const response = await this.httpRequest({
          url: templatedUrl,
          method: 'GET',
          headers: {
            'Accept': 'application/rss+xml, application/atom+xml, application/xml, text/xml',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
          }
        });

        if (!response.success) {
          throw new Error(response.error?.message || 'Failed to fetch feed');
        }

        const feedContent = response.data.data;
        
        if (typeof feedContent !== 'string') {
          throw new Error('Invalid feed format: Expected XML string');
        }

        // Parse the feed content using rss-parser
        const feed = await parser.parseString(feedContent);
        console.log('Parsed feed:', feed);

        if (!feed) {
          throw new Error('Failed to parse feed content');
        }

        // Normalize the feed structure
        const normalizedFeed = {
          title: feed.title,
          description: feed.description || feed.subtitle,
          link: feed.link,
          image: feed.image?.url || feed.image,
          items: (feed.items || []).map(item => ({
            title: item.title,
            description: item.description || item.content || item['content:encoded'],
            link: item.link,
            published: item.pubDate || item.published || item.date || item.isoDate,
            author: item.creator || item.author || item.dc?.creator,
            id: item.id || item.guid,
            content: item['content:encoded'] || item.content || item.description,
            categories: Array.isArray(item.categories) ? item.categories : 
                       item.category ? [item.category] : []
          }))
        };

        // Sort items
        if (normalizedFeed.items.length > 0) {
          normalizedFeed.items.sort((a, b) => {
            const aDate = new Date(a[sortBy] || 0);
            const bDate = new Date(b[sortBy] || 0);
            return sortDirection === 'desc' ? 
              (bDate - aDate) : 
              (aDate - bDate);
          });

          // Limit items
          if (maxItems > 0) {
            normalizedFeed.items = normalizedFeed.items.slice(0, maxItems);
          }
        }

        return formatter.standardResponse(true, normalizedFeed);
      } catch (error) {
        console.error('Feed error:', error);
        return formatter.errorResponse(`Feed error: ${error.message}`);
      }
    } catch (error) {
      console.error('Execution error:', error);
      return formatter.errorResponse(error.message);
    }
  }

  decodeHtmlEntities(str) {
    if (!str) return '';
    const textarea = document.createElement('textarea');
    textarea.innerHTML = str;
    return textarea.value;
  }
}
===========================================
<renderer/src/executor/basic/TestNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class TestNode {
  async execute(data, inputData, sourceNodes = []) {
    try {
      const { tests = [], requireAll = true, continueOnFailure = false } = data;
      
      // Build context mapping for source nodes
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      if (!tests.length) {
        return formatter.standardResponse(true, {
          success: true,
          message: 'No tests configured',
          results: []
        });
      }
  
      // Execute each test case
      const results = [];
      let allPassed = true;
  
      for (const test of tests) {
        try {
          const result = await this.executeTestCase(test, context);
          results.push(result);
          
          if (!result.success) {
            allPassed = false;
            if (!continueOnFailure && test.stopOnFailure) {
              break;
            }
          }
        } catch (error) {
          const errorResult = {
            id: test.id,
            name: test.name,
            success: false,
            error: error.message
          };
          results.push(errorResult);
          allPassed = false;
          
          if (!continueOnFailure && test.stopOnFailure) {
            break;
          }
        }
      }
  
      // Determine overall success based on requireAll setting
      const success = requireAll ? allPassed : results.some(r => r.success);
  
      return formatter.standardResponse(true, {
        success,
        message: success ? 'All tests passed' : 'Some tests failed',
        results,
        timestamp: new Date().toISOString(),
        data: context
      });
  
    } catch (error) {
      return formatter.errorResponse(error.message);
    }
  }

  async executeTestCase(test, context) {
    try {
      const { type, operator, expected, path, header, sourceNodeId, id, name } = test;
      let actual;
      
      // Get the source node's data
      const sourceData = context[sourceNodeId];
      if (!sourceData) {
        return {
          id,
          name,
          success: false,
          error: `Source node ${sourceNodeId} not found in context`
        };
      }
    
      // Get actual value based on test type
      try {
        switch (type) {
          case 'status':
            actual = sourceData?.response?.status;
            break;
            
          case 'headers':
            const headers = sourceData?.response?.headers || {};
            const headerKey = Object.keys(headers)
              .find(key => key.toLowerCase() === header?.toLowerCase());
            actual = headers[headerKey];
            break;
            
          case 'body':
            actual = jq.evaluate(path, sourceData);
            break;
            
          default:
            throw new Error(`Unsupported test type: ${type}`);
        }
      } catch (error) {
        return {
          id,
          name,
          success: false,
          error: `Failed to get test value: ${error.message}`
        };
      }
    
      // Compare values based on operator
      let success = false;
      let message = '';
    
      try {
        switch (operator) {
          case 'equals':
            success = String(actual) === String(expected);
            message = success ? 'Values match' : 'Values do not match';
            break;
            
          case 'not_equals':
            success = String(actual) !== String(expected);
            message = success ? 'Values differ as expected' : 'Values match when they should differ';
            break;
            
          case 'contains':
            success = String(actual).includes(String(expected));
            message = success ? 'Value contains expected string' : 'Value does not contain expected string';
            break;
            
          case 'not_contains':
            success = !String(actual).includes(String(expected));
            message = success ? 'Value does not contain string as expected' : 'Value contains string when it should not';
            break;
            
          case 'greater_than':
            success = Number(actual) > Number(expected);
            message = success ? 'Value is greater' : 'Value is not greater';
            break;
            
          case 'less_than':
            success = Number(actual) < Number(expected);
            message = success ? 'Value is less' : 'Value is not less';
            break;
            
          case 'exists':
            success = actual !== undefined && actual !== null;
            message = success ? 'Value exists' : 'Value does not exist';
            break;
            
          case 'not_exists':
            success = actual === undefined || actual === null;
            message = success ? 'Value does not exist as expected' : 'Value exists when it should not';
            break;
            
          default:
            throw new Error(`Unsupported operator: ${operator}`);
        }
      } catch (error) {
        return {
          id,
          name,
          success: false,
          error: `Comparison failed: ${error.message}`
        };
      }
    
      return {
        id,
        name,
        type,
        success,
        message,
        expected,
        actual,
        operator
      };
    } catch (error) {
      return {
        id: test.id,
        name: test.name,
        success: false,
        error: error.message
      };
    }
  }
} 
===========================================
<renderer/src/executor/basic/TextDisplayNode.js>
===========================================
import formatter from '../../utils/formatter';
import JQParser from '../../utils/jq';

const jq = new JQParser();

export default class TextDisplayNode {
  constructor(getEnvVar, setEnvironmentVariable, localEnvironment, updateNodeData) {
    this.getEnvVar = getEnvVar;
    this.setEnvironmentVariable = setEnvironmentVariable;
    this.localEnvironment = localEnvironment || { variables: {} };
    this.updateNodeData = updateNodeData;  // Store the updateNodeData function
  }

  evaluateEnvTemplate(template, context) {
    if (!template?.includes('{{')) return template;
    
    let result = template;
    const matches = template.match(/\{\{(.+?)\}\}/g);
    if (matches) {
      for (const match of matches) {
        const path = match.slice(2, -2).trim();
        let value;
        
        if (path.startsWith('$')) {
          value = this.getEnvVar(path);
          if (value === undefined) {
            console.warn(`Environment variable ${path} not found`);
            value = '';
          }
        } else {
          try {
            // Extract the node ID and path
            const [nodeId, ...pathParts] = path.split('.');
            const nodePath = pathParts.join('.');
            
            // Get the node's data from context
            const nodeData = context[nodeId];
            if (!nodeData) {
              console.warn(`Node data not found for ${nodeId}`);
              value = '';
            } else {
              // First try to get data from response.data
              if (nodeData.response?.data && nodePath === 'response.data') {
                value = nodeData.response.data;
              } else {
                // Fallback to regular path evaluation
                value = jq.evaluate(nodePath, nodeData);
              }
            }
          } catch (error) {
            console.error('Path evaluation failed:', error);
            value = '';
          }
        }
        result = result.replace(match, value ?? '');
      }
    }
    return result;
  }

  async execute(data, inputData = null, sourceNodes = []) {
    try {
      const { inputText, id } = data;
      
      // Build context from source nodes
      const context = sourceNodes?.reduce((acc, source) => ({
        ...acc,
        [source.id]: source.data
      }), {}) || {};

      // Template the text
      let outputText;
      try {
        outputText = this.evaluateEnvTemplate(inputText || '', context);
        console.log('TextDisplay templating:', { inputText, outputText, context });
        
        // Update the node data with both response and outputText
        if (this.updateNodeData && id) {
          await this.updateNodeData(id, 'response', {
            data: outputText,
            success: true
          });
          await this.updateNodeData(id, 'outputText', outputText);
        }
      } catch (error) {
        console.error('Text templating failed:', error);
        outputText = 'Error: Failed to template text';
      }

      return formatter.standardResponse(true, {
        inputText,
        outputText,
        response: {
          data: outputText,
          success: true
        }
      });
    } catch (error) {
      console.error('Text display node execution failed:', error);
      return formatter.errorResponse(error.message, {
        inputText: data.inputText,
        outputText: 'Error: Execution failed'
      });
    }
  }
}
===========================================
<renderer/src/utils/formatter.js>
===========================================
import xml from './xml';

/**
 * Standard response format for all nodes
 * @param {boolean} success - Whether the operation was successful
 * @param {*} data - The data payload
 * @param {Error|string} [error] - Optional error message or object
 * @param {string} [sourceId] - ID of the node that generated this response
 * @returns {Object} Standardized response object
 */
const standardResponse = (success, data, error = null, sourceId = null) => {
  // If data is an object with status, headers, data structure, use it directly
  if (data && typeof data === 'object' && 'status' in data) {
    return {
      success,
      response: {
        status: data.status,
        headers: data.headers || {},
        data: data.data
      },
      error,
      source_id: sourceId
    };
  }

  // Otherwise wrap the data
  return {
    success,
    response: data,
    error,
    source_id: sourceId
  };
};

/**
 * Creates an error response
 * @param {Error|string} error - Error message or object
 * @param {string} [sourceId] - ID of the node that generated this error
 * @returns {Object} Standardized error response
 */
const errorResponse = (error, sourceId = null) => {
  return standardResponse(
    false, 
    null, 
    error instanceof Error ? error.message : error,
    sourceId
  );
};

/**
 * Processes input data into a consistent format
 * @param {*} input - Raw input data
 * @returns {Object} Standardized data object
 */
const processInput = (input) => {
  // If input is already in standard format, return it
  if (input && typeof input === 'object' && 'success' in input) {
    return input;
  }

  try {
    // Handle raw XML string
    if (typeof input === 'string' && input.trim().startsWith('<')) {
      try {
        const xmlDoc = xml.parse(input);
        const jsonData = xml.toObject(xmlDoc);
        return standardResponse(true, jsonData);
      } catch (error) {
        console.warn('XML parsing failed:', error);
        return standardResponse(true, input);
      }
    }

    // Handle regular data
    return standardResponse(true, input);

  } catch (error) {
    return errorResponse(error.message);
  }
};

/**
 * Extracts the actual data from a standardized response
 * @param {Object} input - Standardized input object
 * @returns {*} The actual data payload
 */
const extractData = (input) => {
  if (input && typeof input === 'object') {
    if ('success' in input && 'response' in input) {
      return input.response;
    }
    return input;
  }
  return input;
};

/**
 * Checks if input is in standard format
 * @param {*} input - Input to check
 * @returns {boolean} Whether input is in standard format
 */
const isStandardFormat = (input) => {
  return input && 
         typeof input === 'object' && 
         'success' in input && 
         'response' in input && 
         'error' in input;
};

export default {
  standardResponse,
  errorResponse,
  processInput,
  extractData,
  isStandardFormat
}; 
===========================================
<renderer/src/utils/graphUtils.js>
===========================================
export const findRootNodes = (nodes, edges) => {
  const nodesWithIncoming = new Set(edges.map(edge => edge.target));
  return nodes.filter(node => !nodesWithIncoming.has(node.id));
};

export const findNextNodes = (nodeId, edges, nodes) => {
  // Ensure edges is an array
  if (!Array.isArray(edges)) {
    console.warn('Edges is not an array:', edges);
    return [];
  }

  // Find all edges where this node is the source
  const connectedEdges = edges.filter(edge => edge.source === nodeId);
  
  // Get the target nodes for these edges
  return connectedEdges.map(edge => {
    const targetNode = nodes.find(node => node.id === edge.target);
    return targetNode;
  }).filter(Boolean); // Remove any undefined nodes
};

export const findPreviousNodes = (nodeId, edges, nodes) => {
  // Ensure edges is an array
  if (!Array.isArray(edges)) {
    console.warn('Edges is not an array:', edges);
    return [];
  }

  // Find all edges where this node is the target
  const connectedEdges = edges.filter(edge => edge.target === nodeId);
  
  // Get the source nodes for these edges
  return connectedEdges.map(edge => {
    const sourceNode = nodes.find(node => node.id === edge.source);
    return sourceNode;
  }).filter(Boolean); // Remove any undefined nodes
}; 
===========================================
<renderer/src/utils/index.js>
===========================================
import { clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

/**
 * Merge class names with Tailwind CSS classes
 * @param  {...string} inputs - Class names to merge
 * @returns {string} - Merged class names
 */
export function cn(...inputs) {
  return twMerge(clsx(inputs));
}

/**
 * Generate a unique ID
 * @returns {string} - Unique ID
 */
export function generateId() {
  return Math.random().toString(36).substring(2, 9);
}

/**
 * Format a date string
 * @param {string} date - Date string
 * @returns {string} - Formatted date
 */
export function formatDate(date) {
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });
} 
===========================================
<renderer/src/utils/jq.js>
===========================================
class JQParser {
  evaluate(path, data) {
    if (!path || !data) {
      throw new Error('Path and data are required');
    }

    // Handle empty path
    if (path.trim() === '') {
      return data;
    }

    // Split path into segments
    const segments = this.tokenizePath(path);
    let result = data;

    try {
      // Process each path segment
      for (const segment of segments) {
        result = this.evaluateSegment(segment, result);
      }

      return result;
    } catch (error) {
      throw new Error(`Error evaluating path '${path}': ${error.message}`);
    }
  }

  tokenizePath(path) {
    // Split on dots while preserving array operations
    const tokens = [];
    let currentToken = '';
    let inBrackets = 0;

    for (let i = 0; i < path.length; i++) {
      const char = path[i];
      
      if (char === '[') {
        inBrackets++;
      } else if (char === ']') {
        inBrackets--;
      }

      if (char === '.' && inBrackets === 0) {
        if (currentToken) {
          tokens.push(currentToken);
          currentToken = '';
        }
      } else {
        currentToken += char;
      }
    }

    if (currentToken) {
      tokens.push(currentToken);
    }

    return tokens;
  }

  evaluateSegment(segment, data) {
    // Handle array operations (e.g., data[].id)
    if (segment.endsWith('[]')) {
      const arrayProp = segment.slice(0, -2);
      if (!data || !(arrayProp in data)) {
        throw new Error(`Property '${arrayProp}' not found`);
      }
      if (!Array.isArray(data[arrayProp])) {
        throw new Error(`Expected array at '${arrayProp}'`);
      }
      return data[arrayProp];
    }

    // Handle array mapping (e.g., id after data[])
    if (Array.isArray(data)) {
      return data.map(item => {
        if (!(segment in item)) {
          throw new Error(`Property '${segment}' not found in array item`);
        }
        return item[segment];
      });
    }

    // Handle array index access (e.g., data[0])
    if (segment.includes('[') && segment.includes(']')) {
      const [prop, indexExpr] = segment.split('[');
      const index = parseInt(indexExpr.replace(']', ''), 10);

      if (!data || !(prop in data)) {
        throw new Error(`Property '${prop}' not found`);
      }

      if (!Array.isArray(data[prop])) {
        throw new Error(`Expected array at '${prop}'`);
      }

      if (isNaN(index) || index < 0 || index >= data[prop].length) {
        throw new Error(`Invalid array index: ${indexExpr}`);
      }

      return data[prop][index];
    }

    // Handle regular object property access
    if (!data || typeof data !== 'object') {
      throw new Error(`Cannot access property '${segment}' of ${data}`);
    }

    if (!(segment in data)) {
      throw new Error(`Property '${segment}' not found`);
    }

    return data[segment];
  }
}

export default JQParser;
===========================================
<renderer/src/utils/regex.js>
===========================================
/**
 * A utility for safe regex operations
 */

// Maximum time (in milliseconds) to allow a regex operation to run
const REGEX_TIMEOUT = 1000;

// Maximum input length to prevent catastrophic backtracking
const MAX_INPUT_LENGTH = 1000000; // 1MB

// Maximum pattern length
const MAX_PATTERN_LENGTH = 1000;

/**
 * Predefined safe patterns for common use cases
 */
export const PATTERNS = {
  // Text extraction
  WORDS: '\\w+',
  SENTENCES: '[^.!?]+[.!?]',
  PARAGRAPHS: '\\n\\s*\\n',
  
  // Data formats
  EMAIL: '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}',
  URL: 'https?://[\\w\\d.-]+\\.[a-zA-Z]{2,}(?:/[\\w\\d./-]*)*',
  IP_ADDRESS: '\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b',
  DATE_ISO: '\\d{4}-\\d{2}-\\d{2}',
  TIME_24H: '(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d',
  
  // Common formats
  PHONE_BASIC: '\\+?\\d{10,}',
  ZIPCODE_US: '\\d{5}(?:-\\d{4})?',
  
  // Programming
  JSON_PROPS: '"([^"]+)":',
  HTML_TAGS: '<([^>]+)>',
  COMMENTS_LINE: '\\/\\/.*$',
  COMMENTS_BLOCK: '\\/\\*[\\s\\S]*?\\*\\/',
};

/**
 * Error class for regex timeouts
 */
class RegexTimeoutError extends Error {
  constructor(message = 'Regex evaluation timed out') {
    super(message);
    this.name = 'RegexTimeoutError';
  }
}

/**
 * Validates a regex pattern for safety
 */
function validatePattern(pattern) {
  if (!pattern) {
    throw new Error('Regex pattern is required');
  }
  
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new Error(`Pattern exceeds maximum length of ${MAX_PATTERN_LENGTH} characters`);
  }
}

/**
 * Validates input text length
 */
function validateInput(input) {
  if (input.length > MAX_INPUT_LENGTH) {
    throw new Error(`Input exceeds maximum length of ${MAX_INPUT_LENGTH} characters`);
  }
}

/**
 * Executes a regex operation with a timeout
 */
function withTimeout(operation) {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      reject(new RegexTimeoutError());
    }, REGEX_TIMEOUT);

    try {
      const result = operation();
      clearTimeout(timeoutId);
      resolve(result);
    } catch (error) {
      clearTimeout(timeoutId);
      reject(error);
    }
  });
}

/**
 * Safely executes a regex match operation
 * @param {string} pattern - The regex pattern
 * @param {string} input - The input text
 * @param {string} flags - Regex flags (default: 'g')
 * @returns {Promise<Object>} Match results
 */
export async function analyze(pattern, input, flags = 'g') {
  validatePattern(pattern);
  validateInput(input);
  
  return withTimeout(() => {
    try {
      const regex = new RegExp(pattern, flags);
      const matches = [];
      let match;

      while ((match = regex.exec(input)) !== null) {
        matches.push(match[0]);  // Just store the matched text
        
        // Prevent infinite loops
        if (match.index === regex.lastIndex) {
          regex.lastIndex++;
        }
      }

      return {
        success: true,
        matches
      };
    } catch (error) {
      return {
        success: false,
        matches: []
      };
    }
  });
}

export const regex = {
  PATTERNS,
  analyze
};

export default regex; 
===========================================
<renderer/src/utils/storageUtils.js>
===========================================
// storageUtils.js
import { openDB } from 'idb';

const DB_NAME = 'workflow_db';
const STORE_NAME = 'workflow_store';
const DB_VERSION = 1;

export const DEFAULT_STORAGE = {
  type: 'memory',
  data: new Map()
};

export const initStorage = async () => {
  // First try IndexedDB
  try {
    const db = await openDB(DB_NAME, DB_VERSION, {
      upgrade(db) {
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME);
        }
      },
    });
    
    // Test write to verify we can actually use IndexedDB
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    await store.put({ test: 'test' }, 'test_key');
    await tx.done;
    
    return {
      type: 'indexedDB',
      db
    };
  } catch (error) {
    console.log('IndexedDB not available, falling back to localStorage:', error);
    
    // Test localStorage
    try {
      localStorage.setItem('test', 'test');
      localStorage.removeItem('test');
      return {
        type: 'localStorage'
      };
    } catch (error) {
      console.warn('Neither IndexedDB nor localStorage are available:', error);
      return DEFAULT_STORAGE;
    }
  }
};

export const loadState = async (storage = DEFAULT_STORAGE) => {
  try {
    let savedState = null;
    
    switch (storage.type) {
      case 'indexedDB':
        const tx = storage.db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        savedState = await store.get('workflow_data');
        break;
        
      case 'localStorage':
        const data = localStorage.getItem('workflow_data');
        savedState = data ? JSON.parse(data) : null;
        break;
      
      case 'memory':
        savedState = storage.data.get('workflow_data');
        break;
    }
    
    // If we have saved state, ensure all expected properties exist
    if (savedState) {
      savedState.nodes = savedState.nodes || [];
      savedState.edges = savedState.edges || [];
      savedState.nodeCounter = savedState.nodeCounter || {};
      savedState.nodeSequence = savedState.nodeSequence || {};
    }
    
    return savedState;
  } catch (error) {
    console.error('Failed to load state:', error);
    return null;
  }
};

export const saveState = async (storage = DEFAULT_STORAGE, state) => {
  if (!state) return;
  
  try {
    const cleanState = cleanStateForStorage(state);
    
    switch (storage.type) {
      case 'indexedDB':
        const tx = storage.db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        await store.put(cleanState, 'workflow_data');
        await tx.done;
        break;
        
      case 'localStorage':
        localStorage.setItem('workflow_data', JSON.stringify(cleanState));
        break;
        
      case 'memory':
        storage.data.set('workflow_data', cleanState);
        break;
    }
  } catch (error) {
    console.error('Failed to save state:', error);
  }
};

export const clearState = async (storage = DEFAULT_STORAGE) => {
  try {
    switch (storage.type) {
      case 'indexedDB':
        const tx = storage.db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        await store.delete('workflow_data');
        await tx.done;
        break;
        
      case 'localStorage':
        localStorage.removeItem('workflow_data');
        break;
        
      case 'memory':
        storage.data.delete('workflow_data');
        break;
    }
  } catch (error) {
    console.error('Failed to clear state:', error);
  }
};

// Helper functions for cleaning data
const cleanNodeData = (node) => {
  const cleanData = { ...node };
  if (cleanData.data) {
    Object.keys(cleanData.data).forEach(key => {
      if (typeof cleanData.data[key] === 'function') {
        delete cleanData.data[key];
      }
    });
  }
  delete cleanData.dragHandle;
  delete cleanData.dragging;
  delete cleanData.selected;
  return cleanData;
};

const cleanEdgeData = (edge) => {
  const cleanData = { ...edge };
  delete cleanData.selected;
  delete cleanData.updatable;
  return cleanData;
};

const cleanStateForStorage = (state) => {
  const cleanState = { ...state };
  if (cleanState.nodes) {
    cleanState.nodes = cleanState.nodes.map(cleanNodeData);
  }
  if (cleanState.edges) {
    cleanState.edges = cleanState.edges.map(cleanEdgeData);
  }
  Object.keys(cleanState).forEach(key => {
    if (typeof cleanState[key] === 'function') {
      delete cleanState[key];
    }
  });
  return cleanState;
};
===========================================
<renderer/src/utils/xml.js>
===========================================
import {convertXML} from 'simple-xml-to-json';
/**
 * Parse XML string into a DOM Document
 * @param {string} xmlString - The XML string to parse
 * @returns {Document} The parsed XML document
 */
export function parseXML(xmlString) {
  try {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
    
    // Check for parsing errors
    const parseError = xmlDoc.querySelector('parsererror');
    if (parseError) {
      throw new Error(parseError.textContent);
    }
    
    return xmlDoc;
  } catch (error) {
    console.log('XML parsing error:', xmlString);
    throw new Error(`XML parsing error: ${error.message}`);
  }
}

/**
 * Evaluate an XPath expression against an XML document
 * @param {string} xpath - The XPath expression
 * @param {Document|Node} xmlNode - The XML document or node to query
 * @param {string} returnType - The type of result to return ('string', 'number', 'boolean', 'nodes')
 * @returns {string|number|boolean|Node[]} The query result
 */
export function evaluateXPath(xpath, xmlNode, returnType = 'nodes') {
  try {
    const resolver = xmlNode.createNSResolver(xmlNode.documentElement);
    let result;

    switch (returnType) {
      case 'string':
        result = xmlNode.evaluate(
          xpath,
          xmlNode,
          resolver,
          XPathResult.STRING_TYPE,
          null
        );
        return result.stringValue;

      case 'number':
        result = xmlNode.evaluate(
          xpath,
          xmlNode,
          resolver,
          XPathResult.NUMBER_TYPE,
          null
        );
        return result.numberValue;

      case 'boolean':
        result = xmlNode.evaluate(
          xpath,
          xmlNode,
          resolver,
          XPathResult.BOOLEAN_TYPE,
          null
        );
        return result.booleanValue;

      case 'nodes':
        result = xmlNode.evaluate(
          xpath,
          xmlNode,
          resolver,
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
          null
        );
        const nodes = [];
        for (let i = 0; i < result.snapshotLength; i++) {
          nodes.push(result.snapshotItem(i));
        }
        return nodes;

      default:
        throw new Error(`Unsupported return type: ${returnType}`);
    }
  } catch (error) {
    throw new Error(`XPath evaluation error: ${error.message}`);
  }
}

/**
 * Convert XML nodes to a JavaScript object/array
 * @param {Node|Node[]} nodes - The XML node(s) to convert
 * @returns {object|array} The converted JavaScript object/array
 */
export function xmlNodesToObject(nodes) {
  if (Array.isArray(nodes)) {
    return nodes.map(node => nodeToObject(node));
  }
  return nodeToObject(nodes);
}

/**
 * Convert a single XML node to a JavaScript object
 * @param {Node} node - The XML node to convert
 * @returns {object|string} The converted JavaScript object or string
 */
function nodeToObject(node) {
  // Handle text nodes
  if (node.nodeType === Node.TEXT_NODE) {
    const text = node.textContent.trim();
    return text || undefined;
  }

  // Handle element nodes
  if (node.nodeType === Node.ELEMENT_NODE) {
    const obj = {};
    
    // Add attributes if present
    if (node.attributes.length > 0) {
      obj['@attributes'] = {};
      for (const attr of node.attributes) {
        obj['@attributes'][attr.name] = attr.value;
      }
    }

    // Process child nodes
    for (const child of node.childNodes) {
      const childResult = nodeToObject(child);
      if (childResult !== undefined) {
        const name = child.nodeName;
        if (name === '#text') {
          // If it's just text content, assign it directly
          if (Object.keys(obj).length === 0) {
            return childResult;
          }
          obj['#text'] = childResult;
        } else {
          // Handle multiple children with same name
          if (obj[name]) {
            if (!Array.isArray(obj[name])) {
              obj[name] = [obj[name]];
            }
            obj[name].push(childResult);
          } else {
            obj[name] = childResult;
          }
        }
      }
    }

    return obj;
  }

  return undefined;
}

export function to_json(xmlString) {
  return convertXML(xmlString);
}

function simplifyXmlStructure(obj) {
  console.log('simplifyXmlStructure - obj:', obj);
  // Handle arrays of children
  if (obj && obj.children && Array.isArray(obj.children)) {
    // Convert children array to object
    const result = obj.children.reduce((acc, child) => {
      const key = Object.keys(child)[0];
      
      // If the child has its own children, recursively process them
      if (child[key].children) {
        const processedChild = simplifyXmlStructure(child[key]);
        
        // If we already have this key, make it an array
        if (acc[key]) {
          if (!Array.isArray(acc[key])) {
            acc[key] = [acc[key]];
          }
          acc[key].push(processedChild);
        } else {
          acc[key] = processedChild;
        }
      } else if (child[key].content) {
        // If it's a leaf node with content, just get the content
        acc[key] = child[key].content;
      }
      
      return acc;
    }, {});

    return result;
  }

  // If it's an object but not a children array
  if (obj && typeof obj === 'object') {
    // If it has content, return the content
    if ('content' in obj) {
      return obj.content;
    }

    // Otherwise process each property
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = simplifyXmlStructure(value);
    }
    return result;
  }

  return obj;
}

// Update the toObject function to use the new simplifier
function toObject(xmlDoc) {
  // Your existing XML to initial object conversion
  const rawObj = xmlNodesToObject(xmlDoc.documentElement.childNodes);
  
  // Simplify the structure
  const simplified = simplifyXmlStructure(rawObj);
  
  // If posts is not an array but should be, wrap it
  if (simplified.posts && simplified.posts.post && !Array.isArray(simplified.posts)) {
    simplified.posts = [simplified.posts];
  }
  
  return simplified;
}

export const xml = {
  parse: parseXML,
  evaluate: evaluateXPath,
  toObject: toObject,
  to_json: to_json
};

export default xml; 
